'<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Git</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Criando o meu próprio git</h1>
                    </section>
                    <br />

                    <section>
                        <div class="tags">
                            <small class="tag">Git</small>
                            <small class="tag">C#</small>
                            <small class="tag">Estrutura de dados</small>
                            <small class="tag">.NET</small>
                            <small class="tag">CVS</small>
                            <small class="tag">SVN</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div class="blog-text">
                            <p>
                                Há algum tempo, me deparei com o artigo
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">Write Yourself a Git</a>
                                Ao lê-lo, despertou em mim um desejo que se somou a uma vontade antiga que eu já
                                possuía: implementar uma versão simplificada do Git, com o objetivo de exercitar, de
                                maneira prática, tudo aquilo que eu já havia estudado em
                                <a
                                    href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects"
                                    target="_blank"
                                    class="blog-link"
                                    >Git internals.</a
                                >
                            </p>
                            <p>
                                No dia em que escrevo este artigo, o Git já completou 20 anos de existência, e acredito
                                que, há mais de 15 anos, vem se tornando uma ferramenta <strong>obrigatória</strong> no
                                dia a dia de qualquer pessoa que se diz programadora. Entender como essa ferramenta
                                funciona é tão importante quanto compreender algoritmos e estruturas de dados.
                            </p>
                            <p>
                                Obviamente, <strong>entender</strong> como algo funciona não é a mesma coisa que saber
                                <strong>usar</strong>. Qualquer pessoa aprende, em uma tarde, os comandos básicos, e em
                                uma semana já consegue incorporar o Git por completo em seu fluxo de trabalho. No
                                entanto, poucos realmente sabem o que está acontecendo com seus arquivos, e muito menos
                                compreendem o motivo de estarem usando o Git.
                            </p>
                            <p>
                                Obtive uma experiencia muito interessante, que durou aproximadamente 3 semanas, eu
                                implementei 14 comandos do git (talvez, com o passar do tempo, implemente ainda mais), e
                                cada comando constrói e manipula os tres princiapis objetos do git: Blob, Tree e Commit.
                                Dito isso, o meu objetivo nesse artigo, é descrever como foi essa experiencia, o que eu
                                aprendi nesse periodo.
                            </p>
                            <p>
                                Além de implementar mais comandos e funcionalidades do que o artigo "Write Yourself a
                                Git" apresenta, também optei por utilizar uma linguagem de programação diferente do
                                Python. No meu caso, escolhi C# (.NET 9.0) por preferência pessoal. Este projeto pode
                                ser desenvolvido com fluidez em qualquer linguagem moderna de alto nível.
                            </p>
                            <p>
                                Obviamente, não vou conseguir documentar e detalhar todos os comandos, apenas vou citar
                                os principais para explicar a estrutura do git, para entender como implementei cada
                                comando, acesse o projeto no
                                <a
                                    href="https://github.com/AdrielSantoss/Write-Yourself-A-Git"
                                    target="_blank"
                                    class="blog-link"
                                    >Github</a
                                >.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>
                            <p>
                                Prometo não me alongar muito, portanto, tente não dormir… Se você quer realmente
                                entender o Git, conhecer um pouco do passado nebuloso do período pré-Git é extremamente
                                importante. Somente assim você vai compreender o real motivo de estar usando o Git hoje.
                            </p>
                            <p>
                                Antes do Git, os sistemas de controle de versão mais utilizados eram: SVN, BitKeeper e
                                CVS. Pesquisando mais a fundo, encontramos nomes como Visual SourceSafe, Mercurial,
                                Bazaar, e, ainda mais antigos, SCCS e RCS. Todos, sem exceção, apresentavam soluções
                                complexas e problemáticas demais para lidar com um problema ainda mais desafiador:
                                gerenciar versões de arquivos.
                            </p>
                            <p>
                                Cada uma dessas ferramentas surgiu com o objetivo de corrigir problemas de seus
                                concorrentes, mas, ao fazer isso, gerava ou ignorava outros problemas. Um exemplo
                                clássico é a "evolução" entre o SVN (Subversion) e o CVS (Concurrent Versions System),
                                ambos gratuitos e de código aberto.
                            </p>
                            <p>
                                Em resumo, CVS e SVN apresentavam um sistema centralizado, ou seja, tudo era gerenciado
                                e monitorado por um servidor central. Por exemplo, para fazer commits (o famoso
                                "comitar"), era necessário solicitar permissão ao servidor.
                            </p>
                            <p>
                                O CVS era considerado o “inferno na terra” quando se tratava de sistemas de
                                versionamento. Alguns dos seus principais problemas/limitações eram: apenas arquivos
                                eram versionados, diretórios não; arquivos se perdiam no histórico quando eram movidos
                                ou renomeados; e commits não eram operações atômicas — portanto, se um commit falhasse
                                no meio, havia o risco de corromper todo o repositório.
                            </p>
                            <p>
                                Quando surgiu, o SVN corrigiu todos esses problemas, mas isso não o tornou
                                necessariamente “melhor”. O SVN ainda possuía várias limitações, e um de seus principais
                                problemas não estava na parte técnica, mas sim no marketing, que utilizava o slogan:
                                “SVN is CVS done right”.
                            </p>
                            <p>
                                Uma das críticas mais notórias ao SVN e à sua campanha de marketing veio de ninguém
                                menos que Linus Torvalds, durante sua famosa palestra sobre o Git no Google:
                                <a href="https://www.youtube.com/watch?v=idLyobOhtO4m" class="blog-link" target="_blank"
                                    >Linus Torvalds, Google Tech Talk.</a
                                >
                                Recomendo fortemente assistir a essa palestra para compreender as complicações que esses
                                sistemas geravam no dia a dia dos programadores no fim dos anos 90 e início dos anos
                                2000.
                            </p>
                            <p>
                                Em resumo, os principais problemas do SVN eram: merges frágeis, com risco de conflitos
                                complexos (two-way merge); criação de branches ainda era uma tarefa cara (apesar do
                                marketing afirmar o contrário); dificuldade em comparar branches complexos; problemas de
                                desempenho em projetos grandes; entre outros.
                            </p>
                            <p>
                                O branching no SVN foi uma melhoria em relação ao CVS, mas ainda apresentava limitações
                                que o tornavam caro em termos práticos. Criar um branch no CVS/SVN era equivalente a
                                <strong>duplicar</strong> o diretório principal. Agora imagine fazer isso com frequência
                                em projetos gigantes como o kernel do Linux... Mesclar dois branches no SVN era uma
                                operação <strong>custosa</strong> e, principalmente, <strong>ineficiente</strong>,
                                devido ao fraco algoritmo de merge, chamado <strong>two-way merge</strong>. Na prática,
                                realizar um merge significava comparar TUDO de um branch contra TUDO do branch trunk
                                (branch principal do SVN, equivalente ao master/main do Git). Esse processo fazia com
                                que conflitos surgissem com extrema facilidade. Já o CVS aplicava o
                                <b>three-way merge</b>, de forma limitada, pois não rastreava bem histórico de merges
                                anteriores. (Nesse aspecto, podemos concluir que SVN não era um CVS feito direito...)
                            </p>
                            <p>
                                Devido a todos os problemas do CVS e do SVN, Linus Torvalds optou por utilizar o
                                BitKeeper no desenvolvimento do kernel no início dos anos 2000. Os principais motivos
                                dessa escolha eram que o BitKeeper era um sistema distribuído, lidava melhor com grandes
                                bases de código (um ponto crítico em que CVS e SVN falhavam) e oferecia um mecanismo de
                                merge relativamente eficiente.
                            </p>
                            <p>
                                A BitMover, empresa responsável pelo BitKeeper, ofereceu licenças gratuitas para uso no
                                kernel Linux, desde que não fossem utilizadas para desenvolver ferramentas concorrentes.
                                Apesar da contradição ideológica de depender de um software proprietário para criar um
                                software livre, tudo corria bem até que, em 2005, o acesso gratuito ao BitKeeper foi
                                revogado.
                            </p>
                            <p>
                                Esse foi o ponto decisivo que levou diretamente ao nascimento do Git. A BitMover começou
                                a desconfiar que a comunidade do Linux estava realizando engenharia reversa do protocolo
                                de rede do BitKeeper. De certa forma, isso era verdade: muitos desenvolvedores não
                                aceitavam a ideia de depender de um software fechado para um projeto como o kernel, e
                                alguns começaram a criar alternativas capazes de ler e interagir com repositórios do
                                BitKeeper. A mais conhecida delas foi o <em>SourcePuller</em>.
                            </p>
                            <p>
                                Após a revogação das licenças gratuitas do BitKeeper, Linus Torvalds decidiu resolver
                                esse problema de forma definitiva. Ele queria um sistema de controle de versão que
                                atendesse aos seguintes requisitos: ser distribuído, eficiente, rápido, resistente à
                                corrupção de dados e 100% software livre.
                            </p>
                            <p>
                                As opções disponíveis na época eram: Mercurial, Bazaar, Darcs e Monotone. Todas, no
                                entanto, apresentavam problemas de desempenho em projetos grandes como o kernel. Com
                                essas alternativas descartadas, restou apenas uma saída: criar um novo sistema de
                                versionamento. Assim nasceu o Git, que se tornaria o sistema de controle de versão mais
                                utilizado da história.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Init e Objects</h1>
                            <p>
                                Em resumo, o Git é um sistema que cria e manipula um "banco de dados de objetos". Esses
                                objetos são: <em>Blob</em>, <em>Tree</em>, <em>Commit</em> e <em>Tag</em>. Sendo o
                                <em>Tag</em> um objeto não essencial para o funcionamento do Git. Implementei comandos
                                capazes de criar, excluir e editar os três objetos essenciais. Conforme eu for
                                detalhando a implementação de cada comando, também explicarei como esses objetos
                                funcionam e se relacionam.
                            </p>
                            <p>
                                O primeiro comando abordado será o de inicialização do repositório
                                <em>.gitadr</em> (equivalente ao <em>.git</em>). É dentro desse repositório (ou pasta,
                                se você for da terra do Windows) que são armazenados os objetos e arquivos auxiliares
                                necessários para o funcionamento do Git.
                            </p>
                            <pre><code>using Git.Core;
using System.Text;

namespace Git.Commands
{
    public class Init
    {
        public static void Execute()
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");

            if (Directory.Exists(gitDir))
            {
                Console.WriteLine("Repositório .gitadr já existe.");
                return;
            }

            Directory.CreateDirectory(gitDir);
            Directory.CreateDirectory(Path.Combine(gitDir, "objects"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs", "heads"));

            File.WriteAllText(Path.Combine(gitDir, "refs", "heads", "master"), string.Empty);
            File.WriteAllText(Path.Combine(gitDir, "HEAD"), $"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}master");

            Console.WriteLine($"Repositório inicializado em {gitDir}");
        }
    }
}</code></pre>

                            <p>Estrutura criada pelo comando <code>init</code>:</p>

                            <p>
                                <strong>.gitadr</strong>: diretório principal do sistema ("adr" = <em>Adriel</em>).
                                <br />

                                <strong>/objects</strong>: onde ficam os objetos do Git (<em>Blob</em>, <em>Tree</em>,
                                <em>Commit</em> e <em>Tag</em>). <br />

                                <strong>/refs/heads</strong>: contém os arquivos que representam os branches. O projeto
                                já inicia com o branch <code>master</code>. <br />

                                <strong>HEAD</strong>: arquivo que guarda a referência do branch atual, iniciando com
                                <code>ref: refs/heads/master</code>. <br />
                            </p>

                            <p>
                                Esse comando não tem grandes segredos: ele basicamente cria diretórios e arquivos. Note
                                que mantive a convenção de usar um nome iniciado por ponto (<code>.gitadr</code>) para o
                                diretório principal. Em sistemas Unix-like (Linux e macOS), arquivos e pastas que
                                começam com <code>.</code> são tratados como ocultos.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Hash-Object</h1>

                            <p>
                                Este é um dos comandos
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">plumbing</a> mais
                                importantes do Git. Seu objetivo é transformar um arquivo em um objeto <em>blob</em> e
                                armazená-lo no repositório.
                            </p>
                            <p>
                                Um objeto <em>blob</em> (<strong>binary large object</strong>) nada mais é do que um
                                conjunto de bytes que guarda apenas duas informações: o tamanho do conteúdo e o próprio
                                conteúdo do arquivo. Sua estrutura binária segue o formato:
                            </p>
                            <pre><code>blob content.length\0contentBytes</code></pre>
                            <p>
                                <strong><code>blob content.length</code></strong
                                >: Cabeçalho do objeto. É composto pela palavra <code>blob</code>, seguida de um espaço
                                em branco e do tamanho total do conteúdo em bytes. <br />

                                <strong><code>\0</code></strong
                                >: Caractere nulo que separa o cabeçalho do conteúdo. <br />

                                <strong><code>contentBytes</code></strong
                                >: O conteúdo do arquivo em si, armazenado em formato binário.
                            </p>
                            <p>
                                Repare que o <em>blob</em> não guarda informações como nome do arquivo, autor ou data de
                                criação. Para ele, esses metadados são irrelevantes: o que importa é apenas o conteúdo
                                puro.
                            </p>
                            <p>
                                Depois de combinar os bytes do cabeçalho com os bytes do conteúdo, o resultado é
                                processado pela função
                                <strong>SHA-1</strong>. Essa função gera um identificador único de 20 bytes, que em
                                seguida é convertido para uma representação em string hexadecimal. O resultado é algo
                                como:
                            </p>

                            <pre><code>658e12ad10bfd93dcf0712de258795828f6c4240</code></pre>

                            <p>
                                Provavelmente esse formato já lhe parece familiar: é o hash que identifica TODOS os
                                objetos no Git.
                            </p>
                            <p></p>
                        </div>
                    </section>
                    <!-- <section class="portfolio-description">
                        <h1 class="h4 portfolio-title">Referencias</h1>
                        <h6>CVS:</h6>
                        <p>https://www.projecthut.com/cvs-version-control-system-explained/?utm_source=chatgpt.com</p>
                        <p>
                            https://web.mit.edu/macdev/Development/Documentation/www/CVS%20Documentation/Understanding%20CVS.html?utm_source=chatgpt.com
                        </p>
                        <p>https://tartarus.org/~simon/cvs-vs-svn.html</p>
                    </section> -->
                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
    </body>
</html>
