<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Git</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Criando o meu próprio git</h1>
                        <div>
                            <small style="color: white;">20/09/2025</small> -                 
                            <a
                                href="https://github.com/AdrielSantoss/Write-Yourself-A-Git"
                                target="_blank"
                                class="blog-link">Projeto (Github)</a>
                        </div>
                        <div class="tags">
                            <small class="tag">Git</small>
                            <small class="tag">C#</small>
                            <small class="tag">Estrutura de dados</small>
                            <small class="tag">.NET</small>
                            <small class="tag">CVS</small>
                            <small class="tag">SVN</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div class="blog-text">
                            <p>
                                Há algum tempo, me deparei com o artigo
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">Write Yourself a Git</a>
                                Ao lê-lo, despertou em mim um desejo que se somou a uma vontade antiga que eu já
                                possuía: implementar uma versão simplificada do Git, com o objetivo de exercitar, de
                                maneira prática, tudo aquilo que eu já havia estudado em
                                <a
                                    href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects"
                                    target="_blank"
                                    class="blog-link"
                                    >Git internals.</a
                                >
                            </p>
                            <p>
                                No dia em que escrevo este artigo, o Git já completou 20 anos de existência, e acredito
                                que, há mais de 15 anos, vem se tornando uma ferramenta <strong>obrigatória</strong> no
                                dia a dia de qualquer pessoa que se diz programadora. Entender como essa ferramenta
                                funciona é tão importante quanto compreender algoritmos e estruturas de dados.
                            </p>
                            <p>
                                Obviamente, <strong>entender</strong> como algo funciona não é a mesma coisa que saber
                                <strong>usar</strong>. Qualquer pessoa aprende, em uma tarde, os comandos básicos, e em
                                uma semana já consegue incorporar o Git por completo em seu fluxo de trabalho. No
                                entanto, poucos realmente sabem o que está acontecendo com seus arquivos, e muito menos
                                compreendem o motivo de estarem usando o Git.
                            </p>
                            <p>
                                Obtive uma experiência muito interessante, que durou aproximadamente 3 semanas, eu
                                implementei 15 comandos do git (talvez, com o passar do tempo, implemente ainda mais), e
                                cada comando constrói e manipula os tres princiapis objetos do git: Blob, Tree e Commit.
                                Dito isso, o meu objetivo nesse artigo, é descrever como foi essa experiência, o que eu
                                aprendi nesse periodo.
                            </p>
                            <p>
                                Além de implementar mais comandos e funcionalidades do que o artigo "Write Yourself a
                                Git" apresenta, também optei por utilizar uma linguagem de programação diferente do
                                Python. No meu caso, escolhi C# (.NET 9.0) por preferência pessoal. Este projeto pode
                                ser desenvolvido com fluidez em qualquer linguagem moderna de alto nível.
                            </p>
                            <p>
                                Obviamente, não vou conseguir documentar e detalhar todos os comandos, apenas vou citar
                                os principais para explicar a estrutura do git, para entender como implementei cada
                                comando, acesse o projeto no
                                <a
                                    href="https://github.com/AdrielSantoss/Write-Yourself-A-Git"
                                    target="_blank"
                                    class="blog-link"
                                    >Github</a
                                >.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>
                            <p>
                                Prometo não me alongar muito, portanto, tente não dormir… Se você quer realmente
                                entender o Git, conhecer um pouco do passado nebuloso do período pré-Git é extremamente
                                importante. Somente assim você vai compreender o real motivo de estar usando o Git hoje.
                            </p>
                            <p>
                                Antes do Git, os sistemas de controle de versão mais utilizados eram: SVN, BitKeeper e
                                CVS. Pesquisando mais a fundo, encontramos nomes como Visual SourceSafe, Mercurial,
                                Bazaar, e, ainda mais antigos, SCCS e RCS. Todos, sem exceção, apresentavam soluções
                                complexas e problemáticas demais para lidar com um problema ainda mais desafiador:
                                gerenciar versões de arquivos.
                            </p>
                            <p>
                                Cada uma dessas ferramentas surgiu com o objetivo de corrigir problemas de seus
                                concorrentes, mas, ao fazer isso, gerava ou ignorava outros problemas. Um exemplo
                                clássico é a "evolução" entre o SVN (Subversion) e o CVS (Concurrent Versions System),
                                ambos gratuitos e de código aberto.
                            </p>
                            <p>
                                Em resumo, CVS e SVN apresentavam um sistema centralizado, ou seja, tudo era gerenciado
                                e monitorado por um servidor central. Por exemplo, para fazer commits (o famoso
                                "comitar"), era necessário solicitar permissão ao servidor.
                            </p>
                            <p>
                                O CVS era considerado o “inferno na terra” quando se tratava de sistemas de
                                versionamento. Alguns dos seus principais problemas/limitações eram: apenas arquivos
                                eram versionados, diretórios não; arquivos se perdiam no histórico quando eram movidos
                                ou renomeados; e commits não eram operações atômicas — portanto, se um commit falhasse
                                no meio, havia o risco de corromper todo o repositório.
                            </p>
                            <p>
                                Quando surgiu, o SVN corrigiu todos esses problemas, mas isso não o tornou
                                necessariamente “melhor”. O SVN ainda possuía várias limitações, e um de seus principais
                                problemas não estava na parte técnica, mas sim no marketing, que utilizava o slogan:
                                “SVN is CVS done right”.
                            </p>
                            <p>
                                Uma das críticas mais notórias ao SVN e à sua campanha de marketing veio de ninguém
                                menos que Linus Torvalds, durante sua famosa palestra sobre o Git no Google:
                                <a href="https://www.youtube.com/watch?v=idLyobOhtO4m" class="blog-link" target="_blank"
                                    >Linus Torvalds, Google Tech Talk.</a
                                >
                                Recomendo fortemente assistir a essa palestra para compreender as complicações que esses
                                sistemas geravam no dia a dia dos programadores no fim dos anos 90 e início dos anos
                                2000.
                            </p>
                            <p>
                                Em resumo, os principais problemas do SVN eram: merges frágeis, com risco de conflitos
                                complexos (two-way merge); criação de branches ainda era uma tarefa cara (apesar do
                                marketing afirmar o contrário); dificuldade em comparar branches complexos; problemas de
                                desempenho em projetos grandes; entre outros.
                            </p>
                            <p>
                                O branching no SVN foi uma melhoria em relação ao CVS, mas ainda apresentava limitações
                                que o tornavam caro em termos práticos. Criar um branch no CVS/SVN era equivalente a
                                <strong>duplicar</strong> o diretório principal. Agora imagine fazer isso com frequência
                                em projetos gigantes como o kernel do Linux... Mesclar dois branches no SVN era uma
                                operação <strong>custosa</strong> e, principalmente, <strong>ineficiente</strong>,
                                devido ao fraco algoritmo de merge, chamado <strong>two-way merge</strong>. Na prática,
                                realizar um merge significava comparar TUDO de um branch contra TUDO do branch trunk
                                (branch principal do SVN, equivalente ao master/main do Git). Esse processo fazia com
                                que conflitos surgissem com extrema facilidade. Já o CVS aplicava o
                                <b>three-way merge</b>, de forma limitada, pois não rastreava bem histórico de merges
                                anteriores. (Nesse aspecto, podemos concluir que SVN não era um CVS feito direito...)
                            </p>
                            <p>
                                Devido a todos os problemas do CVS e do SVN, Linus Torvalds optou por utilizar o
                                BitKeeper no desenvolvimento do kernel no início dos anos 2000. Os principais motivos
                                dessa escolha eram que o BitKeeper era um sistema distribuído, lidava melhor com grandes
                                bases de código (um ponto crítico em que CVS e SVN falhavam) e oferecia um mecanismo de
                                merge relativamente eficiente.
                            </p>
                            <p>
                                A BitMover, empresa responsável pelo BitKeeper, ofereceu licenças gratuitas para uso no
                                kernel Linux, desde que não fossem utilizadas para desenvolver ferramentas concorrentes.
                                Apesar da contradição ideológica de depender de um software proprietário para criar um
                                software livre, tudo corria bem até que, em 2005, o acesso gratuito ao BitKeeper foi
                                revogado.
                            </p>
                            <p>
                                Esse foi o ponto decisivo que levou diretamente ao nascimento do Git. A BitMover começou
                                a desconfiar que a comunidade do Linux estava realizando engenharia reversa do protocolo
                                de rede do BitKeeper. De certa forma, isso era verdade: muitos desenvolvedores não
                                aceitavam a ideia de depender de um software fechado para um projeto como o kernel, e
                                alguns começaram a criar alternativas capazes de ler e interagir com repositórios do
                                BitKeeper. A mais conhecida delas foi o <em>SourcePuller</em>.
                            </p>
                            <p>
                                Após a revogação das licenças gratuitas do BitKeeper, Linus Torvalds decidiu resolver
                                esse problema de forma definitiva. Ele queria um sistema de controle de versão que
                                atendesse aos seguintes requisitos: ser distribuído, eficiente, rápido, resistente à
                                corrupção de dados e 100% software livre.
                            </p>
                            <p>
                                As opções disponíveis na época eram: Mercurial, Bazaar, Darcs e Monotone. Todas, no
                                entanto, apresentavam problemas de desempenho em projetos grandes como o kernel. Com
                                essas alternativas descartadas, restou apenas uma saída: criar um novo sistema de
                                versionamento. Assim nasceu o Git, que se tornaria o sistema de controle de versão mais
                                utilizado da história.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Init e Objects</h1>
                            <p>
                                Em resumo, o Git é um sistema que cria e manipula um "banco de dados de objetos". Esses
                                objetos são: <em>Blob</em>, <em>Tree</em>, <em>Commit</em> e <em>Tag</em>. Sendo o
                                <em>Tag</em> um objeto não essencial para o funcionamento do Git. Implementei comandos
                                capazes de criar, excluir e editar os três objetos essenciais. Conforme eu for
                                detalhando a implementação de cada comando, também explicarei como esses objetos
                                funcionam e se relacionam.
                            </p>
                            <p>
                                O primeiro comando abordado será o de inicialização do repositório
                                <em>.gitadr</em> (equivalente ao <em>.git</em>). É dentro desse repositório (ou pasta,
                                se você for da terra do Windows) que são armazenados os objetos e arquivos auxiliares
                                necessários para o funcionamento do Git.
                            </p>
                            <details>
                                <summary>Código fonte do comando Init</summary>
                                <pre><code>using Git.Core;
using System.Text;

namespace Git.Commands
{
    public class Init
    {
        public static void Execute()
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");

            if (Directory.Exists(gitDir))
            {
                Console.WriteLine("Repositório .gitadr já existe.");
                return;
            }

            Directory.CreateDirectory(gitDir);
            Directory.CreateDirectory(Path.Combine(gitDir, "objects"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs", "heads"));

            File.WriteAllText(Path.Combine(gitDir, "refs", "heads", "master"), string.Empty);
            File.WriteAllText(Path.Combine(gitDir, "HEAD"), $"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}master");

            Console.WriteLine($"Repositório inicializado em {gitDir}");
        }
    }
}</code></pre>
                            </details>

                            <p>Estrutura criada pelo comando <code>init</code>:</p>

                            <p>
                                <strong>.gitadr</strong>: diretório principal do sistema ("adr" = <em>Adriel</em>).
                                <br />

                                <strong>/objects</strong>: onde ficam os objetos do Git (<em>Blob</em>, <em>Tree</em>,
                                <em>Commit</em> e <em>Tag</em>). <br />

                                <strong>/refs/heads</strong>: contém os arquivos que representam os branches. O projeto
                                já inicia com o branch <code>master</code>. <br />

                                <strong>HEAD</strong>: arquivo que guarda a referência do branch atual, iniciando com
                                <code>ref: refs/heads/master</code>. <br />
                            </p>

                            <p>
                                Esse comando não tem grandes segredos: ele basicamente cria diretórios e arquivos. Note
                                que mantive a convenção de usar um nome iniciado por ponto (<code>.gitadr</code>) para o
                                diretório principal. Em sistemas Unix-like (Linux e macOS), arquivos e pastas que
                                começam com <code>.</code> são tratados como ocultos.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Hash-Object</h1>

                            <p>
                                Este é um dos comandos
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">plumbing</a> mais
                                importantes do Git. Seu objetivo é transformar um arquivo em um objeto <em>blob</em> e
                                armazená-lo no repositório.
                            </p>
                            <p>
                                Um objeto <em>blob</em> (<strong>binary large object</strong>) nada mais é do que um
                                conjunto de bytes que guarda apenas duas informações: o tamanho do conteúdo e o próprio
                                conteúdo do arquivo. Sua estrutura binária segue o formato:
                            </p>
                            <pre><code>blob content.length\0contentBytes</code></pre>
                            <p>
                                <strong><code>blob content.length</code></strong
                                >: Cabeçalho do objeto. É composto pela palavra <code>blob</code>, seguida de um espaço
                                em branco e do tamanho total do conteúdo em bytes. <br />

                                <strong><code>\0</code></strong
                                >: Caractere nulo que separa o cabeçalho do conteúdo. <br />

                                <strong><code>contentBytes</code></strong
                                >: O conteúdo do arquivo em si, armazenado em formato binário.
                            </p>
                            <p>
                                Repare que o <em>blob</em> não guarda informações como nome do arquivo, autor ou data de
                                criação. Para ele, esses metadados são irrelevantes: o que importa é apenas o conteúdo
                                puro.
                            </p>
                            <p>
                                Depois de combinar os bytes do cabeçalho com os bytes do conteúdo, o resultado é
                                processado pela função
                                <strong>SHA-1</strong>. Essa função gera um identificador único de 20 bytes, que em
                                seguida é convertido para uma representação em string hexadecimal. O resultado é algo
                                como:
                            </p>

                            <pre><code>658e12ad10bfd93dcf0712de258795828f6c4240</code></pre>

                            <p>
                                Esse formato de hash provavelmente já lhe é familiar: é o identificador único de
                                <strong>todos</strong> os objetos no Git. Cada hash possui 40 caracteres hexadecimais.
                                No armazenamento, os 2 primeiros caracteres são usados para nomear o diretório, e os 38
                                restantes para nomear o arquivo do objeto.
                            </p>

                            <p>
                                Os arquivos binários dos objetos não ficam soltos diretamente dentro de
                                <code>/objects</code>. Em vez disso, cada objeto é armazenado em um subdiretório cujo
                                nome corresponde aos dois primeiros caracteres do hash SHA-1. Essa divisão surgiu por
                                conta das limitações de sistemas de arquivos mais antigos (como ext2, FAT32 ou versões
                                iniciais do NTFS), que não lidavam bem com diretórios contendo dezenas ou até centenas
                                de milhares de arquivos.
                            </p>

                            <p>
                                Se você abrir agora o diretório <code>.git/objects</code>, verá exatamente essa
                                estrutura. Exemplo dos diretórios de objetos:
                            </p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/diretorios-de-objetos.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                <div class="item-description">
                                    <small
                                        ><i
                                            >Cada diretório representa o prefixo (2 caracteres) de um hash de objeto.</i
                                        ></small
                                    >
                                </div>
                            </div>

                            <br />

                            <p>Exemplo de um objeto armazenado com seu hash completo dentro do diretório:</p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/objeto.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                <div class="item-description">
                                    <small
                                        ><i
                                            >Arquivo binário de um objeto blob, nomeado com 38 caracteres hexadecimais
                                            do hash.</i
                                        ></small
                                    >
                                </div>
                            </div>

                            <p>
                                Entendendo essa estrutura, a implementação do comando <code>hash-object</code> se torna
                                simples: basta gerar o hash SHA-1 do conteúdo com uma biblioteca de criptografia e criar
                                o arquivo binário correspondente.
                            </p>

                            <details>
                                <summary>Código fonte do comando Hash-Object</summary>
                                <pre><code>using Csharp.Core;
using Git.Core;

namespace Git.Commands
{
    public class HashObject
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr hash-object [-w] &lt;arquivo&gt;");
                return string.Empty;
            }

            var write = args[0] == "-w";
            var path = write ? args[1] : args[0];

            if (!File.Exists(path))
            {
                throw new Exception($"Arquivo não encontrado: {path}");
            }

            var (sha1Hash, fullBlob) = BlobUtils.WriteBlob(path);

            if (write)
            {
                ObjectStore.WriteObject(sha1Hash, fullBlob);
            }
            else
            {
                Console.WriteLine(sha1Hash);
            }

            return sha1Hash;
        }
    }
}
</code></pre>
                        </details>

                        <details>
                            <summary>Código fonte dos métodos utilitários sha1 (Sha1Utils.cs)</summary>
                            <p>
                                Nessa classe, está presente os métodos utilitários para a utilização e aplicação da criptografia sha1, alguns métodos abaixos vão ser reaproveitados em outros comandos.
                            </p>
                                <pre><code>using System.IO.Compression;
using System.Security.Cryptography;

namespace Git.Core
{
    public class Sha1Utils
    {
        public static byte[] CombineBytes(byte[] a, byte[] b)
        {
            var combined = new byte[a.Length + b.Length];
            Buffer.BlockCopy(a, 0, combined, 0, a.Length);
            Buffer.BlockCopy(b, 0, combined, a.Length, b.Length);

            return combined;
        }

        public static string Sha1BytesToString(byte[] sha1)
        {
            return BitConverter.ToString(sha1).Replace("-", "").ToLower();
        }

        public static byte[] Sha1StringToBytes(string sha1)
        {
            var bytes = new byte[20];
            for (var i = 0; i &lt; 20; i++)
            {
                var byteString = sha1.Substring(i * 2, 2);
                bytes[i] = Convert.ToByte(byteString, 16);
            }

            return bytes;
        }

        public static string CreateSha1FromByteData(byte[] data)
        {
            using var sha1 = SHA1.Create();
            var hashBytes = sha1.ComputeHash(data);

            return Sha1BytesToString(hashBytes);
        }

        public static byte[] GetObjectDataBySha1(string sha1)
        {
            var dir = Path.Combine(".gitadr", "objects", sha1.Substring(0, 2));
            var file = sha1.Substring(2);
            var path = Path.Combine(dir, file);

            if (!Directory.Exists(dir) || !File.Exists(path))
            {
                throw new Exception($"Objeto não encontrado: ${sha1} não encontrado.");
            }

            using var fs = File.OpenRead(path);
            using var zlib = new ZLibStream(fs, CompressionMode.Decompress);
            using var outputStream = new MemoryStream();

            zlib.CopyTo(outputStream);
            var data = outputStream.ToArray();

            var nullIndex = Array.IndexOf(data, (byte)0);
            if (nullIndex == -1)
            {
                throw new Exception("Objeto inválido (sem header)");
            }

            return data;
        }

        public static void WriteFileAndDirectoriesFromSha1(string path, string sha1)
        {
            var data = GetObjectDataBySha1(sha1);
            var nullIndex = Array.IndexOf(data, (byte)0);
            var blob = data[(nullIndex + 1)..];

            var dir = Path.GetDirectoryName(path);
            if (!string.IsNullOrEmpty(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllBytes(path, blob);
        }
    }
}

</code></pre>
                        </details>
                        <details>
                            <p>
                                Nessa classe, está presente o método utilitário para a criação do arquivo binário do objeto dentro do diretório <code>.gitadr/objects</code>.
                                Esse método vai ser muito reutilizado em outros comandos.
                            </p>
                            <summary>Código fonte do método de criação de um objeto do git (ObjectStore.cs)</summary>
                            <pre><code>using System.IO.Compression;

namespace Git.Core
{
    public class ObjectStore
    {
        public static void WriteObject(string sha1, byte[] data)
        {
            string dir = Path.Combine(".gitadr", "objects", sha1.Substring(0, 2));
            string file = sha1.Substring(2);

            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            string path = Path.Combine(dir, file);
            using var fs = File.Create(path);
            using var zlib = new ZLibStream(fs, CompressionMode.Compress);
            zlib.Write(data, 0, data.Length);
        }
    }
}</code></pre>
                        </details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Cat-File</h1>

                            <p>
                                O comando <code>cat-file</code> permite ler o conteúdo de um objeto no Git.  
                                Ele recebe como parâmetro o hash SHA-1 do objeto e, a partir dele, localiza o arquivo correspondente dentro de 
                                <code>.gitadr/objects</code>.  
                                Primeiro, utiliza os dois primeiros caracteres do hash para identificar o diretório.  
                                Em seguida, abre o arquivo, realiza a descompactação e exibe o conteúdo do objeto na tela.
                            </p>

                            <p>
                                Se você acompanhou o código do comando <code>hash-object</code>, deve ter notado que o objeto é armazenado 
                                em formato compactado com <strong>zlib</strong>.  
                                Ou seja, o Git não guarda os dados em binário puro: antes de gravar, ele comprime o conteúdo, e ao ler, 
                                precisa descompactá-lo para exibição.
                            </p>

                            <p>
                                Depois de entender como os objeto blob do git funciona, e depois de implementar o hash-object, esse comando se torna extremamente fácil e intuitivo.
                            </p>

                            <details>
                            <summary>Código fonte do comando Cat-File</summary>
                            <p>
                                <i>Este comando utiliza métodos da classe <strong>sha1Utils.cs</strong> (mencionada no comando hash-object)</i>
                            </p>
                            <pre><code>using Git.Core;
using System.Text;

namespace Git.Commands
{
    public class CatFile
    {
        public static string Execute(string[] args)
        {
            if (args.Length < 2 || args[0] != "-p")
            {
                Console.WriteLine("Uso: gitadr cat-file [-p] &lt;hash&gt;");
                return string.Empty;
            }

            var data = Sha1Utils.GetObjectDataBySha1(args[1]);
            var nullIndex = Array.IndexOf(data, (byte)0);
            var content = Encoding.UTF8.GetString(data[(nullIndex + 1)..]);

            Console.WriteLine(content);
            return content;
        }
    }
}</code></pre>
                        </details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Write-Tree</h1>

                            <p>
                                Este comando percorre todos os arquivos e diretórios do projeto (a partir do diretório raiz), 
                                criando <code>blobs</code> para os arquivos e objetos <code>tree</code> para os diretórios.  
                                Em resumo: enquanto os <code>blobs</code> representam os arquivos do projeto, as <code>trees</code> 
                                representam os diretórios em que esses arquivos estão.
                            </p>

                            <p>
                                A estrutura binária de um objeto <code>tree</code> é semelhante à de um <code>blob</code>: 
                                todo objeto do Git possui um cabeçalho e um conteúdo.  
                                A diferença é que o conteúdo de uma <code>tree</code> armazena os hashes de <code>blobs</code> e de outras <code>trees</code>, 
                                formando assim uma verdadeira estrutura em árvore.  
                                Na prática, uma <code>tree</code> funciona como um ponteiro para um <code>blob</code> ou outra <code>tree</code>.
                            </p>

                            <p>
                                Entender a estrutura de árvores é essencial para compreender o funcionamento interno do Git.  
                                Por exemplo: um commit referencia o hash de um objeto <code>tree</code>, e um branch referencia um commit 
                                (falaremos sobre branches mais adiante).  
                                Assim, dominar a lógica de árvores é fundamental para quem deseja compreender como um sistema de versionamento de arquivos funciona.
                            </p>

                            <p>
                                A estrutura binária de um objeto <code>tree</code> é:
                            </p>

                            <pre><code>tree content.length\0contentBytes</code></pre>

                            <p>
                                <strong><code>tree content.length</code></strong>: cabeçalho do objeto.  
                                Composto pela palavra <code>tree</code>, seguida de um espaço e do tamanho total do conteúdo em bytes. <br />

                                <strong><code>\0</code></strong>: caractere nulo que separa o cabeçalho do conteúdo. <br />

                                <strong><code>contentBytes</code></strong>: conteúdo da <code>tree</code>, que armazena referências aos arquivos e subdiretórios.  
                                Exemplo:
                            </p>

                            <pre><code>100644 arquivo_nome.txt\0658e12ad10bfd93dcf0712de258795828f6c4240
100644 arquivo2_nome.txt\0238e12ad10bfd93dcf0712de258795828f634250</code></pre>

                            <p>
                                O objeto completo (cabeçalho + conteúdo) ficaria assim:
                            </p>

                            <pre><code>tree 40405339\0100644 arquivo_nome.txt\0658e12ad10bfd93dcf0712de258795828f6c4240100644 arquivo2_nome.txt\0238e12ad10bfd93dcf0712de258795828f634250</code></pre>

                            <p>
                                <strong><code>100644</code></strong>: esse código antes do nome do arquivo ou diretório é o <code>mode</code> do objeto.  
                                Ele indica o tipo e as permissões de leitura/escrita, seguindo o padrão do Unix file mode.  
                                Neste clone do Git, interpreto apenas dois modos: <code>100644</code> (blob) e <code>040000</code> (tree).  
                                O <code>mode</code> é seguido de um espaço em branco antes do nome do arquivo ou diretório.
                            </p>
                            <details>
                            <summary>Todos os file modes reconhecidos pelo Git</summary>
                                <table class="table">
                                <thead> 
                                    <tr>
                                    <th>Mode</th>
                                    <th>Tipo de objeto</th>
                                    <th>Descrição</th>
                                    <th>Exemplo</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="table-td">
                                    <td >040000</td>
                                    <td>tree</td>
                                    <td>Diretório (contém outras entradas)</td>
                                    <td>src/</td>
                                    </tr>
                                    <tr>
                                    <td>100644</td>
                                    <td>blob</td>
                                    <td>Arquivo normal, não executável</td>
                                    <td>README.md</td>
                                    </tr>
                                    <tr>
                                    <td>100755</td>
                                    <td>blob</td>
                                    <td>Arquivo executável</td>
                                    <td>scripts/build.sh</td>
                                    </tr>
                                    <tr>
                                    <td>120000</td>
                                    <td>blob</td>
                                    <td>Link simbólico (conteúdo do blob = caminho alvo)</td>
                                    <td>link -> ../docs</td>
                                    </tr>
                                    <tr>
                                    <td>160000</td>
                                    <td>commit</td>
                                    <td>Submódulo (ponteiro para um commit de outro repositório)</td>
                                    <td>vendor/libfoo (submodule)</td>
                                    </tr>
                                </tbody>
                                </table>
                            </details>
                            <p>
                                <strong><code>arquivo_nome.txt</code></strong>: Nome do arquivo ou do diretório.
                            </p>
                            <p>
                                <strong><code>\0</code></strong>: Caractere nulo que separa o cabeçalho do conteúdo.
                            </p>
                            <p>
                                <strong><code>658e12ad10bfd93dcf0712de258795828f6c4240100644</code></strong>: Hash sha1 do blob ou tree.
                            </p>
                            <p>
                                A estrutura desses objetos é baseada na forma como os arquivos e diretórios são interpretados pelos sistemas de arquivos do unix como (ext2/ext3). Segue uma comparação visual:
                            </p>
                            <p>
                                Diretório no Unix (ext2/ext4)
                                <pre><code>[tipo/mode] [nome] [ponteiro → inode]

exemplo:

[0100644] [file.txt] [inode=1234]
</code></pre>
                            </p>
                            <p>
                                Tree no Git:
                                <pre><code>[mode] [nome]\0[hash (20 bytes)]

exemplo:

100644 file.txt\0658e12ad10bfd93dcf0712de258795828f6c4240
</code></pre>
                            </p>
                            
                            <details>
                            <summary>Código fonte do comando Write-Tree</summary>
<pre><code>using Git.Core;
using static Git.Core.TreeUtils;

namespace Git.Commands
{
    public class WriteTree
    {
        public static string Execute()
        {
            return WriteTreeRecursive(Directory.GetCurrentDirectory());
        }

        public static string WriteTreeRecursive(string directory)
        {
            var entries = new List&lt;TreeEntry&gt;();

            foreach (var file in Directory.GetFiles(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(file) == ignoreFile))
                {
                    continue;
                }

                var (blobSha1, fullBlob) = BlobUtils.WriteBlob(file);
                ObjectStore.WriteObject(blobSha1, fullBlob);

                entries.Add(new TreeEntry
                {
                    Mode = "100644",
                    Name = Path.GetFileName(file),
                    Sha1 = blobSha1
                });
            }

            foreach (var subdir in Directory.GetDirectories(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(subdir) == ignoreFile))
                {
                    continue;
                }

                var treeSha1 = WriteTreeRecursive(subdir);

                entries.Add(new TreeEntry
                {
                    Mode = "040000",
                    Name = Path.GetFileName(subdir),
                    Sha1 = treeSha1
                });
            }

            if (entries.Count > 0)
            {
                return TreeObject.WriteTree(entries);
            }

            return string.Empty;
        }
    }
}
</code></pre>
                        </details>
                        <details>
                            <summary>Código fonte da classe TreeObject.cs</summary>
<pre><code>using System.Text;
using static Git.Core.TreeUtils;

namespace Git.Core
{
    public class TreeObject
    {
        public static string WriteTree(List&lt;TreeEntry&gt; entries)
        {
            using var treeStream = new MemoryStream();

            foreach (var entry in entries)
            {
                var modeBytes = Encoding.ASCII.GetBytes(entry.Mode + " ");
                var nameBytes = Encoding.UTF8.GetBytes(entry.Name);
                var sha1Bytes = Sha1Utils.Sha1StringToBytes(entry.Sha1);

                treeStream.Write(modeBytes, 0, modeBytes.Length);
                treeStream.Write(nameBytes, 0, nameBytes.Length);
                treeStream.WriteByte(0); // separador \0
                treeStream.Write(sha1Bytes, 0, sha1Bytes.Length);
            }

            var treeContent = treeStream.ToArray();
            var header = $"tree {treeContent.Length}\0";
            var fullTree = Sha1Utils.CombineBytes(Encoding.UTF8.GetBytes(header), treeContent);

            var treeSha1 = Sha1Utils.CreateSha1FromByteData(fullTree);
            ObjectStore.WriteObject(treeSha1, fullTree);

            return treeSha1;
        }
    }
}
</code></pre>
                            </details>
<details>
    <summary>Código fonte da classe TreeUtils.cs</summary>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class TreeUtils
    {
        public class TreeEntry
        {
            public required string Mode { get; set; }
            public required string Name { get; set; }
            public required string Sha1 { get; set; }
        }

        public static List&lt;TreeEntry&gt; GetTreeData(string sha1Param)
        {
            var data = Sha1Utils.GetObjectDataBySha1(sha1Param);

            var nullIndexHeader = Array.IndexOf(data, (byte)0);
            var content = data.Skip(nullIndexHeader + 1).ToArray();

            var entries = new List&lt;TreeEntry&gt;();
            int offset = 0;

            while (offset &lt; content.Length)
            {
                int modeEnd = Array.IndexOf(content, (byte)0x20, offset);
                var mode = Encoding.UTF8.GetString(content, offset, modeEnd - offset);

                int nameEnd = Array.IndexOf(content, (byte)0, modeEnd + 1);
                var name = Encoding.UTF8.GetString(content, modeEnd + 1, nameEnd - (modeEnd + 1));

                var sha1Bytes = content.Skip(nameEnd + 1).Take(20).ToArray();
                var sha1 = Sha1Utils.Sha1BytesToString(sha1Bytes);

                entries.Add(new TreeEntry { Mode = mode, Sha1 = sha1, Name = name });

                offset = nameEnd + 1 + 20;
            }

            return entries;
        }

        public static Dictionary&lt;string, (string Mode, string Sha1)&gt; GetTreeEntriesFromSha1(string prefix, string treeSha1, Dictionary&lt;string, (string Mode, string Sha1)&gt; dict)
        {
            var entries = GetTreeData(treeSha1);

            foreach (var entry in entries)
            {
                var fullPath = TreeUtils.CombinePrefix(prefix, entry.Name);

                if (entry.Mode == "040000")
                {
                    GetTreeEntriesFromSha1(fullPath, entry.Sha1, dict);
                }
                else
                {
                    dict[fullPath] = (entry.Mode, entry.Sha1);
                }
            }

            return dict;
        }

        public static string CombinePrefix(string prefix, string name)
        {
            return string.IsNullOrEmpty(prefix) ? name : Path.Combine(prefix, name);
        }
    }
}

</code></pre>
</details>
                            <p>
                                Com o comando <code>write-tree</code>, a estrutura de dados principal do Git é criada.  
                                A seguir, podemos ver um exemplo de como as <code>trees</code> e <code>blobs</code> se referenciam entre si (resultado do comando write-tree):
                            </p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/data-model-1.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                
                            </div>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Ls-Tree</h1>

                            <p>
                                Este é o comando que exibe o conteúdo de uma tree. No git oficial também é possivel utilizar o <code>cat-file</code> para exibir o conteúdo de uma tree, mas para fins didático
                                optei por separar:  <br>
                                <code>cat-file</code>: Exibir conteúdo de um blob. <br>
                                <code>ls-tree</code>: Exibir conteúdo de uma tree.
                            </p>
                            <p>
                                Este comando vai exibir exatamente as informações contidas no conteúdo do objeto <code>tree</code> que detalhei na descrição do comando <code>write-tree</code>
                            </p>
                            <p>
                                O conteúdo da tree será exibido dessa forma no console:
                            </p>
                            <pre><code>[mode] [type] [sha1] [name]</code></pre>                        
<details>
    <summary>Código fonte do comando Ls-Tree</summary>
    <p>
        <i>Este comando utiliza métodos da classe <strong>treeUtils.cs</strong> (mencionada no comando write-tree)</i>
    </p>
    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class LsTree
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 2 || args[0] != "-p")
            {
                Console.WriteLine("Uso: gitadr ls-tree [-p] &lt;hash&gt;");
                return string.Empty;
            }

            var entries = TreeUtils.GetTreeData(args[1]);

            var result = string.Empty;

            foreach (var entry in entries)
            {
                var type = entry.Mode == "040000" ? "tree" : "blob";
                var lineData = $"{entry.Mode} {type} {entry.Sha1} {entry.Name}";

                Console.WriteLine(lineData);
                result += lineData + "\n";
            }

            return result;
        }
    }
}
</code></pre>
</details>                            
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Add</h1>
                            
                            <p>
                                Este é o primeiro comando <a href="https://wyag.thb.lt" target="_blank" class="blog-link">porcelain</a> 
                                que os usuários normalmente utilizam no dia a dia.  
                                No Git oficial, o <code>add</code> utiliza internamente um comando <a href="https://wyag.thb.lt" target="_blank" class="blog-link">plumbing</a> chamado <code>update-index</code>.
                            </p>

                            <p>
                                No meu clone, optei por criar diretamente o comando <code>add</code>.  
                                Assim, <code>gitadr add</code> equivale a <code>git hash-object</code> + <code>git update-index</code> no Git oficial.
                            </p>

                            <p>
                                Ao entender o funcionamento do meu comando <code>add</code> e analisar o código, você automaticamente compreenderá 
                                como funciona o <code>update-index</code>.  
                                Caso queira implementar o <code>update-index</code> separadamente, fique à vontade: ele apenas adiciona ou atualiza o hash SHA-1 no arquivo <code>index</code>, o que é relativamente simples.
                            </p>

                            <p>
                                O comando <code>add</code> realiza basicamente duas operações: cria os objetos e atualiza o arquivo <code>index</code>.  
                                Esse arquivo é gerado na primeira execução do <code>add</code> e fica armazenado em <i>./gitadr/index</i>.  
                                Também conhecido como <i>staging area</i>, o <code>index</code> funciona como uma ponte entre o workspace e o commit, permitindo que o Git saiba exatamente quais alterações serão incluídas no próximo commit.
                            </p>

                            <p>
                                No Git oficial, o arquivo <code>index</code> é binário e contém diversas informações sobre arquivos e diretórios 
                                (caminho, hash SHA-1, mode, flags internas etc.).  
                                No <code>gitadr</code>, simplifiquei o índice: ele é um arquivo de texto que armazena apenas duas informações por arquivo: <i>SHA-1</i> e <i>caminho</i>.  
                                Isso é suficiente para criar uma <i>staging area</i> eficiente, capaz de controlar quais arquivos alterados serão incluídos no próximo commit.
                            </p>
                            
                            <p>
                                A estrutura do conteúdo do arquivo index é assim: <i>sha1 + espaço em branco + caminho do arquivo + quebra de linha</i>.
                                Segue abaixo um exemplo:
                            </p>
                            <pre><code>4a481a3aa65ec275d2fd0f751e995e2450fbc6c4 src/fileA.txt
0c991fcb4fe1739224d4a0df2973df2de4eef4ad src/lib/fileB.txt</code></pre>

<details>
    <summary>Código fonte do comando Add</summary>
    <p>
        Perceba que é possivel adicionar a worskpace inteira na staging area com o comando <code>gitadr add .</code> ou todos os arquivos de um determinado diretório, com <code>gitadr add [diretório]</code>
    </p>
    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class Add
    {
        public static void Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr add &lt;arquivo | diretório | .&gt;");
                return;
            }

            var target = args[0];

            if (target == ".")
            {
                AddAll();
                return;
            }

            if (Directory.Exists(target))
            {
                ExecuteRecursive(Path.GetFullPath(target));
                StageDeletionsUnderPath(Path.GetFullPath(target));
                return;
            }

            var rel = Path.GetRelativePath(Directory.GetCurrentDirectory(), target);
            AddOrUpdateIndexFile(rel);
        }

        public static void AddAll()
        {
            var workspaceFiles = IndexUtils.RecursiveReadWorkSapce(Directory.GetCurrentDirectory(), new Dictionary&lt;string, string&gt;());
            var indexFiles = IndexUtils.GetIndexEntries(true);

            foreach (var file in workspaceFiles.Keys)
            {
                AddOrUpdateIndexFile(file);
            }

            foreach (var file in indexFiles.Keys.ToList())
            {
                if (!workspaceFiles.ContainsKey(file))
                {
                    indexFiles.Remove(file);
                    IndexUtils.CreateOrUpdateIndex(string.Join('\n', indexFiles.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
                }
            }
        }

        public static void ExecuteRecursive(string directory)
        {
            foreach (var file in Directory.GetFiles(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(file) == ignoreFile))
                    continue;

                AddOrUpdateIndexFile(Path.GetRelativePath(Directory.GetCurrentDirectory(), file));
            }

            foreach (var subdir in Directory.GetDirectories(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(subdir) == ignoreFile))
                    continue;

                ExecuteRecursive(subdir);
            }
        }

        private static void StageDeletionsUnderPath(string basePath)
        {
            var root = Directory.GetCurrentDirectory();
            var relBase = Path.GetRelativePath(root, basePath);
            if (relBase == "." || string.IsNullOrEmpty(relBase))
            {
                relBase = string.Empty;
            }

            var index = IndexUtils.GetIndexEntries(true);
            var newContentLines = new List&lt;string&gt;();

            foreach (var kv in index)
            {
                var file = kv.Key;
                var sha1 = kv.Value;

                bool underBase =
                    string.IsNullOrEmpty(relBase) ||
                    file == relBase ||
                    file.StartsWith(relBase + Path.DirectorySeparatorChar);

                if (underBase)
                {
                    var fullPath = Path.Combine(root, file);
                    if (!File.Exists(fullPath))
                    {
                        continue;
                    }
                }

                newContentLines.Add($"{sha1} {file}");
            }

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', newContentLines) + "\n");
        }

        public static void AddOrUpdateIndexFile(string file, string? sha1Param = null)
        {
            var index = IndexUtils.GetIndexEntries(true);

            if (!File.Exists(file))
            {
                if (index.ContainsKey(file))
                {
                    index.Remove(file);
                    IndexUtils.CreateOrUpdateIndex(string.Join('\n', index.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
                }
                return;
            }

            var sha1 = sha1Param ?? HashObject.Execute(new string[] { "-w", file });
            index[file] = sha1;

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', index.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
        }
    }
}
</code></pre>
</details>           
<details>
    <summary>Código fonte da classe indexUtils.cs</summary>
    <pre><code>namespace Git.Core
{
    public class IndexUtils
    {
        public static readonly string[] ignoreFiles = { ".gitadr" };
        public static Dictionary&lt;string, string&gt; GetIndexEntries(bool createIndexFile = false)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var pathIndex = Path.Combine(gitDir, "index");

            if (!File.Exists(pathIndex))
            {
                if (createIndexFile)
                {
                    File.WriteAllText(pathIndex, string.Empty);
                }

                return new Dictionary&lt;string, string&gt;();
            }

            var content = File.ReadAllText(pathIndex);

            if (string.IsNullOrWhiteSpace(content))
            {
                if (createIndexFile)
                {
                    File.WriteAllText(pathIndex, content);
                }

                return new Dictionary&lt;string, string&gt;();
            }

            var entries = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);

            var indexMap = new Dictionary&lt;string, string&gt;();

            foreach (var line in entries)
            {
                var parts = line.Split(' ', 2);

                var sha1 = parts[0];
                var path = parts[1];

                var relPath = Path.GetRelativePath(Directory.GetCurrentDirectory(), path);

                relPath = relPath.Replace('/', Path.DirectorySeparatorChar);

                indexMap[relPath] = sha1;
            }

            return indexMap;
        }

        public static void CreateOrUpdateIndex(string contenet)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, "index");

            File.WriteAllText(path, contenet);
        }

        public static List&lt;string&gt; RecursiveUpdateIndexFromTree(string prefix, string treeSha1, List&lt;string&gt; indexLines)
        {
            var treeEntries = TreeUtils.GetTreeData(treeSha1);

            foreach (var entry in treeEntries)
            {
                var fullPath = TreeUtils.CombinePrefix(prefix, entry.Name);

                if (entry.Mode == "040000")
                {
                    RecursiveUpdateIndexFromTree(fullPath, entry.Sha1, indexLines);
                }
                else
                {
                    indexLines.Add($"{entry.Sha1} {fullPath}");
                }
            }

            CreateOrUpdateIndex(string.Join('\n', indexLines) + "\n");

            return indexLines;
        }

        public static Dictionary&lt;string, string&gt; RecursiveReadWorkSapce(string dir, Dictionary&lt;string, string&gt; dict)
        {
            foreach (var entry in Directory.GetFiles(dir))
            {
                if (ignoreFiles.Any(ignoreFile => Path.GetFileName(entry) == ignoreFile))
                {
                    continue;
                }

                var fullPath = Path.GetRelativePath(Directory.GetCurrentDirectory(), entry);
                dict[fullPath] = BlobUtils.GetSha1FromBlob(entry);
            }

            foreach (var entry in Directory.GetDirectories(dir))
            {
                if (ignoreFiles.Any(ignoreDir => Path.GetFileName(entry) == ignoreDir))
                {
                    continue;
                }

                RecursiveReadWorkSapce(entry, dict);
            }

            return dict;
        }

        public static string NormalizePath(string path)
        {
            var fullPath = Path.GetFullPath(path);
            var repoRoot = Directory.GetParent(Path.Combine(Directory.GetCurrentDirectory(), ".gitadr"))!.FullName;
            var relativePath = Path.GetRelativePath(repoRoot, fullPath);

            return relativePath.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar).TrimEnd(Path.DirectorySeparatorChar);
        }

        public static void RemoveEmptyDirectories(string root)
        {
            var allDirs = Directory.GetDirectories(root, "*", SearchOption.AllDirectories)
                                   .OrderByDescending(d => d.Length);

            var gitDir = Path.GetFullPath(Path.Combine(root, ".gitadr"));

            foreach (var dir in allDirs)
            {
                var full = Path.GetFullPath(dir);
                if (full.Equals(gitDir, StringComparison.OrdinalIgnoreCase) || full.StartsWith(gitDir + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (!Directory.EnumerateFileSystemEntries(full).Any())
                {
                    Directory.Delete(full, recursive: false);
                }
            }
        }
    }
}
</code></pre>
</details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Commit</h1>

                            <p>
                                Este é o comando clássico do Git — provavelmente o mais conhecido de todos.  
                                Em essência, ele realiza duas operações principais: <code>write-tree</code> e a criação de um novo objeto <code>commit</code>.  
                                Primeiro, o comando lê os arquivos presentes no <i>index</i> e monta uma árvore completa desses arquivos e diretórios através do <code>write-tree</code>.  
                                Em seguida, é criado o objeto <code>commit</code>, que armazena o hash SHA-1 da árvore raiz gerada e o hash do commit anterior (<i>parent commit</i>), caso exista.
                            </p>

                            <p>
                                Em resumo, um objeto <code>commit</code> é essencialmente um ponteiro para uma árvore (<code>tree</code>) acompanhado de metadados.  
                                Além dos hashes da árvore e do commit anterior, ele também contém informações como autor, e-mail, data e hora, além da mensagem do commit.
                            </p>

                            <p>
                                Particularmente, não gosto da explicação popular que diz: <i>"um commit é um ponto na linha do tempo"</i>.  
                                Embora isso possa ajudar iniciantes que não entendem nada de git a formar uma ideia vaga, essa definição não reflete o que o Commit realmente faz — e pode até dar a impressão de que o Git é uma ferramenta mágica que "controla" o tempo.  
                                Prefiro uma explicação mais precisa: <i>"um commit representa um estado do seu projeto"</i>.  
                                Isso traduz melhor a realidade: cada commit é um ponteiro para uma árvore que descreve todos os arquivos do repositório naquele momento.  
                                Assim, cada commit captura um estado completo do projeto.
                            </p>

                            <p>
                                Abaixo está a estrutura de um objeto <code>commit</code>:
                            </p>
                            <pre><code>commit [tamanho]\0
tree [sha1 da tree raiz]
parent [sha1 do commit pai]     # (opcional — só existe se não for o primeiro commit)
author [nome] [email] [timestamp] [timezone]
committer [nome] [email] [timestamp] [timezone]

[mensagem do commit]

exemplo:

commit 187\0
tree 9a1fc4d8e1dba7a4d1246b26d4a2c716b8bfc1f1
parent 5c2f8a91a9a24f21df739eac78a9c53ebc71e63c
author Linus Torvalds [torvalds@linux-foundation.org] [1618590723] [-0700]
committer Linus Torvalds [torvalds@linux-foundation.org] [1618590723] [-0700]

[Fix race condition in file locking]
</code></pre>
<details>
    <summary>Código fonte do comando Commit</summary>
    <pre><code>using Git.Core;
using static Git.Core.TreeUtils;

namespace Git.Commands
{
    public class Commit
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 2 || args[0] != "-m")
            {
                Console.WriteLine("Uso: gitadr commit [-m] &lt;mensagem_do_commit&gt;");
                return string.Empty;
            }

            var indexEntries = IndexUtils.GetIndexEntries(false);

            if (indexEntries == null || indexEntries.Keys.Count == 0)
            {
                Console.WriteLine("Nenhum arquivo na staging area.");
                return string.Empty;
            }

            var parentCommit = CommitUtils.GetLastCommitSha1FromHead();

            if (!string.IsNullOrEmpty(parentCommit))
            {
                var headTreeSha1 = CommitUtils.GetCommitTreeSha1(parentCommit);
                var headEntries = TreeUtils.GetTreeEntriesFromSha1("", headTreeSha1, new Dictionary&lt;string, (string Mode, string Sha1)&gt;());

                var hasChanges = false;

                if (indexEntries.Count != headEntries.Count)
                {
                    hasChanges = true;
                }
                else
                {
                    foreach (var kv in indexEntries)
                    {
                        if (!headEntries.TryGetValue(kv.Key, out var head) || head.Sha1 != kv.Value)
                        {
                            hasChanges = true;
                            break;
                        }
                    }
                }

                if (!hasChanges)
                {
                    Console.WriteLine("working tree limpa.");
                    return string.Empty;
                }
            }
                    
            var rootSha1 = BuildCommitTree(indexEntries, parentCommit);

            var commitSha1 = CommitObject.WriteCommit(rootSha1, args[1]);

            UpdateHead(commitSha1);

            return commitSha1;
        }

        private static string BuildCommitTree(Dictionary&lt;string, string&gt; indexMap, string? parentCommit)
        {
            var baseFiles = new Dictionary&lt;string, (string Mode, string Sha1)&gt;();

            if (!string.IsNullOrEmpty(parentCommit))
            {
                var parentTreeSha1 = CommitUtils.GetCommitTreeSha1(parentCommit);
                TreeUtils.GetTreeEntriesFromSha1("", parentTreeSha1, baseFiles);
            }

            var newFiles = baseFiles.Keys.Union(indexMap.Keys);

            foreach (var file in newFiles)
            {
                var stagedFileSha1 = indexMap.ContainsKey(file) ? indexMap[file] : null;
                var baseFileSha1 = baseFiles.ContainsKey(file) ? baseFiles[file].Sha1 : null;

                if (stagedFileSha1 == null && baseFileSha1 != null)
                {
                    baseFiles.Remove(file);
                    continue;
                }

                baseFiles[file] = ("100644", stagedFileSha1!);
            }

            string WriteDir(string prefix)
            {
                var childNames = baseFiles.Keys
                    .Where(p => IsUnderPrefix(p, prefix))
                    .Select(p =>
                    {
                        var remainder = GetRemainder(p, prefix);
                        return remainder.Split(Path.DirectorySeparatorChar)[0];
                    })
                    .Distinct()
                    .OrderBy(n => n)
                    .ToList();

                var entries = new List&lt;TreeEntry&gt;();

                foreach (var name in childNames)
                {
                    var fullPath = TreeUtils.CombinePrefix(prefix, name);

                    if (baseFiles.TryGetValue(fullPath, out var fileInfo))
                    {
                        entries.Add(new TreeEntry
                        {
                            Mode = fileInfo.Mode,
                            Name = name,
                            Sha1 = fileInfo.Sha1
                        });
                    }
                    else
                    {
                        var subTreeSha1 = WriteDir(fullPath);
                        entries.Add(new TreeEntry
                        {
                            Mode = "040000",
                            Name = name,
                            Sha1 = subTreeSha1
                        });
                    }
                }

                return TreeObject.WriteTree(entries);
            }

            return WriteDir("");
        }

        private static bool IsUnderPrefix(string path, string prefix)
        {
            if (string.IsNullOrEmpty(prefix))
            {
                return true;
            }

            if (path.Length &lt; prefix.Length)
            {
                return false;
            }

            if (!path.StartsWith(prefix)) 
            { 
                return false; 
            }

            if (path.Length == prefix.Length) 
            { 
                return false; 
            }

            return path[prefix.Length] == Path.DirectorySeparatorChar;
        }

        private static string GetRemainder(string path, string prefix)
        {
            if (string.IsNullOrEmpty(prefix))
            {
                return path;
            }

            return path.Substring(prefix.Length + 1);
        }

        private static void UpdateHead(string commitSha1)
        {
            var refs = BranchUtils.GetHead();
            var parts = refs.Split(" ", 2);
            BranchUtils.CreateOrUpdateBranch(parts[1], commitSha1);
        }
    }
}
</code></pre>
</details>
<details>
    <summary>Código fonte da classe commitUtils.cs</summary>
    <p>
        Classe que possui os método utilitários para manipulação de commits.
    </p>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class CommitUtils
    {
        public static string GetTimestamp() => DateTimeOffset.Now.ToUnixTimeSeconds().ToString();
        public static string GetTimezone() => DateTimeOffset.Now.ToString("zzz").Replace(":", "");

        public static string GetLastCommitSha1FromHead()
        {
            var gitAdrDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var refs = BranchUtils.GetHead();
            var parts = refs.Split(" ", 2);

            return File.ReadAllText(Path.Combine(gitAdrDir, parts[1]));
        }

        public static string GetCommitTreeSha1(string commitSha1)
        {
            var data = Sha1Utils.GetObjectDataBySha1(commitSha1);
            var nullIdx = Array.IndexOf(data, (byte)0);
            var content = data[(nullIdx + 1)..];

            var text = Encoding.UTF8.GetString(content);
            var lineTree = text.Split('\n').First(l => l.StartsWith("tree "));
                
            var parts = lineTree.Split(' ', 2);

            return parts[1];
        }

        public static List&lt;string&gt; GetCommitParents(string commitSha1)
        {
            var data = Sha1Utils.GetObjectDataBySha1(commitSha1);
            var nullIdx = Array.IndexOf(data, (byte)0);
            var content = data[(nullIdx + 1)..];

            var text = Encoding.UTF8.GetString(content);
            var parents = text.Split('\n').Where(l => l.StartsWith("parent "));

            var commits = new List&lt;string&gt;();

            foreach (var parent in parents)
            {
                commits.Add(parent.Split(" ", 2)[1]);
            }

            return commits;
        }
    }
}
</code></pre>
</details>
<details>
    <summary>Código fonte da classe commitObject.cs</summary>

    <p>
        Classe que possui o método de criação do arquivo binário do objeto commit.
    </p>
    <p>
        Perceba que eu coloquei author e comitter com informações hardcoded. 
        É possivel tornar essas infos dinamicas, para isso será necessário criar comandos de configuração que armazanem informações em um arquivo de config, para saber mais leia sobre as <a href="https://git-scm.com/docs/git-config" target="_blank" class="blog-link">configurações de usuário do git</a>.
    </p>
    <p>
        Comandos de configs não abordam nenhum conceito estrutural do git, então, fica a teu critério essa implementação.
    </p>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class CommitObject
    {
        public static string WriteCommit(string rootSha1, string msg, string[]? sha1Parents = null)
        {
            using var commitStream = new MemoryStream();

            var tree = Encoding.UTF8.GetBytes($"tree {rootSha1}\n");

            var parents = new List&lt;byte&gt;();

            if (sha1Parents != null) 
            {
                foreach (var sha1 in sha1Parents)
                {
                    parents.Add(Encoding.UTF8.GetBytes($"parent {sha1}\n"));
                }
            }
            else
            {
                var parentSah1 = CommitUtils.GetLastCommitSha1FromHead();
               
                if (!string.IsNullOrWhiteSpace(parentSah1))
                {
                    parents.Add(Encoding.UTF8.GetBytes($"parent {parentSah1}\n"));
                }
            }

            var author = Encoding.UTF8.GetBytes($"author Guest &lt;author@gmail.com&gt; {CommitUtils.GetTimestamp()} {CommitUtils.GetTimezone()}\n");
            var committer = Encoding.UTF8.GetBytes($"committer Guest &lt;commiter@email.com&gt; {CommitUtils.GetTimestamp()} {CommitUtils.GetTimezone()}\n");
            var message = Encoding.UTF8.GetBytes($"{msg}\n");

            commitStream.Write(tree, 0, tree.Length);

            foreach(var parent in parents)
            {
                commitStream.Write(parent, 0, parent.Length);
            }  

            commitStream.Write(author, 0, author.Length);
            commitStream.Write(committer, 0, committer.Length);
            commitStream.WriteByte(0x0A);
            commitStream.Write(message, 0, message.Length);

            var commitContent = commitStream.ToArray();
            var header = $"commit {commitContent.Length}\0";

            var fullCommit = Sha1Utils.CombineBytes(Encoding.UTF8.GetBytes(header), commitContent);
            var commitSha1 = Sha1Utils.CreateSha1FromByteData(fullCommit);

            ObjectStore.WriteObject(commitSha1, fullCommit);

            return commitSha1;
        }
    }
}
</code></pre>
</details>
                            <p>
                                Até agora conseguimos construir exatamente essa estrutura:
                            </p>
                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/commit-and-tree.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                                    <small
                                        ><i
                                            >Imagem retirada do livro do git.</i
                                        ></small
                                    >
                            </div>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Branch</h1>

                            <p>
                                Este comando permite criar, listar e remover branches.  
                                Antes de tudo, é fundamental entender o que é um branch e como ele funciona:  
                                um <strong>branch</strong> nada mais é do que <strong>um ponteiro para um commit</strong>.
                            </p>

                            <p>
                                Os branches são armazenados como arquivos de texto dentro de <i>.gitadr/refs/heads</i>.  
                                O nome de cada arquivo corresponde ao nome do branch, e o conteúdo desse arquivo é o hash SHA-1 do último commit daquele branch.  
                                A cada novo commit, o arquivo do branch é atualizado com o hash do commit recém-criado.
                            </p>

                            <p>
                                Já o arquivo <code>HEAD</code>, localizado em <i>.gitadr/HEAD</i>, indica qual branch está ativo no momento.  
                                Quando você executa <code>gitadr init</code>, o branch padrão <code>master</code> é criado, e o arquivo <code>HEAD</code> recebe o valor  
                                <code>ref: refs/heads/master</code>, informando que o branch ativo é o <code>master</code>.
                            </p>

                            <p>
                                Ao criar um novo branch, o GitAdr simplesmente gera um novo arquivo em  
                                <i>.gitadr/refs/heads/[novo_branch]</i>, cujo conteúdo é o mesmo hash SHA-1 do branch atual (aquele apontado por <code>HEAD</code>).  
                                Isso significa que o novo branch passa a apontar para o mesmo commit do branch de origem.  
                                Veja o exemplo abaixo:
                            </p>

                            <pre><code>
gitadr init
1. [branch "master" é criado em .gitadr/refs/heads/master]
2. [arquivo HEAD é criado com o conteúdo: ref: refs/heads/master]

gitadr add + gitadr commit
1. [commit criado com hash SHA-1 "abc123..."]
2. [arquivo do branch (.gitadr/refs/heads/master) é atualizado com o novo hash "abc123..."]

gitadr branch teste
1. [novo arquivo criado em .gitadr/refs/heads/teste]
2. [o conteúdo desse arquivo é o mesmo hash SHA-1 da master: "abc123..." (branch de origem)]</code></pre>

                        <p>
                            Novos branches são sempre criados a partir de um commit existente do branch de origem, garantindo um fluxo linear no histórico do repositório.  
                            Essa referência ao commit de origem é fundamental, pois será utilizada posteriormente durante a operação de <i>merge</i> (que veremos mais adiante).
                        </p>

                        <p>
                            Note como o conceito de branch no Git é algo extremamente <strong>simples</strong> e <strong>leve</strong>: um branch não é uma cópia completa do branch de origem, mas apenas um pequeno arquivo de texto que armazena o identificador (hash SHA-1) de um commit, o qual por sua vez referencia uma árvore (<i>tree</i>) de arquivos e diretórios.  
                            Por isso, é possível criar milhares de branches sem qualquer impacto perceptível na performance do Git.
                        </p>

                        <p>
                            Diagrama visual da criação de um branch "feature" a partir de um commit da master:
                        </p>
                        <pre><code>o---o---o master
     \
      o---o feature</code></pre>

<details>
    <summary>Código fonte do comando branch</summary>

    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class Branch
    {
        public static List&lt;string&gt;? Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
                var branchs = Directory.GetFiles(Path.Combine(gitDir, $"refs{Path.DirectorySeparatorChar}heads"));
                var head = BranchUtils.GetHead().Replace(@$"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}", string.Empty);
                var allBranches = new List&lt;string&gt;();

                foreach (var branch in branchs)
                {
                    var name = Path.GetFileName(branch);
                    var formattedName = $"{(name == head ? "*" : string.Empty)} {name}";

                    Console.WriteLine(formattedName);
                    allBranches.Add(formattedName.Trim());
                }

                return allBranches;
            }

            var branchName = args[0];

            if (args.Length == 2 && args[0] == "-d") 
            {
                branchName = args[1];
                var head = BranchUtils.GetHead().Replace(@$"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}", string.Empty);

                if (branchName == head)
                {
                    Console.WriteLine("Não é possivel excluir o HEAD.");

                    return null;
                }

                var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
                File.Delete(Path.Combine(gitDir, $"refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}{branchName}"));

                return null;
            }

            var existHeadFile = BranchUtils.GetCommitHeadFromBranch(branchName);

            if (existHeadFile != null)
            {
                Console.WriteLine($"Já existe um branch com o nome {branchName}");
                return null;
            }

            var lastCommitSha1 = CommitUtils.GetLastCommitSha1FromHead();

            if (string.IsNullOrWhiteSpace(lastCommitSha1))
            {
                Console.WriteLine($"Não é possivel criar um branch quando não existem commits.");
                return null;
            }

            BranchUtils.CreateOrUpdateBranch($"refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}{branchName}", lastCommitSha1);

            Console.WriteLine($"Branch {branchName} criado com sucesso");

            return null;
        }
    }
}
</code></pre>
</details>      
<details>
    <summary>Código fonte da classe branchUtils.cs</summary>

    <pre><code>using System.Text;

namespace Git.Core
{
    public class BranchUtils
    {
        public static string GetHead()
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, "HEAD");

            return File.ReadAllText(path);
        }

        public static void WriteHead(string headContent)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, "HEAD");

            File.WriteAllText(path, headContent);
        }

        public static string? GetCommitHeadFromBranch(string branchFileName)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, $"refs{Path.DirectorySeparatorChar}heads", branchFileName);

            if (!File.Exists(path))
            {
                return null;
            }

            return File.ReadAllText(path);
        }

        public static List&lt;string&gt;? GetAllCommitsFromBranch(string branchFileName)
        {
            var head = GetCommitHeadFromBranch(branchFileName);

            if (string.IsNullOrWhiteSpace(head))
            {
                return null;
            }

            void GetParentCommit(string sha1, List&lt;string&gt; commits)
            {
                var data = Sha1Utils.GetObjectDataBySha1(sha1);
                var nullIndex = Array.IndexOf(data, (byte)0);
                var content = Encoding.UTF8.GetString(data[(nullIndex + 1)..]);

                var lines = content.Split('\n');

                var parent = lines.FirstOrDefault(line => line.StartsWith("parent "));

                if (!string.IsNullOrWhiteSpace(parent))
                {
                    var commitParent = parent.Split(" ")[1];
                    commits.Add(commitParent);

                    GetParentCommit(commitParent, commits);
                }
            }

            var listCommits = new List&lt;string&gt;() { head };

            GetParentCommit(head, listCommits);

            return listCommits;
        }

        public static void CreateOrUpdateBranch(string branchPath, string commitSha1)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, branchPath);

            File.WriteAllText(path, commitSha1);
        }
    }
}
</code></pre>
</details>  
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Switch</h1>

                            <p>
                                Com o comando <code>switch</code>, podemos alterar o branch ativo na <code>HEAD</code>. Ou seja, após criar um branch, podemos "entrar" nele.
                            </p>
                            <p>
                                Talvez o comando <code>switch</code> seja desconhecido para você, pois normalmente a criação e troca de branches é feita com o <code>checkout</code>. No entanto, o Git introduziu o <code>switch</code> justamente para dividir as responsabilidades do <code>checkout</code>.
                            </p>
                            <p>
                                O <code>git checkout</code> realiza várias funções: mudar de branch, criar um novo branch e alternar para ele, restaurar arquivos do workspace, entre outras. Isso gerava confusão. Por isso, no patch <a href="https://github.com/git/git/blob/2d2a71ce85026edcc40f469678a1035df0dfcf57/Documentation/RelNotes/2.23.0.adoc?plain=1#L61-L65" target="_blank" class="blog-link">2.23</a>, lançado em 2019, foram criados os comandos <code>switch</code> e <code>restore</code> (eu implementei o restore no GitAdr, mas não vou detalhar neste artigo; veja o código-fonte no GitHub).
                            </p>
                            <p>
                                A principal função do <code>switch</code> é alterar a referência do branch ativo no arquivo <code>HEAD</code>. À primeira vista, parece simples — basta mudar um arquivo de texto. Mas não é bem assim: além de atualizar o <code>HEAD</code>, é necessário <strong>atualizar o workspace</strong>. Ao trocar de branch, o workspace precisa refletir o estado do commit do branch de destino. (Lembre-se: cada branch armazena o SHA-1 do seu último commit, e cada commit armazena o estado completo do projeto. Portanto, ao mudar de branch, os arquivos devem ser ajustados para esse estado.)
                            </p>
                            <p>
                                Para ilustrar, veja o exemplo abaixo:
                            </p>
                        <pre><code>o---o---o master
     \
      o---o feature</code></pre>

                            <p>
                                Cada "o" representa um commit, ou seja, uma "cópia" do projeto em um estado diferente. Note que o branch <code>feature</code> possui dois commits: o primeiro é o mesmo da <code>master</code> (chamado de commit ancestral comum), pois todo novo branch armazena o SHA-1 do último commit do branch de origem (conforme explicado no comando <code>branch</code>). O segundo commit contém alterações no projeto, como edição, criação, movimentação ou exclusão de arquivos. Suponha que um arquivo tenha sido excluído no branch <code>feature</code>. Se um usuário que está no branch <code>feature</code> trocar para <code>master</code> com <code>gitadr switch master</code>, o arquivo deve ser recriado, refletindo o estado do commit da <code>master</code>.
                            </p>
                            <p>
                                Porém, há situações em que o <code>switch</code> não pode ser executado: quando existem alterações não commitadas na workspace que entrariam em conflito com os arquivos do branch de destino. Para entender melhor, observe este cenário:
                            </p>
                            <pre><code>João: Trocou para o branch feature, editou a linha 22 do arquivo "teste.txt" e não fez commit.
Maria: Está no branch master, editou a linha 22 do arquivo "teste.txt" e fez commit.
João: Tentou trocar para o branch master com "gitadr switch master".
João: Recebeu um erro de conflito devido a alterações não commitadas (unstaged changes).</code></pre>
                            <p>
                                O Git impede que João troque de branch por questão de segurança, evitando que alterações não salvas sejam sobrescritas.
                                Toda atualização de workspace no git é cuidadosa, evitando ao máximo perda de trabalho, mesmo que exista um possivel "erro do usuário" (cenário onde joão esqueceu de commitar),
                                segurança no git sempre foi algo primordial.
                            </p>
<details>
    <summary>Código fonte do comando Switch</summary>
    <p>Este comando utiliza: <i>BranchUtils.cs, TreeUtils.cs, CommitUtils.cs e IndexUtils.cs</i>. Todas essas classes tiveram seu código fonte mencionadas acima na documentação de outros comandos.</p>

    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class Switch
    {
        public static void Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr switch &lt;branch&gt;");
                return;
            }

            var branchName = args[0];

            var existHeadFile = BranchUtils.GetCommitHeadFromBranch(branchName);

            if (existHeadFile == null)
            {
                Console.WriteLine($"Não existe um branch com o nome {branchName}.");
                return;
            }

            var workSpaceEntries  = IndexUtils.RecursiveReadWorkSapce(Directory.GetCurrentDirectory(), new Dictionary&lt;string, string&gt;());
            var indexEntries = IndexUtils.GetIndexEntries(false);

            var targetBranchHead = BranchUtils.GetCommitHeadFromBranch(branchName);
            var targetBranchTreeSha1 = CommitUtils.GetCommitTreeSha1(targetBranchHead!);
            var targetBranchEntries = TreeUtils.GetTreeEntriesFromSha1("", targetBranchTreeSha1, new Dictionary&lt;string, (string Mode, string Sha1)&gt;());

            var commitHead = CommitUtils.GetLastCommitSha1FromHead();
            var commitHeadTreeSha1 = CommitUtils.GetCommitTreeSha1(commitHead);
            var headEntries = TreeUtils.GetTreeEntriesFromSha1("", commitHeadTreeSha1, new Dictionary&lt;string, (string Mode, string Sha1)&gt;());

            var fullEntries = workSpaceEntries.Keys.Union(indexEntries.Keys);
            
            foreach (var entry in fullEntries)
            {
                var wsSha1 = workSpaceEntries.ContainsKey(entry) ? workSpaceEntries[entry] : null;
                var idxSha1 = indexEntries.ContainsKey(entry) ? indexEntries[entry] : null;
                var tgtSha1 = targetBranchEntries.ContainsKey(entry) ? targetBranchEntries[entry].Sha1 : null;
                var headSha1 = headEntries.FirstOrDefault(e => e.Key == entry).Value.Sha1;

                if (idxSha1 == null && wsSha1 != null && tgtSha1 != null)
                {
                    Console.WriteLine($"Arquivo não rastreado '{entry}' seria sobrescrito ao trocar de branch.");
                    return;
                }

                if (wsSha1 != null && idxSha1 != null && wsSha1 != idxSha1)
                {
                    Console.WriteLine($"Existem mudanças não commitadas na workspace para '{entry}'.");
                    return;
                }

                if (tgtSha1 != null && idxSha1 != null && idxSha1 != tgtSha1 && idxSha1 != headSha1)
                {
                    Console.WriteLine($"Existem mudanças staged que conflitam com o branch alvo para '{entry}'.");
                    return;
                }
            }

            var indexLines = new List&lt;string&gt;();

            IndexUtils.RecursiveUpdateIndexFromTree("", targetBranchTreeSha1, indexLines);

            var fullNewWs = targetBranchEntries.Keys.Union(workSpaceEntries.Keys);

            foreach (var entry in fullNewWs)
            {
                var tgtSha1 = targetBranchEntries.ContainsKey(entry) ? targetBranchEntries[entry].Sha1 : null;
                var wsSha1 = workSpaceEntries.ContainsKey(entry) ? workSpaceEntries[entry] : null;
                var headSha1 = headEntries.FirstOrDefault(e => e.Key == entry).Value.Sha1;

                if (tgtSha1 != null && wsSha1 != null)
                {
                    if (tgtSha1 != wsSha1)
                    {
                        Sha1Utils.WriteFileAndDirectoriesFromSha1(entry, tgtSha1);
                    }

                    continue;
                }

                if (tgtSha1 == null && wsSha1 != null && headSha1 != null)
                {
                    File.Delete(Path.Combine(Directory.GetCurrentDirectory(), entry));
                    continue;
                }

                if (wsSha1 == null && tgtSha1 != null)
                {
                    Sha1Utils.WriteFileAndDirectoriesFromSha1(entry, tgtSha1);
                    continue;
                }
            }

            IndexUtils.RemoveEmptyDirectories(Directory.GetCurrentDirectory());

            BranchUtils.WriteHead(@$"ref: refs\heads\{branchName}");

            Console.WriteLine($"Branch atual alterado com sucesso para {branchName}");
        }
    }
}
</code></pre>
</details>  
                        </div>
            

<div class="blog-text">
    <h1 class="h4 portfolio-title">Merge</h1>

    <p>
        Com o comando <code>merge</code>, podemos mesclar dois branches.  
        Em termos simples, um <strong>merge</strong> é o processo de comparar duas árvores — ou seja, dois conjuntos de commits — e unir suas diferenças.  
        Quando mesclamos um branch A em um branch B, estamos basicamente aplicando as alterações do A dentro do B.
    </p>

    <p>
        Fazer merges no Git é, na maior parte do tempo, simples.  
        É comum manter branches vivos por longos períodos, recebendo merges periódicos e resolvendo pequenos conflitos quando necessário.  
        A própria documentação do Git recomenda não deixar um branch ficar muito tempo desatualizado em relação ao principal (geralmente <code>master</code> ou <code>main</code>), pois isso aumenta a chance de conflitos grandes e difíceis de resolver.  
        Por isso, realizar merges frequentes é uma boa prática para manter os branches sincronizados e facilitar a integração contínua.
    </p>

    <p>
        Quando executamos <code>git merge feature</code> enquanto estamos no branch <code>master</code>, o Git tenta unir o histórico de commits da <code>feature</code> dentro do histórico atual.  
        Para fazer isso, ele precisa encontrar um ponto em comum entre os dois branches — esse ponto é chamado de <strong>commit ancestral comum</strong>.
    </p>

    <pre><code>
A---B---C master
     \
      D---E feature
    </code></pre>

    <p>
        Nesse exemplo, o commit <code>B</code> é o ancestral comum entre os dois branches.  
        O Git então compara as diferenças entre:
    </p>
    <ul>
        <li><strong>O ancestral comum</strong> (<code>B</code>)</li>
        <li><strong>A ponta do branch atual</strong> (<code>C</code>)</li>
        <li><strong>A ponta do branch a ser mesclado</strong> (<code>E</code>)</li>
    </ul>

    <p>
        Essa comparação entre três commits é chamada de <strong>3-way merge</strong> (mesclagem em três vias).  
        O Git analisa o que mudou de <code>B → C</code> e o que mudou de <code>B → E</code>.  
        Se essas mudanças não afetarem as mesmas linhas ou arquivos, o Git consegue mesclar automaticamente.
    </p>

    <p>
        Um <strong>conflito de merge</strong> ocorre quando os dois branches modificam a mesma linha de um arquivo (ou um exclui e o outro altera o mesmo arquivo).  
        Nesse caso, o Git não consegue decidir qual versão deve prevalecer e marca o conflito para que o desenvolvedor escolha manualmente.
    </p>

    <pre><code>
<<<<<<< HEAD
print("Olá, mundo!")
=======
print("Olá, universo!")
>>>>>>> feature
    </code></pre>

    <p>
        Esse é o formato que o Git usa para mostrar conflitos.  
        O trecho entre <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> e <code>=======</code> mostra o conteúdo do branch atual,  
        e o trecho entre <code>=======</code> e <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> mostra o conteúdo do branch que está sendo mesclado.  
        Após escolher a versão correta (ou combinar ambas), basta salvar o arquivo e executar:
    </p>

    <pre><code>git add arquivo.txt
git commit</code></pre>

    <p>
        O commit resultante será um <strong>commit de merge</strong>, que une os dois históricos em um ponto comum.
    </p>

     <p>
        O Git oferece diferentes estratégias para realizar merges, dependendo da situação:
    </p>

    <ul>
        <li>
            <strong>Recursive/Ort (padrão)</strong> — usada em merges comuns entre dois branches.  
            É a estratégia que realiza o 3-way merge automaticamente e tenta resolver conflitos simples.
        </li>
        <li>
            <strong>Ours</strong> — ignora as alterações do branch que está sendo mesclado, mantendo apenas as do branch atual.
        </li>
        <li>
            <strong>Theirs</strong> — o oposto de <code>ours</code>; ignora o branch atual e mantém o conteúdo do branch que está sendo mesclado.
        </li>
        <li>
            <strong>Octopus</strong> — usada para mesclar mais de dois branches de uma só vez (geralmente em merges automáticos de integração).
        </li>
    </ul>
    <p></p>

    <p>
        Quando um merge é finalizado, o git cria um novo <strong>commit de merge</strong>.
        Diferente de um commit comum, que possui apenas um <em>parent</em> (ancestral direto),  
        um <strong>commit de merge</strong> possui <strong>dois parents</strong>: o commit da branch atual e o commit da branch mesclada.
    </p>

    <pre><code>
A---B---C---F (master)
     \     /
      D---E (feature)
    </code></pre>

    <p>
        Nesse exemplo, o commit <code>F</code> é o <strong>commit de merge</strong>.  
        Ele tem dois ancestrais: <code>C</code> (do branch <code>master</code>) e <code>E</code> (do branch <code>feature</code>).  
        O Git cria esse commit automaticamente para representar o ponto onde os dois históricos se unem.
    </p>

    <p>
        Internamente, o commit de merge contém uma nova árvore (tree) resultante da mesclagem das duas árvores anteriores,  
        e seu cabeçalho (header) inclui duas linhas <code>parent</code> em vez de uma:
    </p>

    <pre><code>
tree a9b3e4f...
parent 7f1a2b3  ← commit C
parent 1d9c4e7  ← commit E
author João &lt;joao@example.com&gt; 1738702336 +0300
committer João &lt;joao@example.com&gt; 1738702336 +0300
Merge branch 'feature' into 'master'
    </code></pre>

<p>
    Além do merge tradicional, o Git também oferece um modo de merge chamado <code>--ff-only</code> (fast-forward only).
    Esse modo é mais simples e restritivo: ele apenas move o ponteiro do branch atual para o commit mais recente do branch de destino,
    sem criar um novo commit de merge.
</p>

<p>
    Isso só é possível quando o histórico do branch atual está diretamente "atrás" do branch que queremos unir, ou seja,
    quando não existem commits divergentes entre eles.
    Nesse caso, o Git entende que pode simplesmente "avançar" o ponteiro do branch sem precisar fazer nenhuma comparação de árvores.
</p>

<pre><code>
A---B---C  (main)
           \
            D---E  (feature)
</code></pre>

<p>
    Se executarmos <code>git merge --ff-only feature</code> estando no branch <code>main</code>,
    o Git não criará um commit de merge. Em vez disso, ele apenas moverá o ponteiro de <code>main</code> até o commit <code>E</code>:
</p>

<pre><code>
A---B---C---D---E  (main, feature)
</code></pre>

<p>
    Esse tipo de merge mantém o histórico <strong>linear</strong> e limpo — como se todos os commits tivessem ocorrido
    no mesmo branch. É muito usado em projetos que preferem manter um histórico sem commits de merge visuais.
</p>

<p>
    No entanto, se houver commits divergentes (por exemplo, se o branch atual tiver commits que o branch de destino não possui),
    o Git <strong>não permitirá</strong> o fast-forward e exibirá um erro:
</p>

<pre><code>
A---B---C---F  (main)
     \
      D---E  (feature)

$ git merge --ff-only feature
fatal: Not possible to fast-forward, aborting.
</code></pre>

<p>
    Nesse caso, só seria possível realizar um merge tradicional, com a criação de um novo commit que unifica as duas histórias.
</p>


<p>
    No código abaixo, implementei o merge utilizando a estratégia padrão do Git (<strong>Ort</strong>).
    Essa implementação detecta automaticamente o <strong>commit ancestral comum</strong> e realiza o <strong>commit de merge</strong> quando necessário.
    Além disso, inclui suporte ao modo <code>--ff-only</code>.
</p>
<p>
    Em caso de conflitos, a operação é <em>abortada</em> e o console exibe quais arquivos apresentaram divergências.
    Caso deseje evoluir essa implementação, é possível adicionar facilmente um mecanismo de resolução de conflitos,
    já que a estrutura principal do processo de merge já está pronta.
</p>

<details>
    <summary>Código fonte do comando Merge</summary>

    <p>Este comando utiliza: <i>BranchUtils.cs, TreeUtils.cs, CommitUtils.cs, IndexUtils.cs e Sha1Utils.cs</i>. Todas essas classes tiveram seu código fonte mencionadas acima na documentação de outros comandos.</p>

    <pre><code>using Git.Core;
using TreeEntry = Git.Core.TreeUtils.TreeEntry;

namespace Git.Commands
{
    public class Merge
    {
        public static void Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr merge &lt;branch&gt;");
                return;
            }

            var ffOnly = false;
            string targetBranch;

            if (args[0] == "--ff-only" && args.Length >= 2)
            {
                ffOnly = true;
                targetBranch = args[1];
            }
            else
            {
                targetBranch = args[0];
            }

            var targetCommit = BranchUtils.GetCommitHeadFromBranch(targetBranch);

            if (targetCommit == null)
            {
                Console.WriteLine($"Não existe um branch com o nome {targetBranch}");
                return;
            }

            var headBranch = BranchUtils.GetHead();
            var headCommit = CommitUtils.GetLastCommitSha1FromHead();
            var headCommits = BranchUtils.GetAllCommitsFromBranch(headBranch.Replace($"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}", ""));

            var targetTreeSha1 = CommitUtils.GetCommitTreeSha1(targetCommit);
            var targetCommits = BranchUtils.GetAllCommitsFromBranch(targetBranch);

            if (targetCommits!.All(commit => headCommits!.Contains(commit)))
            {
                Console.WriteLine($"Already up to date.");

                return;
            }

            var commitBase = FindMergeBase(headCommit, targetCommit);

            var baseTreeSha1 = CommitUtils.GetCommitTreeSha1(commitBase!);
            var baseEntries = TreeUtils.GetTreeData(baseTreeSha1);

            var headTreeSha1 = CommitUtils.GetCommitTreeSha1(headCommit);
            var headEntries = TreeUtils.GetTreeData(headTreeSha1);

            var targetEntries = TreeUtils.GetTreeData(targetTreeSha1);

            var addedOrUpdatedFiles = new Dictionary&lt;string, string&gt;();
            var removedFiles = new Dictionary&lt;string, string&gt;();

            if (ffOnly)
            {
                var canFastForward = headCommits!.All(c => targetCommits!.Contains(c));

                if (!canFastForward)
                {
                    Console.WriteLine($"Não é possível realizar fast-forward merge para {targetBranch}, abortando.");
                    return;
                }

                var survivingFiles = new HashSet&lt;string&gt;();
                UpdateIndexAndWorkSpaceFromTree(targetEntries, survivingFiles);
                RemoveFilesAndDirectories(survivingFiles);

                BranchUtils.CreateOrUpdateBranch(headBranch.Replace("ref: ", string.Empty), targetCommit);
                Console.WriteLine($"Fast-forward merge realizado para {targetBranch}");
                return;
            }

            var mergedEntries = BuildTreeFromTwoTreeDiffs(baseEntries, headEntries, targetEntries);

            if (mergedEntries.Count > 0)
            {
                var survivingFiles = new HashSet&lt;string&gt;();
                UpdateIndexAndWorkSpaceFromTree(mergedEntries, survivingFiles);
                RemoveFilesAndDirectories(survivingFiles);

                var mergeRootSha1 = TreeObject.WriteTree(mergedEntries);
                var mergeCommitSha1 = CommitObject.WriteCommit(
                                        mergeRootSha1, 
                                        $"Merge branch {targetBranch} into {headBranch.Replace(@$"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}", string.Empty)}", 
                                        [headCommit, targetCommit]);

                BranchUtils.CreateOrUpdateBranch(headBranch.Replace("ref: ", string.Empty), mergeCommitSha1);
            }
        }

        private static List&lt;TreeEntry&gt; BuildTreeFromTwoTreeDiffs(
            List&lt;TreeEntry&gt; baseEntries,
            List&lt;TreeEntry&gt; headEntries,
            List&lt;TreeEntry&gt; targetEntries
        )
        {
            var mergedEntries = new List&lt;TreeEntry&gt;();

            var allNames = baseEntries.Select(e => e.Name)
                .Union(headEntries.Select(e => e.Name))
                .Union(targetEntries.Select(e => e.Name));

            foreach (var name in allNames)
            {
                var baseEntry = baseEntries.FirstOrDefault(e => e.Name == name);
                var headEntry = headEntries.FirstOrDefault(e => e.Name == name);
                var targetEntry = targetEntries.FirstOrDefault(e => e.Name == name);

                if (baseEntry == null && headEntry == null && targetEntry != null)
                {
                    mergedEntries.Add(targetEntry);
                    continue;
                }

                if (baseEntry == null && targetEntry == null && headEntry != null)
                {
                    mergedEntries.Add(headEntry);
                    continue;
                }

                if (headEntry == null && targetEntry == null && baseEntry != null)
                {
                    continue;
                }

                if (headEntry != null && targetEntry != null && baseEntry != null)
                {
                    if (headEntry.Mode.StartsWith("040") || targetEntry.Mode.StartsWith("040"))
                    {
                        var headSubtree = headEntry != null ? TreeUtils.GetTreeData(headEntry.Sha1) : new List&lt;TreeEntry&gt;();
                        var targetSubtree = targetEntry != null ? TreeUtils.GetTreeData(targetEntry.Sha1) : new List&lt;TreeEntry&gt;();
                        var baseSubtree = baseEntry != null ? TreeUtils.GetTreeData(baseEntry.Sha1) : new List&lt;TreeEntry&gt;();

                        var mergedSubtree = BuildTreeFromTwoTreeDiffs(baseSubtree, headSubtree, targetSubtree);

                        if (mergedSubtree.Any())
                        {
                            var newTreeSha1 = TreeObject.WriteTree(mergedSubtree);
                            mergedEntries.Add(new TreeEntry
                            {
                                Mode = "040000",
                                Name = name,
                                Sha1 = newTreeSha1
                            });
                        }

                        continue;
                    }

                    if (baseEntry.Sha1 == headEntry.Sha1 && headEntry.Sha1 == targetEntry.Sha1)
                    {
                        mergedEntries.Add(targetEntry);
                    }

                    if (baseEntry.Sha1 == headEntry.Sha1 && headEntry.Sha1 != targetEntry.Sha1)
                    {
                        mergedEntries.Add(targetEntry);
                    }

                    if (baseEntry.Sha1 == targetEntry.Sha1 && headEntry.Sha1 != targetEntry.Sha1)
                    {
                        mergedEntries.Add(headEntry);
                    }

                    if (baseEntry.Sha1 != targetEntry.Sha1 && baseEntry.Sha1 != headEntry.Sha1)
                    {
                        Console.WriteLine($"Conflito detectado no arquivo {name}");
                        return new List&lt;TreeEntry&gt;();
                    }

                    continue;
                }
            }

            return mergedEntries;
        }

        private static void UpdateIndexAndWorkSpaceFromTree(List&lt;TreeEntry&gt; treeData, HashSet&lt;string&gt; survivingFiles)
        {
            foreach (var entry in treeData)
            {
                if (entry.Mode.StartsWith("040"))
                {
                    var subEntries = TreeUtils.GetTreeData(entry.Sha1);

                    foreach (var subEntry in subEntries)
                    {
                        var fullPath = Path.Combine(entry.Name, subEntry.Name);

                        if (subEntry.Mode.StartsWith("040"))
                        {
                            UpdateIndexAndWorkSpaceFromTree(
                                new List&lt;TreeEntry&gt; {
                                    new TreeEntry {
                                        Mode = subEntry.Mode,
                                        Name = fullPath,
                                        Sha1 = subEntry.Sha1
                                    }
                                },
                                survivingFiles
                            );
                        }
                        else
                        {
                            AddOrUpdateIndexFile(fullPath, subEntry.Sha1);
                            survivingFiles.Add(fullPath);
                            Sha1Utils.WriteFileAndDirectoriesFromSha1(fullPath, subEntry.Sha1);
                        }
                    }

                    continue;
                }

                AddOrUpdateIndexFile(entry.Name, entry.Sha1);
                survivingFiles.Add(entry.Name);

                Sha1Utils.WriteFileAndDirectoriesFromSha1(entry.Name, entry.Sha1);
            }
        }

        private static void RemoveFilesAndDirectories(HashSet&lt;string&gt; survivingFiles)
        {
            var currentIndex = IndexUtils.GetIndexEntries(true);

            foreach (var file in currentIndex.Keys)
            {
                if (!survivingFiles.Contains(file))
                {
                    RemoveIndexFile(file);
                    if (File.Exists(file))
                    {
                        File.Delete(file);
                    }
                }
            }

            IndexUtils.RemoveEmptyDirectories(Directory.GetCurrentDirectory());
        }

        private static void AddOrUpdateIndexFile(string file, string sha1)
        {
            var lines = IndexUtils.GetIndexEntries(true);

            var newContentLines = new List&lt;string&gt;();
            var found = false;

            foreach (var fileName in lines.Keys)
            {
                var fileSha1 = lines[fileName];

                if (fileName == file)
                {
                    found = true;
                    if (fileSha1 == sha1)
                    {
                        return;
                    }
                    else
                    {
                        newContentLines.Add($"{sha1} {fileName}");
                    }
                }
                else
                {
                    newContentLines.Add($"{fileSha1} {fileName}");
                }
            }

            if (!found)
            {
                newContentLines.Add($"{sha1} {file}");
            }

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', newContentLines) + "\n");
        }

        private static void RemoveIndexFile(string file)
        {
            var lines = IndexUtils.GetIndexEntries(true);
            lines.Remove(file);
            var newContentLines = new List&lt;string&gt;();

            foreach (var fileName in lines.Keys)
            {
                newContentLines.Add($"{lines[fileName]} {fileName}");
            }

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', newContentLines) + "\n");
        }

        private static string? FindMergeBase(string headCommit, string targetCommit)
        {
            var headAncestors = new HashSet&lt;string&gt;(GetAllCommitsFromCommit(headCommit));

            var targetAncestors = GetAllCommitsFromCommit(targetCommit);

            foreach (var commit in targetAncestors)
            {
                if (headAncestors.Contains(commit))
                {
                    return commit;
                }
            }

            return null;
        }

        private static List&lt;string&gt; GetAllCommitsFromCommit(string commitSha1)
        {
            var commits = new List&lt;string&gt;();
            var stack = new Stack&lt;string&gt;();
            var visited = new HashSet&lt;string&gt;();

            stack.Push(commitSha1);

            while (stack.Count > 0)
            {
                var current = stack.Pop();

                if (visited.Contains(current))
                {
                    continue;
                }

                visited.Add(current);
                commits.Add(current);

                var parents = CommitUtils.GetCommitParents(current);
                foreach (var parent in parents)
                {
                    stack.Push(parent);
                }
            }

            return commits;
        }
    }
}
</code></pre>
</details>  
</div>
<div class="blog-text">
    <h1 class="h4 portfolio-title">Conclusão</h1>

    <p>
        Com este projeto, foi possível compreender de forma mais clara como funciona a estrutura interna do Git. 
        Utilizando os métodos das classes em <code>Utils</code>, é possível implementar praticamente qualquer outro comando do Git, 
        o que permite dar continuidade ao projeto com a adição de funcionalidades como <code>rebase</code>, <code>cherry-pick</code>, 
        <code>stash</code> e outros. 
        Neste artigo, apresentei 10 comandos — os que considero essenciais para entender o funcionamento do Git —, 
        embora, ao todo, tenham sido desenvolvidos 15 comandos.
    </p>

    <p>
        Além disso, dediquei um bom tempo ao desenvolvimento do comando <code>diff</code>, 
        estudando a fundo algoritmos de comparação como Myers, Patience, Histogram e outros. 
        No entanto, vou deixar para detalhar essa experiência em um próximo artigo, 
        dedicado exclusivamente ao sistema de diff que desenvolvi em Rust.
    </p>

    <p>
        Enfim, as possibilidades que esse projeto oferece são enormes. 
        A experiência de desenvolver algo mais avançado que o 
        <a href="https://wyag.thb.lt" target="_blank" class="blog-link">Write Yourself a Git</a> 
        foi extremamente gratificante. 
        No total, foram cerca de duas semanas e meia de programação e pesquisa intensas.
    </p>

    <p>
        Com certeza, aprendi muito mais sobre o Git ao longo dessa experiência. 
        E se você leu e entendeu tudo (ou quase tudo), espero que também tenha aprendido bastante com o projeto!
    </p>
</div>
<div class="blog-text">
  <h1 class="h4 portfolio-title">Referências</h1>
  <ol class="list-decimal list-inside space-y-1">
    <li><a href="https://www.gnu.org/software/trans-coord/manual/cvs/cvs.html" target="_blank" class="blog-link">Manual do CVS (GNU)</a></li>
    <li><a href="https://rahul.gopinath.org/post/2011/12/30/version-control-systems/" target="_blank" class="blog-link">Version Control Systems — Rahul Gopinath</a></li>
    <li><a href="https://www.projecthut.com/cvs-version-control-system-explained/" target="_blank" class="blog-link">The CVS Version Control System Explained</a></li>
    <li><a href="https://medium.com/@chittaranjansethi/comparing-version-control-systems-git-svn-cvs-and-more-6af27a74685d" target="_blank" class="blog-link">Comparing Version Control Systems: Git, SVN, CVS, and More</a></li>
    <li><a href="https://www.geeksforgeeks.org/difference-between-concurrent-versions-system-cvs-and-subversion-svn/" target="_blank" class="blog-link">Difference Between CVS and Subversion (SVN)</a></li>
    <li><a href="https://www.youtube.com/watch?v=idLyobOhtO4" target="_blank" class="blog-link">Linus Torvalds — Google Tech Talk (2007)</a></li>
    <li><a href="https://www.linuxjournal.com/content/git-origin-story" target="_blank" class="blog-link">A Git Origin Story — Linux Journal</a></li>
    <li><a href="https://www.britannica.com/technology/Git" target="_blank" class="blog-link">Git — Encyclopaedia Britannica</a></li>
    <li><a href="https://www.red-gate.com/simple-talk/devops/tools/how-we-ended-up-with-git/" target="_blank" class="blog-link">How We Ended Up with Git — Red Gate</a></li>
    <li><a href="https://git-scm.com/book/en/v2" target="_blank" class="blog-link">Pro Git (Livro Oficial)</a></li>
    <li><a href="https://github.com/git/git" target="_blank" class="blog-link">Repositório Oficial do Git</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Mercurial" target="_blank" class="blog-link">Mercurial — Wikipedia</a></li>
    <li><a href="https://www.atlassian.com/blog/software-teams/mercurial-vs-git-why-mercurial" target="_blank" class="blog-link">Mercurial vs. Git: Why Mercurial? — Atlassian</a></li>
    <li><a href="https://darcs.net/" target="_blank" class="blog-link">Darcs — Site Oficial</a></li>
    <li><a href="https://www.geeksforgeeks.org/git/how-git-changed-open-source/" target="_blank" class="blog-link">How Git Changed Open Source — GeeksforGeeks</a></li>
  </ol>
</div>  
                    </section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../assets/js/index.js"></script>
    </body>
</html>
