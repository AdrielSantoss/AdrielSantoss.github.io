'<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Git</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Criando o meu próprio git</h1>
                    </section>
                    <br />

                    <section>
                        <div class="tags">
                            <small class="tag">Git</small>
                            <small class="tag">C#</small>
                            <small class="tag">Estrutura de dados</small>
                            <small class="tag">.NET</small>
                            <small class="tag">CVS</small>
                            <small class="tag">SVN</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div class="blog-text">
                            <p>
                                Há algum tempo, me deparei com o artigo
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">Write Yourself a Git</a>
                                Ao lê-lo, despertou em mim um desejo que se somou a uma vontade antiga que eu já
                                possuía: implementar uma versão simplificada do Git, com o objetivo de exercitar, de
                                maneira prática, tudo aquilo que eu já havia estudado em
                                <a
                                    href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects"
                                    target="_blank"
                                    class="blog-link"
                                    >Git internals.</a
                                >
                            </p>
                            <p>
                                No dia em que escrevo este artigo, o Git já completou 20 anos de existência, e acredito
                                que, há mais de 15 anos, vem se tornando uma ferramenta <strong>obrigatória</strong> no
                                dia a dia de qualquer pessoa que se diz programadora. Entender como essa ferramenta
                                funciona é tão importante quanto compreender algoritmos e estruturas de dados.
                            </p>
                            <p>
                                Obviamente, <strong>entender</strong> como algo funciona não é a mesma coisa que saber
                                <strong>usar</strong>. Qualquer pessoa aprende, em uma tarde, os comandos básicos, e em
                                uma semana já consegue incorporar o Git por completo em seu fluxo de trabalho. No
                                entanto, poucos realmente sabem o que está acontecendo com seus arquivos, e muito menos
                                compreendem o motivo de estarem usando o Git.
                            </p>
                            <p>
                                Obtive uma experiencia muito interessante, que durou aproximadamente 3 semanas, eu
                                implementei 14 comandos do git (talvez, com o passar do tempo, implemente ainda mais), e
                                cada comando constrói e manipula os tres princiapis objetos do git: Blob, Tree e Commit.
                                Dito isso, o meu objetivo nesse artigo, é descrever como foi essa experiencia, o que eu
                                aprendi nesse periodo.
                            </p>
                            <p>
                                Além de implementar mais comandos e funcionalidades do que o artigo "Write Yourself a
                                Git" apresenta, também optei por utilizar uma linguagem de programação diferente do
                                Python. No meu caso, escolhi C# (.NET 9.0) por preferência pessoal. Este projeto pode
                                ser desenvolvido com fluidez em qualquer linguagem moderna de alto nível.
                            </p>
                            <p>
                                Obviamente, não vou conseguir documentar e detalhar todos os comandos, apenas vou citar
                                os principais para explicar a estrutura do git, para entender como implementei cada
                                comando, acesse o projeto no
                                <a
                                    href="https://github.com/AdrielSantoss/Write-Yourself-A-Git"
                                    target="_blank"
                                    class="blog-link"
                                    >Github</a
                                >.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>
                            <p>
                                Prometo não me alongar muito, portanto, tente não dormir… Se você quer realmente
                                entender o Git, conhecer um pouco do passado nebuloso do período pré-Git é extremamente
                                importante. Somente assim você vai compreender o real motivo de estar usando o Git hoje.
                            </p>
                            <p>
                                Antes do Git, os sistemas de controle de versão mais utilizados eram: SVN, BitKeeper e
                                CVS. Pesquisando mais a fundo, encontramos nomes como Visual SourceSafe, Mercurial,
                                Bazaar, e, ainda mais antigos, SCCS e RCS. Todos, sem exceção, apresentavam soluções
                                complexas e problemáticas demais para lidar com um problema ainda mais desafiador:
                                gerenciar versões de arquivos.
                            </p>
                            <p>
                                Cada uma dessas ferramentas surgiu com o objetivo de corrigir problemas de seus
                                concorrentes, mas, ao fazer isso, gerava ou ignorava outros problemas. Um exemplo
                                clássico é a "evolução" entre o SVN (Subversion) e o CVS (Concurrent Versions System),
                                ambos gratuitos e de código aberto.
                            </p>
                            <p>
                                Em resumo, CVS e SVN apresentavam um sistema centralizado, ou seja, tudo era gerenciado
                                e monitorado por um servidor central. Por exemplo, para fazer commits (o famoso
                                "comitar"), era necessário solicitar permissão ao servidor.
                            </p>
                            <p>
                                O CVS era considerado o “inferno na terra” quando se tratava de sistemas de
                                versionamento. Alguns dos seus principais problemas/limitações eram: apenas arquivos
                                eram versionados, diretórios não; arquivos se perdiam no histórico quando eram movidos
                                ou renomeados; e commits não eram operações atômicas — portanto, se um commit falhasse
                                no meio, havia o risco de corromper todo o repositório.
                            </p>
                            <p>
                                Quando surgiu, o SVN corrigiu todos esses problemas, mas isso não o tornou
                                necessariamente “melhor”. O SVN ainda possuía várias limitações, e um de seus principais
                                problemas não estava na parte técnica, mas sim no marketing, que utilizava o slogan:
                                “SVN is CVS done right”.
                            </p>
                            <p>
                                Uma das críticas mais notórias ao SVN e à sua campanha de marketing veio de ninguém
                                menos que Linus Torvalds, durante sua famosa palestra sobre o Git no Google:
                                <a href="https://www.youtube.com/watch?v=idLyobOhtO4m" class="blog-link" target="_blank"
                                    >Linus Torvalds, Google Tech Talk.</a
                                >
                                Recomendo fortemente assistir a essa palestra para compreender as complicações que esses
                                sistemas geravam no dia a dia dos programadores no fim dos anos 90 e início dos anos
                                2000.
                            </p>
                            <p>
                                Em resumo, os principais problemas do SVN eram: merges frágeis, com risco de conflitos
                                complexos (two-way merge); criação de branches ainda era uma tarefa cara (apesar do
                                marketing afirmar o contrário); dificuldade em comparar branches complexos; problemas de
                                desempenho em projetos grandes; entre outros.
                            </p>
                            <p>
                                O branching no SVN foi uma melhoria em relação ao CVS, mas ainda apresentava limitações
                                que o tornavam caro em termos práticos. Criar um branch no CVS/SVN era equivalente a
                                <strong>duplicar</strong> o diretório principal. Agora imagine fazer isso com frequência
                                em projetos gigantes como o kernel do Linux... Mesclar dois branches no SVN era uma
                                operação <strong>custosa</strong> e, principalmente, <strong>ineficiente</strong>,
                                devido ao fraco algoritmo de merge, chamado <strong>two-way merge</strong>. Na prática,
                                realizar um merge significava comparar TUDO de um branch contra TUDO do branch trunk
                                (branch principal do SVN, equivalente ao master/main do Git). Esse processo fazia com
                                que conflitos surgissem com extrema facilidade. Já o CVS aplicava o
                                <b>three-way merge</b>, de forma limitada, pois não rastreava bem histórico de merges
                                anteriores. (Nesse aspecto, podemos concluir que SVN não era um CVS feito direito...)
                            </p>
                            <p>
                                Devido a todos os problemas do CVS e do SVN, Linus Torvalds optou por utilizar o
                                BitKeeper no desenvolvimento do kernel no início dos anos 2000. Os principais motivos
                                dessa escolha eram que o BitKeeper era um sistema distribuído, lidava melhor com grandes
                                bases de código (um ponto crítico em que CVS e SVN falhavam) e oferecia um mecanismo de
                                merge relativamente eficiente.
                            </p>
                            <p>
                                A BitMover, empresa responsável pelo BitKeeper, ofereceu licenças gratuitas para uso no
                                kernel Linux, desde que não fossem utilizadas para desenvolver ferramentas concorrentes.
                                Apesar da contradição ideológica de depender de um software proprietário para criar um
                                software livre, tudo corria bem até que, em 2005, o acesso gratuito ao BitKeeper foi
                                revogado.
                            </p>
                            <p>
                                Esse foi o ponto decisivo que levou diretamente ao nascimento do Git. A BitMover começou
                                a desconfiar que a comunidade do Linux estava realizando engenharia reversa do protocolo
                                de rede do BitKeeper. De certa forma, isso era verdade: muitos desenvolvedores não
                                aceitavam a ideia de depender de um software fechado para um projeto como o kernel, e
                                alguns começaram a criar alternativas capazes de ler e interagir com repositórios do
                                BitKeeper. A mais conhecida delas foi o <em>SourcePuller</em>.
                            </p>
                            <p>
                                Após a revogação das licenças gratuitas do BitKeeper, Linus Torvalds decidiu resolver
                                esse problema de forma definitiva. Ele queria um sistema de controle de versão que
                                atendesse aos seguintes requisitos: ser distribuído, eficiente, rápido, resistente à
                                corrupção de dados e 100% software livre.
                            </p>
                            <p>
                                As opções disponíveis na época eram: Mercurial, Bazaar, Darcs e Monotone. Todas, no
                                entanto, apresentavam problemas de desempenho em projetos grandes como o kernel. Com
                                essas alternativas descartadas, restou apenas uma saída: criar um novo sistema de
                                versionamento. Assim nasceu o Git, que se tornaria o sistema de controle de versão mais
                                utilizado da história.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Init e Objects</h1>
                            <p>
                                Em resumo, o Git é um sistema que cria e manipula um "banco de dados de objetos". Esses
                                objetos são: <em>Blob</em>, <em>Tree</em>, <em>Commit</em> e <em>Tag</em>. Sendo o
                                <em>Tag</em> um objeto não essencial para o funcionamento do Git. Implementei comandos
                                capazes de criar, excluir e editar os três objetos essenciais. Conforme eu for
                                detalhando a implementação de cada comando, também explicarei como esses objetos
                                funcionam e se relacionam.
                            </p>
                            <p>
                                O primeiro comando abordado será o de inicialização do repositório
                                <em>.gitadr</em> (equivalente ao <em>.git</em>). É dentro desse repositório (ou pasta,
                                se você for da terra do Windows) que são armazenados os objetos e arquivos auxiliares
                                necessários para o funcionamento do Git.
                            </p>
                            <details>
                                <summary>Código fonte do comando Init</summary>
                                <pre><code>using Git.Core;
using System.Text;

namespace Git.Commands
{
    public class Init
    {
        public static void Execute()
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");

            if (Directory.Exists(gitDir))
            {
                Console.WriteLine("Repositório .gitadr já existe.");
                return;
            }

            Directory.CreateDirectory(gitDir);
            Directory.CreateDirectory(Path.Combine(gitDir, "objects"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs"));
            Directory.CreateDirectory(Path.Combine(gitDir, "refs", "heads"));

            File.WriteAllText(Path.Combine(gitDir, "refs", "heads", "master"), string.Empty);
            File.WriteAllText(Path.Combine(gitDir, "HEAD"), $"ref: refs{Path.DirectorySeparatorChar}heads{Path.DirectorySeparatorChar}master");

            Console.WriteLine($"Repositório inicializado em {gitDir}");
        }
    }
}</code></pre>
                            </details>

                            <p>Estrutura criada pelo comando <code>init</code>:</p>

                            <p>
                                <strong>.gitadr</strong>: diretório principal do sistema ("adr" = <em>Adriel</em>).
                                <br />

                                <strong>/objects</strong>: onde ficam os objetos do Git (<em>Blob</em>, <em>Tree</em>,
                                <em>Commit</em> e <em>Tag</em>). <br />

                                <strong>/refs/heads</strong>: contém os arquivos que representam os branches. O projeto
                                já inicia com o branch <code>master</code>. <br />

                                <strong>HEAD</strong>: arquivo que guarda a referência do branch atual, iniciando com
                                <code>ref: refs/heads/master</code>. <br />
                            </p>

                            <p>
                                Esse comando não tem grandes segredos: ele basicamente cria diretórios e arquivos. Note
                                que mantive a convenção de usar um nome iniciado por ponto (<code>.gitadr</code>) para o
                                diretório principal. Em sistemas Unix-like (Linux e macOS), arquivos e pastas que
                                começam com <code>.</code> são tratados como ocultos.
                            </p>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Hash-Object</h1>

                            <p>
                                Este é um dos comandos
                                <a href="https://wyag.thb.lt" target="_blank" class="blog-link">plumbing</a> mais
                                importantes do Git. Seu objetivo é transformar um arquivo em um objeto <em>blob</em> e
                                armazená-lo no repositório.
                            </p>
                            <p>
                                Um objeto <em>blob</em> (<strong>binary large object</strong>) nada mais é do que um
                                conjunto de bytes que guarda apenas duas informações: o tamanho do conteúdo e o próprio
                                conteúdo do arquivo. Sua estrutura binária segue o formato:
                            </p>
                            <pre><code>blob content.length\0contentBytes</code></pre>
                            <p>
                                <strong><code>blob content.length</code></strong
                                >: Cabeçalho do objeto. É composto pela palavra <code>blob</code>, seguida de um espaço
                                em branco e do tamanho total do conteúdo em bytes. <br />

                                <strong><code>\0</code></strong
                                >: Caractere nulo que separa o cabeçalho do conteúdo. <br />

                                <strong><code>contentBytes</code></strong
                                >: O conteúdo do arquivo em si, armazenado em formato binário.
                            </p>
                            <p>
                                Repare que o <em>blob</em> não guarda informações como nome do arquivo, autor ou data de
                                criação. Para ele, esses metadados são irrelevantes: o que importa é apenas o conteúdo
                                puro.
                            </p>
                            <p>
                                Depois de combinar os bytes do cabeçalho com os bytes do conteúdo, o resultado é
                                processado pela função
                                <strong>SHA-1</strong>. Essa função gera um identificador único de 20 bytes, que em
                                seguida é convertido para uma representação em string hexadecimal. O resultado é algo
                                como:
                            </p>

                            <pre><code>658e12ad10bfd93dcf0712de258795828f6c4240</code></pre>

                            <p>
                                Esse formato de hash provavelmente já lhe é familiar: é o identificador único de
                                <strong>todos</strong> os objetos no Git. Cada hash possui 40 caracteres hexadecimais.
                                No armazenamento, os 2 primeiros caracteres são usados para nomear o diretório, e os 38
                                restantes para nomear o arquivo do objeto.
                            </p>

                            <p>
                                Os arquivos binários dos objetos não ficam soltos diretamente dentro de
                                <code>/objects</code>. Em vez disso, cada objeto é armazenado em um subdiretório cujo
                                nome corresponde aos dois primeiros caracteres do hash SHA-1. Essa divisão surgiu por
                                conta das limitações de sistemas de arquivos mais antigos (como ext2, FAT32 ou versões
                                iniciais do NTFS), que não lidavam bem com diretórios contendo dezenas ou até centenas
                                de milhares de arquivos.
                            </p>

                            <p>
                                Se você abrir agora o diretório <code>.git/objects</code>, verá exatamente essa
                                estrutura. Exemplo dos diretórios de objetos:
                            </p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/diretorios-de-objetos.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                <div class="item-description">
                                    <small
                                        ><i
                                            >Cada diretório representa o prefixo (2 caracteres) de um hash de objeto.</i
                                        ></small
                                    >
                                </div>
                            </div>

                            <br />

                            <p>Exemplo de um objeto armazenado com seu hash completo dentro do diretório:</p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/objeto.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                <div class="item-description">
                                    <small
                                        ><i
                                            >Arquivo binário de um objeto blob, nomeado com 38 caracteres hexadecimais
                                            do hash.</i
                                        ></small
                                    >
                                </div>
                            </div>

                            <p>
                                Entendendo essa estrutura, a implementação do comando <code>hash-object</code> se torna
                                simples: basta gerar o hash SHA-1 do conteúdo com uma biblioteca de criptografia e criar
                                o arquivo binário correspondente.
                            </p>

                            <details>
                                <summary>Código fonte do comando Hash-Object</summary>
                                <pre><code>using Csharp.Core;
using Git.Core;

namespace Git.Commands
{
    public class HashObject
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr hash-object [-w] &lt;arquivo&gt;");
                return string.Empty;
            }

            var write = args[0] == "-w";
            var path = write ? args[1] : args[0];

            if (!File.Exists(path))
            {
                throw new Exception($"Arquivo não encontrado: {path}");
            }

            var (sha1Hash, fullBlob) = BlobUtils.WriteBlob(path);

            if (write)
            {
                ObjectStore.WriteObject(sha1Hash, fullBlob);
            }
            else
            {
                Console.WriteLine(sha1Hash);
            }

            return sha1Hash;
        }
    }
}
</code></pre>
                        </details>

                        <details>
                            <summary>Código fonte dos métodos utilitários sha1 (Sha1Utils.cs)</summary>
                            <p>
                                Nessa classe, está presente os métodos utilitários para a utilização e aplicação da criptografia sha1, alguns métodos abaixos vão ser reaproveitados em outros comandos.
                            </p>
                                <pre><code>using System.IO.Compression;
using System.Security.Cryptography;

namespace Git.Core
{
    public class Sha1Utils
    {
        public static byte[] CombineBytes(byte[] a, byte[] b)
        {
            var combined = new byte[a.Length + b.Length];
            Buffer.BlockCopy(a, 0, combined, 0, a.Length);
            Buffer.BlockCopy(b, 0, combined, a.Length, b.Length);

            return combined;
        }

        public static string Sha1BytesToString(byte[] sha1)
        {
            return BitConverter.ToString(sha1).Replace("-", "").ToLower();
        }

        public static byte[] Sha1StringToBytes(string sha1)
        {
            var bytes = new byte[20];
            for (var i = 0; i &lt; 20; i++)
            {
                var byteString = sha1.Substring(i * 2, 2);
                bytes[i] = Convert.ToByte(byteString, 16);
            }

            return bytes;
        }

        public static string CreateSha1FromByteData(byte[] data)
        {
            using var sha1 = SHA1.Create();
            var hashBytes = sha1.ComputeHash(data);

            return Sha1BytesToString(hashBytes);
        }

        public static byte[] GetObjectDataBySha1(string sha1)
        {
            var dir = Path.Combine(".gitadr", "objects", sha1.Substring(0, 2));
            var file = sha1.Substring(2);
            var path = Path.Combine(dir, file);

            if (!Directory.Exists(dir) || !File.Exists(path))
            {
                throw new Exception($"Objeto não encontrado: ${sha1} não encontrado.");
            }

            using var fs = File.OpenRead(path);
            using var zlib = new ZLibStream(fs, CompressionMode.Decompress);
            using var outputStream = new MemoryStream();

            zlib.CopyTo(outputStream);
            var data = outputStream.ToArray();

            var nullIndex = Array.IndexOf(data, (byte)0);
            if (nullIndex == -1)
            {
                throw new Exception("Objeto inválido (sem header)");
            }

            return data;
        }

        public static void WriteFileAndDirectoriesFromSha1(string path, string sha1)
        {
            var data = GetObjectDataBySha1(sha1);
            var nullIndex = Array.IndexOf(data, (byte)0);
            var blob = data[(nullIndex + 1)..];

            var dir = Path.GetDirectoryName(path);
            if (!string.IsNullOrEmpty(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllBytes(path, blob);
        }
    }
}

</code></pre>
                        </details>
                        <details>
                            <p>
                                Nessa classe, está presente o método utilitário para a criação do arquivo binário do objeto dentro do diretório <code>.gitadr/objects</code>.
                                Esse método vai ser muito reutilizado em outros comandos.
                            </p>
                            <summary>Código fonte do método de criação de um objeto do git (ObjectStore.cs)</summary>
                            <pre><code>using System.IO.Compression;

namespace Git.Core
{
    public class ObjectStore
    {
        public static void WriteObject(string sha1, byte[] data)
        {
            string dir = Path.Combine(".gitadr", "objects", sha1.Substring(0, 2));
            string file = sha1.Substring(2);

            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            string path = Path.Combine(dir, file);
            using var fs = File.Create(path);
            using var zlib = new ZLibStream(fs, CompressionMode.Compress);
            zlib.Write(data, 0, data.Length);
        }
    }
}</code></pre>
                        </details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Cat-File</h1>

                            <p>
                                O comando <code>cat-file</code> permite ler o conteúdo de um objeto no Git.  
                                Ele recebe como parâmetro o hash SHA-1 do objeto e, a partir dele, localiza o arquivo correspondente dentro de 
                                <code>.gitadr/objects</code>.  
                                Primeiro, utiliza os dois primeiros caracteres do hash para identificar o diretório.  
                                Em seguida, abre o arquivo, realiza a descompactação e exibe o conteúdo do objeto na tela.
                            </p>

                            <p>
                                Se você acompanhou o código do comando <code>hash-object</code>, deve ter notado que o objeto é armazenado 
                                em formato compactado com <strong>zlib</strong>.  
                                Ou seja, o Git não guarda os dados em binário puro: antes de gravar, ele comprime o conteúdo, e ao ler, 
                                precisa descompactá-lo para exibição.
                            </p>

                            <p>
                                Depois de entender como os objeto blob do git funciona, e depois de implementar o hash-object, esse comando se torna extremamente fácil e intuitivo.
                            </p>

                            <details>
                            <summary>Código fonte do comando Cat-File</summary>
                            <p>
                                <i>Este comando utiliza métodos da classe <strong>sha1Utils.cs</strong> (mencionada no comando hash-object)</i>
                            </p>
                            <pre><code>using Git.Core;
using System.Text;

namespace Git.Commands
{
    public class CatFile
    {
        public static string Execute(string[] args)
        {
            if (args.Length < 2 || args[0] != "-p")
            {
                Console.WriteLine("Uso: gitadr cat-file [-p] &lt;hash&gt;");
                return string.Empty;
            }

            var data = Sha1Utils.GetObjectDataBySha1(args[1]);
            var nullIndex = Array.IndexOf(data, (byte)0);
            var content = Encoding.UTF8.GetString(data[(nullIndex + 1)..]);

            Console.WriteLine(content);
            return content;
        }
    }
}</code></pre>
                        </details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Write-Tree</h1>

                            <p>
                                Este comando percorre todos os arquivos e diretórios do projeto (a partir do diretório raiz), 
                                criando <code>blobs</code> para os arquivos e objetos <code>tree</code> para os diretórios.  
                                Em resumo: enquanto os <code>blobs</code> representam os arquivos do projeto, as <code>trees</code> 
                                representam os diretórios em que esses arquivos estão.
                            </p>

                            <p>
                                A estrutura binária de um objeto <code>tree</code> é semelhante à de um <code>blob</code>: 
                                todo objeto do Git possui um cabeçalho e um conteúdo.  
                                A diferença é que o conteúdo de uma <code>tree</code> armazena os hashes de <code>blobs</code> e de outras <code>trees</code>, 
                                formando assim uma verdadeira estrutura em árvore.  
                                Na prática, uma <code>tree</code> funciona como um ponteiro para um <code>blob</code> ou outra <code>tree</code>.
                            </p>

                            <p>
                                Entender a estrutura de árvores é essencial para compreender o funcionamento interno do Git.  
                                Por exemplo: um commit referencia o hash de um objeto <code>tree</code>, e um branch referencia um commit 
                                (falaremos sobre branches mais adiante).  
                                Assim, dominar a lógica de árvores é fundamental para quem deseja compreender como um sistema de versionamento de arquivos funciona.
                            </p>

                            <p>
                                A estrutura binária de um objeto <code>tree</code> é:
                            </p>

                            <pre><code>tree content.length\0contentBytes</code></pre>

                            <p>
                                <strong><code>tree content.length</code></strong>: cabeçalho do objeto.  
                                Composto pela palavra <code>tree</code>, seguida de um espaço e do tamanho total do conteúdo em bytes. <br />

                                <strong><code>\0</code></strong>: caractere nulo que separa o cabeçalho do conteúdo. <br />

                                <strong><code>contentBytes</code></strong>: conteúdo da <code>tree</code>, que armazena referências aos arquivos e subdiretórios.  
                                Exemplo:
                            </p>

                            <pre><code>100644 arquivo_nome.txt\0658e12ad10bfd93dcf0712de258795828f6c4240
100644 arquivo2_nome.txt\0238e12ad10bfd93dcf0712de258795828f634250</code></pre>

                            <p>
                                O objeto completo (cabeçalho + conteúdo) ficaria assim:
                            </p>

                            <pre><code>tree 40405339\0100644 arquivo_nome.txt\0658e12ad10bfd93dcf0712de258795828f6c4240100644 arquivo2_nome.txt\0238e12ad10bfd93dcf0712de258795828f634250</code></pre>

                            <p>
                                <strong><code>100644</code></strong>: esse código antes do nome do arquivo ou diretório é o <code>mode</code> do objeto.  
                                Ele indica o tipo e as permissões de leitura/escrita, seguindo o padrão do Unix file mode.  
                                Neste clone do Git, interpreto apenas dois modos: <code>100644</code> (blob) e <code>040000</code> (tree).  
                                O <code>mode</code> é seguido de um espaço em branco antes do nome do arquivo ou diretório.
                            </p>
                            <details>
                            <summary>Todos os file modes reconhecidos pelo Git</summary>
                                <table class="table">
                                <thead> 
                                    <tr>
                                    <th>Mode</th>
                                    <th>Tipo de objeto</th>
                                    <th>Descrição</th>
                                    <th>Exemplo</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="table-td">
                                    <td >040000</td>
                                    <td>tree</td>
                                    <td>Diretório (contém outras entradas)</td>
                                    <td>src/</td>
                                    </tr>
                                    <tr>
                                    <td>100644</td>
                                    <td>blob</td>
                                    <td>Arquivo normal, não executável</td>
                                    <td>README.md</td>
                                    </tr>
                                    <tr>
                                    <td>100755</td>
                                    <td>blob</td>
                                    <td>Arquivo executável</td>
                                    <td>scripts/build.sh</td>
                                    </tr>
                                    <tr>
                                    <td>120000</td>
                                    <td>blob</td>
                                    <td>Link simbólico (conteúdo do blob = caminho alvo)</td>
                                    <td>link -> ../docs</td>
                                    </tr>
                                    <tr>
                                    <td>160000</td>
                                    <td>commit</td>
                                    <td>Submódulo (ponteiro para um commit de outro repositório)</td>
                                    <td>vendor/libfoo (submodule)</td>
                                    </tr>
                                </tbody>
                                </table>
                            </details>
                            <p>
                                <strong><code>arquivo_nome.txt</code></strong>: Nome do arquivo ou do diretório.
                            </p>
                            <p>
                                <strong><code>\0</code></strong>: Caractere nulo que separa o cabeçalho do conteúdo.
                            </p>
                            <p>
                                <strong><code>658e12ad10bfd93dcf0712de258795828f6c4240100644</code></strong>: Hash sha1 do blob ou tree.
                            </p>
                            <p>
                                A estrutura desses objetos é baseada na forma como os arquivos e diretórios são interpretados pelos sistemas de arquivos do unix como (ext2/ext3). Segue uma comparação visual:
                            </p>
                            <p>
                                Diretório no Unix (ext2/ext4)
                                <pre><code>[tipo/mode] [nome] [ponteiro → inode]

exemplo:

[0100644] [file.txt] [inode=1234]
</code></pre>
                            </p>
                            <p>
                                Tree no Git:
                                <pre><code>[mode] [nome]\0[hash (20 bytes)]

exemplo:

100644 file.txt\0658e12ad10bfd93dcf0712de258795828f6c4240
</code></pre>
                            </p>
                            
                            <details>
                            <summary>Código fonte do comando Write-Tree</summary>
<pre><code>using Git.Core;
using static Git.Core.TreeUtils;

namespace Git.Commands
{
    public class WriteTree
    {
        public static string Execute()
        {
            return WriteTreeRecursive(Directory.GetCurrentDirectory());
        }

        public static string WriteTreeRecursive(string directory)
        {
            var entries = new List&lt;TreeEntry&gt;();

            foreach (var file in Directory.GetFiles(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(file) == ignoreFile))
                {
                    continue;
                }

                var (blobSha1, fullBlob) = BlobUtils.WriteBlob(file);
                ObjectStore.WriteObject(blobSha1, fullBlob);

                entries.Add(new TreeEntry
                {
                    Mode = "100644",
                    Name = Path.GetFileName(file),
                    Sha1 = blobSha1
                });
            }

            foreach (var subdir in Directory.GetDirectories(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(subdir) == ignoreFile))
                {
                    continue;
                }

                var treeSha1 = WriteTreeRecursive(subdir);

                entries.Add(new TreeEntry
                {
                    Mode = "040000",
                    Name = Path.GetFileName(subdir),
                    Sha1 = treeSha1
                });
            }

            if (entries.Count > 0)
            {
                return TreeObject.WriteTree(entries);
            }

            return string.Empty;
        }
    }
}
</code></pre>
                        </details>
                        <details>
                            <summary>Código fonte da classe TreeObject.cs</summary>
<pre><code>using System.Text;
using static Git.Core.TreeUtils;

namespace Git.Core
{
    public class TreeObject
    {
        public static string WriteTree(List&lt;TreeEntry&gt; entries)
        {
            using var treeStream = new MemoryStream();

            foreach (var entry in entries)
            {
                var modeBytes = Encoding.ASCII.GetBytes(entry.Mode + " ");
                var nameBytes = Encoding.UTF8.GetBytes(entry.Name);
                var sha1Bytes = Sha1Utils.Sha1StringToBytes(entry.Sha1);

                treeStream.Write(modeBytes, 0, modeBytes.Length);
                treeStream.Write(nameBytes, 0, nameBytes.Length);
                treeStream.WriteByte(0); // separador \0
                treeStream.Write(sha1Bytes, 0, sha1Bytes.Length);
            }

            var treeContent = treeStream.ToArray();
            var header = $"tree {treeContent.Length}\0";
            var fullTree = Sha1Utils.CombineBytes(Encoding.UTF8.GetBytes(header), treeContent);

            var treeSha1 = Sha1Utils.CreateSha1FromByteData(fullTree);
            ObjectStore.WriteObject(treeSha1, fullTree);

            return treeSha1;
        }
    }
}
</code></pre>
                            </details>
<details>
    <summary>Código fonte da classe TreeUtils.cs</summary>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class TreeUtils
    {
        public class TreeEntry
        {
            public required string Mode { get; set; }
            public required string Name { get; set; }
            public required string Sha1 { get; set; }
        }

        public static List&lt;TreeEntry&gt; GetTreeData(string sha1Param)
        {
            var data = Sha1Utils.GetObjectDataBySha1(sha1Param);

            var nullIndexHeader = Array.IndexOf(data, (byte)0);
            var content = data.Skip(nullIndexHeader + 1).ToArray();

            var entries = new List&lt;TreeEntry&gt;();
            int offset = 0;

            while (offset &lt; content.Length)
            {
                int modeEnd = Array.IndexOf(content, (byte)0x20, offset);
                var mode = Encoding.UTF8.GetString(content, offset, modeEnd - offset);

                int nameEnd = Array.IndexOf(content, (byte)0, modeEnd + 1);
                var name = Encoding.UTF8.GetString(content, modeEnd + 1, nameEnd - (modeEnd + 1));

                var sha1Bytes = content.Skip(nameEnd + 1).Take(20).ToArray();
                var sha1 = Sha1Utils.Sha1BytesToString(sha1Bytes);

                entries.Add(new TreeEntry { Mode = mode, Sha1 = sha1, Name = name });

                offset = nameEnd + 1 + 20;
            }

            return entries;
        }

        public static Dictionary&lt;string, (string Mode, string Sha1)&gt; GetTreeEntriesFromSha1(string prefix, string treeSha1, Dictionary&lt;string, (string Mode, string Sha1)&gt; dict)
        {
            var entries = GetTreeData(treeSha1);

            foreach (var entry in entries)
            {
                var fullPath = TreeUtils.CombinePrefix(prefix, entry.Name);

                if (entry.Mode == "040000")
                {
                    GetTreeEntriesFromSha1(fullPath, entry.Sha1, dict);
                }
                else
                {
                    dict[fullPath] = (entry.Mode, entry.Sha1);
                }
            }

            return dict;
        }

        public static string CombinePrefix(string prefix, string name)
        {
            return string.IsNullOrEmpty(prefix) ? name : Path.Combine(prefix, name);
        }
    }
}

</code></pre>
</details>
                            <p>
                                Com o comando <code>write-tree</code>, a estrutura de dados principal do Git é criada.  
                                A seguir, podemos ver um exemplo de como as <code>trees</code> e <code>blobs</code> se referenciam entre si (resultado do comando write-tree):
                            </p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/gitadr/data-model-1.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                
                            </div>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Ls-Tree</h1>

                            <p>
                                Este é o comando que exibe o conteúdo de uma tree. No git oficial também é possivel utilizar o <code>cat-file</code> para exibir o conteúdo de uma tree, mas para fins didático
                                optei por separar:  <br>
                                <code>cat-file</code>: Exibir conteúdo de um blob. <br>
                                <code>ls-tree</code>: Exibir conteúdo de uma tree.
                            </p>
                            <p>
                                Este comando vai exibir exatamente as informações contidas no conteúdo do objeto <code>tree</code> que detalhei na descrição do comando <code>write-tree</code>
                            </p>
                            <p>
                                O conteúdo da tree será exibido dessa forma no console:
                            </p>
                            <pre><code>[mode] [type] [sha1] [name]</code></pre>                        
<details>
    <summary>Código fonte do comando Ls-Tree</summary>
    <p>
        <i>Este comando utiliza métodos da classe <strong>treeUtils.cs</strong> (mencionada no comando write-tree)</i>
    </p>
    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class LsTree
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 2 || args[0] != "-p")
            {
                Console.WriteLine("Uso: gitadr ls-tree [-p] &lt;hash&gt;");
                return string.Empty;
            }

            var entries = TreeUtils.GetTreeData(args[1]);

            var result = string.Empty;

            foreach (var entry in entries)
            {
                var type = entry.Mode == "040000" ? "tree" : "blob";
                var lineData = $"{entry.Mode} {type} {entry.Sha1} {entry.Name}";

                Console.WriteLine(lineData);
                result += lineData + "\n";
            }

            return result;
        }
    }
}
</code></pre>
</details>                            
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Add</h1>
                            
                            <p>
                                Este é o primeiro comando <a href="https://wyag.thb.lt" target="_blank" class="blog-link">porcelain</a> 
                                que os usuários normalmente utilizam no dia a dia.  
                                No Git oficial, o <code>add</code> utiliza internamente um comando <a href="https://wyag.thb.lt" target="_blank" class="blog-link">plumbing</a> chamado <code>update-index</code>.
                            </p>

                            <p>
                                No meu clone, optei por criar diretamente o comando <code>add</code>.  
                                Assim, <code>gitadr add</code> equivale a <code>git hash-object</code> + <code>git update-index</code> no Git oficial.
                            </p>

                            <p>
                                Ao entender o funcionamento do meu comando <code>add</code> e analisar o código, você automaticamente compreenderá 
                                como funciona o <code>update-index</code>.  
                                Caso queira implementar o <code>update-index</code> separadamente, fique à vontade: ele apenas adiciona ou atualiza o hash SHA-1 no arquivo <code>index</code>, o que é relativamente simples.
                            </p>

                            <p>
                                O comando <code>add</code> realiza basicamente duas operações: cria os objetos e atualiza o arquivo <code>index</code>.  
                                Esse arquivo é gerado na primeira execução do <code>add</code> e fica armazenado em <i>./gitadr/index</i>.  
                                Também conhecido como <i>staging area</i>, o <code>index</code> funciona como uma ponte entre o workspace e o commit, permitindo que o Git saiba exatamente quais alterações serão incluídas no próximo commit.
                            </p>

                            <p>
                                No Git oficial, o arquivo <code>index</code> é binário e contém diversas informações sobre arquivos e diretórios 
                                (caminho, hash SHA-1, mode, flags internas etc.).  
                                No <code>gitadr</code>, simplifiquei o índice: ele é um arquivo de texto que armazena apenas duas informações por arquivo: <i>SHA-1</i> e <i>caminho</i>.  
                                Isso é suficiente para criar uma <i>staging area</i> eficiente, capaz de controlar quais arquivos alterados serão incluídos no próximo commit.
                            </p>
                            
                            <p>
                                A estrutura do conteúdo do arquivo index é assim: <i>sha1 + espaço em branco + caminho do arquivo + quebra de linha</i>.
                                Segue abaixo um exemplo:
                            </p>
                            <pre><code>4a481a3aa65ec275d2fd0f751e995e2450fbc6c4 src/fileA.txt
0c991fcb4fe1739224d4a0df2973df2de4eef4ad src/lib/fileB.txt</code></pre>

<details>
    <summary>Código fonte do comando Add</summary>
    <p>
        Perceba que é possivel adicionar a worskpace inteira na staging area com o comando <code>gitadr add .</code> ou todos os arquivos de um determinado diretório, com <code>gitadr add [diretório]</code>
    </p>
    <pre><code>using Git.Core;

namespace Git.Commands
{
    public class Add
    {
        public static void Execute(string[] args)
        {
            if (args.Length &lt; 1)
            {
                Console.WriteLine("Uso: gitadr add &lt;arquivo | diretório | .&gt;");
                return;
            }

            var target = args[0];

            if (target == ".")
            {
                AddAll();
                return;
            }

            if (Directory.Exists(target))
            {
                ExecuteRecursive(Path.GetFullPath(target));
                StageDeletionsUnderPath(Path.GetFullPath(target));
                return;
            }

            var rel = Path.GetRelativePath(Directory.GetCurrentDirectory(), target);
            AddOrUpdateIndexFile(rel);
        }

        public static void AddAll()
        {
            var workspaceFiles = IndexUtils.RecursiveReadWorkSapce(Directory.GetCurrentDirectory(), new Dictionary&lt;string, string&gt;());
            var indexFiles = IndexUtils.GetIndexEntries(true);

            foreach (var file in workspaceFiles.Keys)
            {
                AddOrUpdateIndexFile(file);
            }

            foreach (var file in indexFiles.Keys.ToList())
            {
                if (!workspaceFiles.ContainsKey(file))
                {
                    indexFiles.Remove(file);
                    IndexUtils.CreateOrUpdateIndex(string.Join('\n', indexFiles.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
                }
            }
        }

        public static void ExecuteRecursive(string directory)
        {
            foreach (var file in Directory.GetFiles(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(file) == ignoreFile))
                    continue;

                AddOrUpdateIndexFile(Path.GetRelativePath(Directory.GetCurrentDirectory(), file));
            }

            foreach (var subdir in Directory.GetDirectories(directory))
            {
                if (IndexUtils.ignoreFiles.Any(ignoreFile => Path.GetFileName(subdir) == ignoreFile))
                    continue;

                ExecuteRecursive(subdir);
            }
        }

        private static void StageDeletionsUnderPath(string basePath)
        {
            var root = Directory.GetCurrentDirectory();
            var relBase = Path.GetRelativePath(root, basePath);
            if (relBase == "." || string.IsNullOrEmpty(relBase))
            {
                relBase = string.Empty;
            }

            var index = IndexUtils.GetIndexEntries(true);
            var newContentLines = new List&lt;string&gt;();

            foreach (var kv in index)
            {
                var file = kv.Key;
                var sha1 = kv.Value;

                bool underBase =
                    string.IsNullOrEmpty(relBase) ||
                    file == relBase ||
                    file.StartsWith(relBase + Path.DirectorySeparatorChar);

                if (underBase)
                {
                    var fullPath = Path.Combine(root, file);
                    if (!File.Exists(fullPath))
                    {
                        continue;
                    }
                }

                newContentLines.Add($"{sha1} {file}");
            }

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', newContentLines) + "\n");
        }

        public static void AddOrUpdateIndexFile(string file, string? sha1Param = null)
        {
            var index = IndexUtils.GetIndexEntries(true);

            if (!File.Exists(file))
            {
                if (index.ContainsKey(file))
                {
                    index.Remove(file);
                    IndexUtils.CreateOrUpdateIndex(string.Join('\n', index.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
                }
                return;
            }

            var sha1 = sha1Param ?? HashObject.Execute(new string[] { "-w", file });
            index[file] = sha1;

            IndexUtils.CreateOrUpdateIndex(string.Join('\n', index.Select(kv => $"{kv.Value} {kv.Key}")) + "\n");
        }
    }
}
</code></pre>
</details>           
<details>
    <summary>Código fonte da classe indexUtils.cs</summary>
    <pre><code>namespace Git.Core
{
    public class IndexUtils
    {
        public static readonly string[] ignoreFiles = { ".gitadr" };
        public static Dictionary&lt;string, string&gt; GetIndexEntries(bool createIndexFile = false)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var pathIndex = Path.Combine(gitDir, "index");

            if (!File.Exists(pathIndex))
            {
                if (createIndexFile)
                {
                    File.WriteAllText(pathIndex, string.Empty);
                }

                return new Dictionary&lt;string, string&gt;();
            }

            var content = File.ReadAllText(pathIndex);

            if (string.IsNullOrWhiteSpace(content))
            {
                if (createIndexFile)
                {
                    File.WriteAllText(pathIndex, content);
                }

                return new Dictionary&lt;string, string&gt;();
            }

            var entries = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);

            var indexMap = new Dictionary&lt;string, string&gt;();

            foreach (var line in entries)
            {
                var parts = line.Split(' ', 2);

                var sha1 = parts[0];
                var path = parts[1];

                var relPath = Path.GetRelativePath(Directory.GetCurrentDirectory(), path);

                relPath = relPath.Replace('/', Path.DirectorySeparatorChar);

                indexMap[relPath] = sha1;
            }

            return indexMap;
        }

        public static void CreateOrUpdateIndex(string contenet)
        {
            var gitDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var path = Path.Combine(gitDir, "index");

            File.WriteAllText(path, contenet);
        }

        public static List&lt;string&gt; RecursiveUpdateIndexFromTree(string prefix, string treeSha1, List&lt;string&gt; indexLines)
        {
            var treeEntries = TreeUtils.GetTreeData(treeSha1);

            foreach (var entry in treeEntries)
            {
                var fullPath = TreeUtils.CombinePrefix(prefix, entry.Name);

                if (entry.Mode == "040000")
                {
                    RecursiveUpdateIndexFromTree(fullPath, entry.Sha1, indexLines);
                }
                else
                {
                    indexLines.Add($"{entry.Sha1} {fullPath}");
                }
            }

            CreateOrUpdateIndex(string.Join('\n', indexLines) + "\n");

            return indexLines;
        }

        public static Dictionary&lt;string, string&gt; RecursiveReadWorkSapce(string dir, Dictionary&lt;string, string&gt; dict)
        {
            foreach (var entry in Directory.GetFiles(dir))
            {
                if (ignoreFiles.Any(ignoreFile => Path.GetFileName(entry) == ignoreFile))
                {
                    continue;
                }

                var fullPath = Path.GetRelativePath(Directory.GetCurrentDirectory(), entry);
                dict[fullPath] = BlobUtils.GetSha1FromBlob(entry);
            }

            foreach (var entry in Directory.GetDirectories(dir))
            {
                if (ignoreFiles.Any(ignoreDir => Path.GetFileName(entry) == ignoreDir))
                {
                    continue;
                }

                RecursiveReadWorkSapce(entry, dict);
            }

            return dict;
        }

        public static string NormalizePath(string path)
        {
            var fullPath = Path.GetFullPath(path);
            var repoRoot = Directory.GetParent(Path.Combine(Directory.GetCurrentDirectory(), ".gitadr"))!.FullName;
            var relativePath = Path.GetRelativePath(repoRoot, fullPath);

            return relativePath.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar).TrimEnd(Path.DirectorySeparatorChar);
        }

        public static void RemoveEmptyDirectories(string root)
        {
            var allDirs = Directory.GetDirectories(root, "*", SearchOption.AllDirectories)
                                   .OrderByDescending(d => d.Length);

            var gitDir = Path.GetFullPath(Path.Combine(root, ".gitadr"));

            foreach (var dir in allDirs)
            {
                var full = Path.GetFullPath(dir);
                if (full.Equals(gitDir, StringComparison.OrdinalIgnoreCase) || full.StartsWith(gitDir + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (!Directory.EnumerateFileSystemEntries(full).Any())
                {
                    Directory.Delete(full, recursive: false);
                }
            }
        }
    }
}
</code></pre>
</details>
                        </div>
                        <div class="blog-text">
                            <h1 class="h4 portfolio-title">Commit</h1>

                            <p>
                                Este é o comando clássico do Git — provavelmente o mais conhecido de todos.  
                                Em essência, ele realiza duas operações principais: <code>write-tree</code> e a criação de um novo objeto <code>commit</code>.  
                                Primeiro, o comando lê os arquivos presentes no <i>index</i> e monta uma árvore completa desses arquivos e diretórios através do <code>write-tree</code>.  
                                Em seguida, é criado o objeto <code>commit</code>, que armazena o hash SHA-1 da árvore raiz gerada e o hash do commit anterior (<i>parent commit</i>), caso exista.
                            </p>

                            <p>
                                Em resumo, um objeto <code>commit</code> é essencialmente um ponteiro para uma árvore (<code>tree</code>) acompanhado de metadados.  
                                Além dos hashes da árvore e do commit anterior, ele também contém informações como autor, e-mail, data e hora, além da mensagem do commit.
                            </p>

                            <p>
                                Particularmente, não gosto da explicação popular que diz: <i>"um commit é um ponto na linha do tempo"</i>.  
                                Embora isso possa ajudar iniciantes que não entendem nada de git a formar uma ideia vaga, essa definição não reflete o que o Commit realmente faz — e pode até dar a impressão de que o Git é uma ferramenta mágica que "controla" o tempo.  
                                Prefiro uma explicação mais precisa: <i>"um commit representa um estado do seu projeto"</i>.  
                                Isso traduz melhor a realidade: cada commit é um ponteiro para uma árvore que descreve todos os arquivos do repositório naquele momento.  
                                Assim, cada commit captura um estado completo do projeto.
                            </p>

                            <p>
                                Abaixo está a estrutura de um objeto <code>commit</code>:
                            </p>
                            <pre><code>commit [tamanho]\0
tree [sha1 da tree raiz]
parent [sha1 do commit pai]     # (opcional — só existe se não for o primeiro commit)
author [nome] [email] [timestamp] [timezone]
committer [nome] [email] [timestamp] [timezone]

[mensagem do commit]

exemplo:

commit 187\0
tree 9a1fc4d8e1dba7a4d1246b26d4a2c716b8bfc1f1
parent 5c2f8a91a9a24f21df739eac78a9c53ebc71e63c
author Linus Torvalds [torvalds@linux-foundation.org] [1618590723] [-0700]
committer Linus Torvalds [torvalds@linux-foundation.org] [1618590723] [-0700]

[Fix race condition in file locking]
</code></pre>
<details>
    <summary>Código fonte do comando Commit</summary>
    <pre><code>using Git.Core;
using static Git.Core.TreeUtils;

namespace Git.Commands
{
    public class Commit
    {
        public static string Execute(string[] args)
        {
            if (args.Length &lt; 2 || args[0] != "-m")
            {
                Console.WriteLine("Uso: gitadr commit [-m] &lt;mensagem_do_commit&gt;");
                return string.Empty;
            }

            var indexEntries = IndexUtils.GetIndexEntries(false);

            if (indexEntries == null || indexEntries.Keys.Count == 0)
            {
                Console.WriteLine("Nenhum arquivo na staging area.");
                return string.Empty;
            }

            var parentCommit = CommitUtils.GetLastCommitSha1FromHead();

            if (!string.IsNullOrEmpty(parentCommit))
            {
                var headTreeSha1 = CommitUtils.GetCommitTreeSha1(parentCommit);
                var headEntries = TreeUtils.GetTreeEntriesFromSha1("", headTreeSha1, new Dictionary&lt;string, (string Mode, string Sha1)&gt;());

                var hasChanges = false;

                if (indexEntries.Count != headEntries.Count)
                {
                    hasChanges = true;
                }
                else
                {
                    foreach (var kv in indexEntries)
                    {
                        if (!headEntries.TryGetValue(kv.Key, out var head) || head.Sha1 != kv.Value)
                        {
                            hasChanges = true;
                            break;
                        }
                    }
                }

                if (!hasChanges)
                {
                    Console.WriteLine("working tree limpa.");
                    return string.Empty;
                }
            }
                    
            var rootSha1 = BuildCommitTree(indexEntries, parentCommit);

            var commitSha1 = CommitObject.WriteCommit(rootSha1, args[1]);

            UpdateHead(commitSha1);

            return commitSha1;
        }

        private static string BuildCommitTree(Dictionary&lt;string, string&gt; indexMap, string? parentCommit)
        {
            var baseFiles = new Dictionary&lt;string, (string Mode, string Sha1)&gt;();

            if (!string.IsNullOrEmpty(parentCommit))
            {
                var parentTreeSha1 = CommitUtils.GetCommitTreeSha1(parentCommit);
                TreeUtils.GetTreeEntriesFromSha1("", parentTreeSha1, baseFiles);
            }

            var newFiles = baseFiles.Keys.Union(indexMap.Keys);

            foreach (var file in newFiles)
            {
                var stagedFileSha1 = indexMap.ContainsKey(file) ? indexMap[file] : null;
                var baseFileSha1 = baseFiles.ContainsKey(file) ? baseFiles[file].Sha1 : null;

                if (stagedFileSha1 == null && baseFileSha1 != null)
                {
                    baseFiles.Remove(file);
                    continue;
                }

                baseFiles[file] = ("100644", stagedFileSha1!);
            }

            string WriteDir(string prefix)
            {
                var childNames = baseFiles.Keys
                    .Where(p => IsUnderPrefix(p, prefix))
                    .Select(p =>
                    {
                        var remainder = GetRemainder(p, prefix);
                        return remainder.Split(Path.DirectorySeparatorChar)[0];
                    })
                    .Distinct()
                    .OrderBy(n => n)
                    .ToList();

                var entries = new List&lt;TreeEntry&gt;();

                foreach (var name in childNames)
                {
                    var fullPath = TreeUtils.CombinePrefix(prefix, name);

                    if (baseFiles.TryGetValue(fullPath, out var fileInfo))
                    {
                        entries.Add(new TreeEntry
                        {
                            Mode = fileInfo.Mode,
                            Name = name,
                            Sha1 = fileInfo.Sha1
                        });
                    }
                    else
                    {
                        var subTreeSha1 = WriteDir(fullPath);
                        entries.Add(new TreeEntry
                        {
                            Mode = "040000",
                            Name = name,
                            Sha1 = subTreeSha1
                        });
                    }
                }

                return TreeObject.WriteTree(entries);
            }

            return WriteDir("");
        }

        private static bool IsUnderPrefix(string path, string prefix)
        {
            if (string.IsNullOrEmpty(prefix))
            {
                return true;
            }

            if (path.Length &lt; prefix.Length)
            {
                return false;
            }

            if (!path.StartsWith(prefix)) 
            { 
                return false; 
            }

            if (path.Length == prefix.Length) 
            { 
                return false; 
            }

            return path[prefix.Length] == Path.DirectorySeparatorChar;
        }

        private static string GetRemainder(string path, string prefix)
        {
            if (string.IsNullOrEmpty(prefix))
            {
                return path;
            }

            return path.Substring(prefix.Length + 1);
        }

        private static void UpdateHead(string commitSha1)
        {
            var refs = BranchUtils.GetHead();
            var parts = refs.Split(" ", 2);
            BranchUtils.CreateOrUpdateBranch(parts[1], commitSha1);
        }
    }
}
</code></pre>
</details>
<details>
    <summary>Código fonte da classe commitUtils.cs</summary>
    <p>
        Classe que possui os método utilitários para manipulação de commits.
    </p>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class CommitUtils
    {
        public static string GetTimestamp() => DateTimeOffset.Now.ToUnixTimeSeconds().ToString();
        public static string GetTimezone() => DateTimeOffset.Now.ToString("zzz").Replace(":", "");

        public static string GetLastCommitSha1FromHead()
        {
            var gitAdrDir = Path.Combine(Directory.GetCurrentDirectory(), ".gitadr");
            var refs = BranchUtils.GetHead();
            var parts = refs.Split(" ", 2);

            return File.ReadAllText(Path.Combine(gitAdrDir, parts[1]));
        }

        public static string GetCommitTreeSha1(string commitSha1)
        {
            var data = Sha1Utils.GetObjectDataBySha1(commitSha1);
            var nullIdx = Array.IndexOf(data, (byte)0);
            var content = data[(nullIdx + 1)..];

            var text = Encoding.UTF8.GetString(content);
            var lineTree = text.Split('\n').First(l => l.StartsWith("tree "));
                
            var parts = lineTree.Split(' ', 2);

            return parts[1];
        }

        public static List&lt;string&gt; GetCommitParents(string commitSha1)
        {
            var data = Sha1Utils.GetObjectDataBySha1(commitSha1);
            var nullIdx = Array.IndexOf(data, (byte)0);
            var content = data[(nullIdx + 1)..];

            var text = Encoding.UTF8.GetString(content);
            var parents = text.Split('\n').Where(l => l.StartsWith("parent "));

            var commits = new List&lt;string&gt;();

            foreach (var parent in parents)
            {
                commits.Add(parent.Split(" ", 2)[1]);
            }

            return commits;
        }
    }
}
</code></pre>
</details>
<details>
    <summary>Código fonte da classe commitObject.cs</summary>

    <p>
        Classe que possui o método de criação do arquivo binário do objeto commit.
    </p>
    <p>
        Perceba que eu coloquei author e comitter com informações hardcoded. 
        É possivel tornar essas infos dinamicas, para isso será necessário criar comandos de configuração que armazanem informações em um arquivo de config, para saber mais leia sobre as <a href="https://git-scm.com/docs/git-config" target="_blank" class="blog-link">configurações de usuário do git</a>.
    </p>
    <p>
        Comandos de configs não abordam nenhum conceito estrutural do git, então, fica a teu critério essa implementação.
    </p>
    <pre><code>using System.Text;

namespace Git.Core
{
    public class CommitObject
    {
        public static string WriteCommit(string rootSha1, string msg, string[]? sha1Parents = null)
        {
            using var commitStream = new MemoryStream();

            var tree = Encoding.UTF8.GetBytes($"tree {rootSha1}\n");

            var parents = new List<byte[]>();

            if (sha1Parents != null) 
            {
                foreach (var sha1 in sha1Parents)
                {
                    parents.Add(Encoding.UTF8.GetBytes($"parent {sha1}\n"));
                }
            }
            else
            {
                var parentSah1 = CommitUtils.GetLastCommitSha1FromHead();
               
                if (!string.IsNullOrWhiteSpace(parentSah1))
                {
                    parents.Add(Encoding.UTF8.GetBytes($"parent {parentSah1}\n"));
                }
            }

            var author = Encoding.UTF8.GetBytes($"author Guest <author@gmail.com> {CommitUtils.GetTimestamp()} {CommitUtils.GetTimezone()}\n");
            var committer = Encoding.UTF8.GetBytes($"committer Guest <commiter@email.com> {CommitUtils.GetTimestamp()} {CommitUtils.GetTimezone()}\n");
            var message = Encoding.UTF8.GetBytes($"{msg}\n");

            commitStream.Write(tree, 0, tree.Length);

            foreach(var parent in parents)
            {
                commitStream.Write(parent, 0, parent.Length);
            }  

            commitStream.Write(author, 0, author.Length);
            commitStream.Write(committer, 0, committer.Length);
            commitStream.WriteByte(0x0A);
            commitStream.Write(message, 0, message.Length);

            var commitContent = commitStream.ToArray();
            var header = $"commit {commitContent.Length}\0";

            var fullCommit = Sha1Utils.CombineBytes(Encoding.UTF8.GetBytes(header), commitContent);
            var commitSha1 = Sha1Utils.CreateSha1FromByteData(fullCommit);

            ObjectStore.WriteObject(commitSha1, fullCommit);

            return commitSha1;
        }
    }
}
</code></pre>
</details>
                        </div>
                    </section>
                    <!-- <section class="portfolio-description">
                        <h1 class="h4 portfolio-title">Referencias</h1>
                        <h6>CVS:</h6>
                        <p>https://www.projecthut.com/cvs-version-control-system-explained/?utm_source=chatgpt.com</p>
                        <p>
                            https://web.mit.edu/macdev/Development/Documentation/www/CVS%20Documentation/Understanding%20CVS.html?utm_source=chatgpt.com
                        </p>
                        <p>https://tartarus.org/~simon/cvs-vs-svn.html</p>
                    </section> -->
                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
    </body>
</html>
