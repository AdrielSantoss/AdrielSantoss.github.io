'<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Git</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Criando o meu próprio git</h1>
                    </section>
                    <br />

                    <section>
                        <div class="tags">
                            <small class="tag">Git</small>
                            <small class="tag">C#</small>
                            <small class="tag">Estrutura de dados</small>
                            <small class="tag">.NET</small>
                            <small class="tag">CVS</small>
                            <small class="tag">SVN</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div class="about-text">
                            <p>
                                Há algum tempo, me deparei com o artigo "Write Yourself a Git" Ao lê-lo, despertou em
                                mim um desejo que se somou a uma vontade antiga que eu já possuía: implementar uma
                                versão simplificada do Git, com o objetivo de exercitar, de maneira prática, tudo aquilo
                                que eu já havia estudado em "Git Internals".
                            </p>
                            <p>
                                No dia em que escrevo este artigo, o Git já completou 20 anos de existência, e acredito
                                que, há mais de 15 anos, vem se tornando uma ferramenta <strong>obrigatória</strong> no
                                dia a dia de qualquer pessoa que se diz programadora. Entender como essa ferramenta
                                funciona é tão importante quanto compreender algoritmos e estruturas de dados.
                            </p>
                            <p>
                                Obviamente, <strong>entender</strong> como algo funciona não é a mesma coisa que saber
                                <strong>usar</strong>. Qualquer pessoa aprende, em uma tarde, os comandos básicos, e em
                                uma semana já consegue incorporar o Git por completo em seu fluxo de trabalho. No
                                entanto, poucos realmente sabem o que está acontecendo com seus arquivos, e muito menos
                                compreendem o motivo de estarem usando o Git.
                            </p>
                            <p>
                                Obtive uma experiencia muito interessante, que durou aproximadamente 3 semanas, eu
                                implementei 14 comandos do git (talvez, com o passar do tempo, implemente ainda mais), e
                                cada comando constrói e manipula os tres princiapis objetos do git: Blob, Tree e Commit.
                                Dito isso, o meu objetivo nesse artigo, é descrever como foi essa experiencia, o que eu
                                aprendi nesse periodo.
                            </p>
                        </div>
                        <div class="about-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>
                            <p>
                                Prometo não me alongar muito, portanto, tente não dormir… Se você quer realmente
                                entender o Git, conhecer um pouco do passado nebuloso do período pré-Git é extremamente
                                importante. Somente assim você vai compreender o real motivo de estar usando o Git hoje.
                            </p>
                            <p>
                                Antes do Git, os sistemas de controle de versão mais utilizados eram: SVN, BitKeeper e
                                CVS. Pesquisando mais a fundo, encontramos nomes como Visual SourceSafe, Mercurial,
                                Bazaar, e, ainda mais antigos, SCCS e RCS. Todos, sem exceção, apresentavam soluções
                                complexas e problemáticas demais para lidar com um problema ainda mais desafiador:
                                gerenciar versões de arquivos.
                            </p>
                            <p>
                                Cada uma dessas ferramentas surgiu com o objetivo de corrigir problemas de seus
                                concorrentes, mas, ao fazer isso, gerava ou ignorava outros problemas. Um exemplo
                                clássico é a "evolução" entre o SVN (Subversion) e o CVS (Concurrent Versions System),
                                ambos gratuitos e de código aberto.
                            </p>
                            <p>
                                Em resumo, CVS e SVN apresentavam um sistema centralizado, ou seja, tudo era gerenciado
                                e monitorado por um servidor central. Por exemplo, para fazer commits (o famoso
                                "comitar"), era necessário solicitar permissão ao servidor.
                            </p>
                            <p>
                                O CVS era considerado o “inferno na terra” quando se tratava de sistemas de
                                versionamento. Alguns dos seus principais problemas/limitações eram: apenas arquivos
                                eram versionados, diretórios não; arquivos se perdiam no histórico quando eram movidos
                                ou renomeados; e commits não eram operações atômicas — portanto, se um commit falhasse
                                no meio, havia o risco de corromper todo o repositório.
                            </p>
                            <p>
                                Quando surgiu, o SVN corrigiu todos esses problemas, mas isso não o tornou
                                necessariamente “melhor”. O SVN ainda possuía várias limitações, e um de seus principais
                                problemas não estava na parte técnica, mas sim no marketing, que utilizava o slogan:
                                “SVN is CVS done right”.
                            </p>
                            <p>
                                Uma das críticas mais notórias ao SVN e à sua campanha de marketing veio de ninguém
                                menos que Linus Torvalds, durante sua famosa palestra sobre o Git no Google:
                                https://www.youtube.com/watch?v=idLyobOhtO4m. Recomendo fortemente assistir a essa
                                palestra para compreender as complicações que esses sistemas geravam no dia a dia dos
                                programadores no fim dos anos 90 e início dos anos 2000.
                            </p>
                            <p>
                                Em resumo, os principais problemas do SVN eram: merges frágeis, com risco de conflitos
                                complexos (two-way merge); criação de branches ainda era uma tarefa cara (apesar do
                                marketing afirmar o contrário); dificuldade em comparar branches complexos; problemas de
                                desempenho em projetos grandes; entre outros.
                            </p>
                            <p>
                                O branching no SVN foi uma melhoria em relação ao CVS, mas ainda apresentava limitações
                                que o tornavam caro em termos práticos. Criar um branch no CVS/SVN era equivalente a
                                <strong>duplicar</strong> o diretório principal. Agora imagine fazer isso com frequência
                                em projetos gigantes como o kernel do Linux... Mesclar dois branches no SVN era uma
                                operação <strong>custosa</strong> e, principalmente, <strong>ineficiente</strong>,
                                devido ao fraco algoritmo de merge, chamado <strong>two-way merge</strong>. Na prática,
                                realizar um merge significava comparar TUDO de um branch contra TUDO do branch trunk
                                (branch principal do SVN, equivalente ao master/main do Git). Esse processo fazia com
                                que conflitos surgissem com extrema facilidade. Já o CVS aplicava o
                                <b>three-way merge</b>, de forma limitada, pois não rastreava bem histórico de merges
                                anteriores. (Nesse aspecto, podemos concluir que SVN não era um CVS feito direito...)
                            </p>
                            <p>
                                Devido a todos os problemas do CVS e do SVN, Linus Torvalds optou por utilizar o
                                BitKeeper no desenvolvimento do kernel no início dos anos 2000. Os principais motivos
                                dessa escolha eram que o BitKeeper era um sistema distribuído, lidava melhor com grandes
                                bases de código (um ponto crítico em que CVS e SVN falhavam) e oferecia um mecanismo de
                                merge relativamente eficiente.
                            </p>
                            <p>
                                A BitMover, empresa responsável pelo BitKeeper, ofereceu licenças gratuitas para uso no
                                kernel Linux, desde que não fossem utilizadas para desenvolver ferramentas concorrentes.
                                Apesar da contradição ideológica de depender de um software proprietário para criar um
                                software livre, tudo corria bem até que, em 2005, o acesso gratuito ao BitKeeper foi
                                revogado.
                            </p>
                            <p>
                                Esse foi o ponto decisivo que levou diretamente ao nascimento do Git. A BitMover começou
                                a desconfiar que a comunidade do Linux estava realizando engenharia reversa do protocolo
                                de rede do BitKeeper. De certa forma, isso era verdade: muitos desenvolvedores não
                                aceitavam a ideia de depender de um software fechado para um projeto como o kernel, e
                                alguns começaram a criar alternativas capazes de ler e interagir com repositórios do
                                BitKeeper. A mais conhecida delas foi o <em>SourcePuller</em>.
                            </p>
                            <p>
                                Após a revogação das licenças gratuitas do BitKeeper, Linus Torvalds decidiu resolver
                                esse problema de forma definitiva. Ele queria um sistema de controle de versão que
                                atendesse aos seguintes requisitos: ser distribuído, eficiente, rápido, resistente à
                                corrupção de dados e 100% software livre.
                            </p>
                            <p>
                                As opções disponíveis na época eram: Mercurial, Bazaar, Darcs e Monotone. Todas, no
                                entanto, apresentavam problemas de desempenho em projetos grandes como o kernel. Com
                                essas alternativas descartadas, restou apenas uma saída: criar um novo sistema de
                                versionamento. Assim nasceu o Git, que se tornaria o sistema de controle de versão mais
                                utilizado da história.
                            </p>
                        </div>
                    </section>
                    <section class="portfolio-description">
                        <h1 class="h4 portfolio-title">Referencias</h1>
                        <h6>CVS:</h6>
                        <p>https://www.projecthut.com/cvs-version-control-system-explained/?utm_source=chatgpt.com</p>
                        <p>
                            https://web.mit.edu/macdev/Development/Documentation/www/CVS%20Documentation/Understanding%20CVS.html?utm_source=chatgpt.com
                        </p>
                        <p>https://tartarus.org/~simon/cvs-vs-svn.html</p>
                    </section>
                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
    </body>
</html>
