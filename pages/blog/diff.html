<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Entendendo algoritmos de diff</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Entendendo algoritmos de diff</h1>
                        <div>
                            <small style="color: white">17/10/2025</small> -
                            <a
                                href="https://github.com/AdrielSantoss/Myers-Patience-Diff"
                                target="_blank"
                                class="blog-link"
                                >Projeto (Github)</a
                            >
                        </div>
                        <div class="tags">
                            <small class="tag">Algoritmo</small>
                            <small class="tag">Programação dinâmica</small>
                            <small class="tag">Rust</small>
                            <small class="tag">Diff</small>
                            <small class="tag">Compressão</small>
                            <small class="tag">Git</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div id="intro" class="about-text">
                            <p>
                                Neste artigo, vou falar sobre algoritmos de diff e, de quebra, um pouco sobre
                                compressão. Desenvolvi um sistema em Rust que implementa dois algoritmos de diff:
                                <strong>Myers</strong> e <strong>Patience</strong>.
                            </p>
                            <p>
                                O projeto nasceu com o objetivo de integrá-lo ao GitAdr. Escolhi Rust por preferência
                                pessoal, mas você pode implementar esses algoritmos em qualquer linguagem que desejar.
                            </p>
                            <p>
                                Além da integração com o GitAdr, um dos motivos da criar esse projeto, é que no
                                trabalho, atualmente eu utilizo Windows 11, e por padrão, o Windowes não possui nenhuma
                                ferramenta de diff decente, todas são simples de força bruta de comparação linha a
                                linha, nenhuma baseada no algoritmo do Myers.
                            </p>
                            <p>
                                E, claro, um dos principais motivos para criar este projeto foi a oportunidade de
                                aprender mais sobre algoritmos de diff de texto.
                            </p>
                        </div>
                        <div id="intro" class="about-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>

                            <p>
                                O primeiro algoritmo de diff eficiente foi implementado em <strong>1976</strong> para o
                                sistema operacional Unix por <strong>Douglas McIlroy</strong> e
                                <strong>James Hunt</strong> na Bell Labs — assim que surgiu a ferramenta diff que existe
                                em todo Linux atualmente.
                            </p>
                            <p>
                                Essa ferramenta de diff realiza comparação por <strong>linha</strong> e utiliza o
                                algoritmo
                                <a
                                    href="https://en.wikipedia.org/wiki/Longest_common_subsequence"
                                    target="_blank"
                                    class="blog-link"
                                    >Longest common subsequence (LCS)</a
                                >, esse algoritmo possui complexidade: <strong>O(n × m)</strong> de tempo e memória.
                                Sendo <strong>n</strong> o tamanho (número de linhas) do primeiro arquivo e
                                <strong>m</strong> o tamanho do segundo arquivo.
                            </p>
                            <p>
                                Após o surgimento e popularização do diff baseado em LCS, surgiu o comando
                                <code>patch</code> criado por Larry Wall (o mesmo criador do Perl). Esse comando
                                permitia aplicar um arquivo .diff (também chamado .patch) para reconstruir a nova versão
                                de um arquivo.
                            </p>
                            <p>Isso criou o ciclo clássico:</p>
                            <pre><code>diff old new > changes.patch 
patch old < changes.patch</code></pre>
                            <p>
                                Esse mecanismo se tornou fundamental para o desenvolvimento colaborativo de software
                                livre (BSD, GNU, etc.).
                            </p>
                            <p>
                                É importante destacar que o algoritmo de LCS utiliza
                                <strong>programação dinâmica</strong> para resolver o problema. Programação dinâmica é
                                uma técnica para resolver problemas complexos dividindo-os em subproblemas menores e
                                reaproveitando resultados já calculados. Ou seja, o problema é resolvido por etapas
                                (quase sempre utilizando matrizes, mas isso depende do problema).
                            </p>
                            <p>
                                No caso do algoritmo LCS, a solução envolve criar e percorrer uma matriz de acordo com
                                as linhas dos arquivos que estão sendo comparados. Essa é uma matriz m × n (m = tamanho
                                do arquivo 1, n = tamanho do arquivo 2), com complexidade:
                                <code>Tempo: O(m × n) | Memória: O(m × n)</code>. Isso pode ser viável para textos
                                curtos, mas torna-se completamente inviável para arquivos grandes (por exemplo, milhares
                                de linhas).
                            </p>
                            <p>
                                Em 1986, esse problema de performance foi resolvido por um cientista da computação
                                norte-americano chamado <strong>Eugene W. Myers</strong>, que se tornou muito famoso
                                pelo seu artigo:
                                <a href="http://www.xmailserver.org/diff2.pdf" class="blog-link">
                                    An O(ND) Difference Algorithm and Its Variations </a
                                >. Nesse artigo, Myers apresenta uma otimização da solução do problema de LCS de forma
                                extremamente eficiente.
                            </p>
                            <p>
                                Ele calcula o Shortest Edit Script (SES) diretamente, sem precisar construir toda a
                                matriz da programação dinâmica. A ideia central é representar o processo de edição em um
                                grafo de caminhos de diferença e encontrar o caminho mais curto usando uma abordagem de
                                expansão por diagonais, com complexidade: <strong>Tempo:</strong>
                                <code>O(N × D)</code> e <strong>Memória:</strong> <code>O(N + M)</code>, onde N e M são
                                os tamanhos das duas sequências e D é o número mínimo de edições (inserções + deleções).
                            </p>
                            <p>
                                De forma simplificada, imagine que, em vez de criar uma tabela inteira e percorrê-la até
                                chegar à última célula, o algoritmo de Myers realiza <strong>atalhos</strong>,
                                caminhando apenas pelas diagonais até atingir a última célula da matriz.
                            </p>
                            <p>
                                Para entender melhor, veja este exemplo visual de uma matriz sendo percorrida pelo
                                algoritmo LCS:
                            </p>

                            <pre><code>
arquiv0_A = "ABCABBA"
arquivo_B = "CBABAC"

    C     B     A    B    A     C
    +---+---+---+---+---+---+---+--+
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
C | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

Total: 7 × 6 = 42 operações
Ou seja, ele percorre toda a matriz.
</code></pre>
                            <p>Agora visualize o trajeto do algoritmo Myers resolvendo o mesmo problema:</p>
                            <pre><code>
arquiv0_A = "ABCABBA"
arquivo_B = "CBABAC"

    C     B     A    B    A     C
    +---+---+---+---+---+---+---+--+
A | ⬛ | ⬛ | ✅ | ⬛ | ⬛ | ⬛ |
B | ⬛ | ✅ | ✅ | ✅ | ⬛ | ⬛ |
C | ✅ | ✅ | ⬛ | ⬛ | ⬛ | ✅ |
A | ⬛ | ✅ | ✅ | ⬛ | ✅ | ⬛ |
B | ⬛ | ✅ | ✅ | ✅ | ⬛ | ⬛ |
B | ⬛ | ⬛ | ✅ | ✅ | ✅ | ⬛ |
A | ⬛ | ⬛ | ✅ | ✅ | ✅ | ✅ |

✅ = célula realmente explorada.
⬛ = célula ignorada/fora do caminho possível.

Total: aproximadamente 20 células visitadas (em vez de 42)
</code></pre>
                            <p>
                                O objetivo de qualquer algoritmo de diff é gerar o Shortest Edit Script (SES): O menor
                                conjunto de operações (inserções e deleções) necessárias para transformar uma sequência
                                A em B. Atualmente, o algoritmo de Myers encontra a <strong>solução ótimo</strong> para
                                o problema do SES, isto é, resolve o problema de forma mais eficiente possivel, e é
                                amplamente utilizado nas ferramentas de diff modernas até hoje.
                            </p>
                            <p>
                                Atualmente, o algoritmo de <strong>Myers</strong> é o padrão utilizado pelo
                                <strong>Git</strong> para a geração de diffs. Ele também está presente nas principais
                                distribuições Linux, integrado à ferramenta <code>diff</code> do pacote
                                <code>GNU diffutils</code>. Esse módulo inclui, principalmente, os seguintes
                                utilitários:
                            </p>

                            <p>
                                <code>diff:</code> compara dois arquivos ou diretórios e exibe as diferenças linha a
                                linha. (<em>Utiliza o algoritmo de Myers</em>) <br /><br />

                                <code>cmp:</code> compara dois arquivos byte a byte (ou linha a linha), indicando o
                                ponto exato em que diferem. (<em>Não utiliza o algoritmo de Myers</em>) <br /><br />

                                <code>diff3:</code> compara três arquivos — normalmente o “original”, a “versão A” e a
                                “versão B” — e pode gerar uma fusão (<em>merge</em>) com indicação de conflitos. (<em
                                    >Utiliza o algoritmo de Myers</em
                                >) <br /><br />

                                <code>sdiff:</code> compara dois arquivos lado a lado e permite, de forma interativa,
                                escolher ou mesclar alterações. (<em>Utiliza o algoritmo de Myers</em>)
                            </p>

                            <p>
                                Alternativas modernas de Diffs como <strong>Patience Diff</strong> ou
                                <strong>Histogram Diff</strong> aplicam soluções heuristicas, na prática, são pequenas
                                variações do algoritmo LCS, ambos com menos perfomance, mas com maior foco em melhorar a
                                legibilidade do diff.
                            </p>
                            <p>
                                <strong>Sobre o Patience Diff:</strong> foi criado por Bram Cohen (criador do
                                BitTorrent) em 2007. Em 2008, chegou a ser adotado pelo sistema de controle de versão
                                <strong>Bazaar</strong> e, em 2010, a equipe do Git adicionou suporte ao algoritmo por
                                meio da opção <code>--diff-algorithm=patience</code>.
                            </p>
                            <p>
                                Esse algoritmo prioriza a geração de diffs mais <strong>legíveis</strong> para humanos.
                                Ele faz isso detectando <code>anchors</code> (âncoras), que são linhas únicas presentes
                                em ambos os arquivos, e aplica o diff apenas <em>entre</em> essas âncoras. Para
                                identificar essas âncoras, o algoritmo utiliza uma ordenação seguida da resolução do
                                problema da <strong>LIS</strong> (<em>Longest Increasing Subsequence</em> — subsequência
                                crescente mais longa).
                            </p>
                            <p>
                                Porém, se nenhuma âncora for encontrada — ou seja, se os arquivos A e B forem
                                extremamente diferentes —, o <em>Patience Diff</em> passa a utilizar o algoritmo de
                                <strong>Myers</strong> como estratégia de fallback. Em condições normais, o
                                <em>Patience Diff</em> possui complexidade de tempo média <code>O(n log n)</code> e
                                complexidade de memória <code>O(n)</code>, mas, ao recorrer ao algoritmo de Myers, a
                                complexidade pode chegar a <code>O(n × m)</code> tanto em tempo quanto em uso de
                                memória.
                            </p>

                            <p>
                                <strong>Sobre o Histogram Diff:</strong> esse algoritmo foi introduzido posteriormente
                                no Git como uma evolução do <em>Patience Diff</em>. Ele também busca gerar diffs mais
                                <strong>legíveis</strong>, mas utiliza um método baseado em
                                <strong>histogramas de frequência</strong> para identificar linhas únicas e
                                significativas nos arquivos. Dessa forma, ele equilibra bem a clareza do resultado com
                                uma melhor cobertura de mudanças, sendo especialmente útil em arquivos com muitas
                                repetições de linhas semelhantes. HistogramDiff foi adicionado em 2011 no Git.
                            </p>
                        </div>

                        <div id="intro" class="about-text">
                            <h1 class="h4 portfolio-title">LCS</h1>

                            <p>
                                Ao executar o comando: <code>diff old.txt new.txt > changes.patch</code> o sistema vai
                                executar o diff com LCS, e criar um novo arquivo (changes.patch) onde estará armazenado
                                o <strong>delta</strong>. O nome "delta" vem da letra grega Δ (delta), usada em
                                matemática para representar mudança ou variação. Nesse caso, podemos dizer que o arquivo
                                <code>changes.patch</code> é o <strong>delta</strong> entre <code>old.txt</code> e
                                <code>new.txt</code>.
                            </p>
                            <p>Segue abaixo um exemplo de conteúdo de um delta:</p>

                            <pre><code>@@ -1,3 +1,3 @@<span style="color: red;">-Linha antiga</span><span style="color: green;">+Linha nova</span>Linha que não mudou</code></pre>

                            <p>
                                Perceba que na primeira linha do arquivo de delta, existe isso:
                                <code>@@ -1,3 +1,3 @@</code> essas informações indicam o "contenxto de mudança", isso é
                                necessário pois um arquivo delta não armazena todo o conteúdo do arquivo original, ele
                                apenas armazena hunks (nacos) de código, e a ferramenta <code>patch</code> (falarei do
                                patch mais a diante), precisa saber examente qual ele deve aplicar as mudanças.
                            </p>
                            <p><code>@@</code>: Cada hunk começa com <code>@@</code> e termina com <code>@@</code>.</p>
                            <p>Para entender melhor, veja esse exemplo de um delta:</p>
                        </div>
                    </section>

                    <p>https://bramcohen.livejournal.com/73318.html</p>

                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
    </body>
</html>
