<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Entendendo algoritmos de diff</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Entendendo algoritmos de diff</h1>
                        <div>
                            <small style="color: white">17/10/2025</small> -
                            <a
                                href="https://github.com/AdrielSantoss/Myers-Patience-Diff"
                                target="_blank"
                                class="blog-link"
                                >Projeto (Github)</a
                            >
                        </div>
                        <div class="tags">
                            <small class="tag">Algoritmo</small>
                            <small class="tag">Programação dinâmica</small>
                            <small class="tag">Rust</small>
                            <small class="tag">Diff</small>
                            <small class="tag">Compressão</small>
                            <small class="tag">Git</small>
                        </div>
                    </section>

                    <section class="portfolio-description">
                        <div id="intro" class="about-text">
                            <p>
                                Neste artigo, vou falar sobre algoritmos de diff e, de quebra, um pouco sobre
                                compressão. Desenvolvi um sistema em Rust que implementa dois algoritmos de diff:
                                <strong>Myers</strong> e <strong>Patience</strong>.
                            </p>
                            <p>
                                O projeto nasceu com o objetivo de integrá-lo ao GitAdr. Escolhi Rust por preferência
                                pessoal, mas você pode implementar esses algoritmos em qualquer linguagem que desejar.
                            </p>
                            <p>
                                Além da integração com o GitAdr, um dos motivos da criar esse projeto, é que no
                                trabalho, atualmente eu utilizo Windows 11, e por padrão, o Windowes não possui nenhuma
                                ferramenta de diff decente, todas são simples de força bruta de comparação linha a
                                linha, nenhuma baseada no algoritmo do Myers.
                            </p>
                            <p>
                                E, claro, um dos principais motivos para criar este projeto foi a oportunidade de
                                aprender mais sobre algoritmos de diff de texto.
                            </p>
                        </div>
                        <div id="history" class="about-text">
                            <h1 class="h4 portfolio-title">Estudar o passado é conhecer o presente</h1>

                            <p>
                                O primeiro algoritmo de diff eficiente foi implementado em <strong>1976</strong> para o
                                sistema operacional Unix por <strong>Douglas McIlroy</strong> e
                                <strong>James Hunt</strong> na Bell Labs — assim que surgiu a ferramenta diff que existe
                                em todo Linux atualmente.
                            </p>
                            <p>
                                Essa ferramenta de diff realiza comparação por <strong>linha</strong> e utiliza o
                                algoritmo
                                <a
                                    href="https://en.wikipedia.org/wiki/Longest_common_subsequence"
                                    target="_blank"
                                    class="blog-link"
                                    >Longest common subsequence (LCS)</a
                                >, esse algoritmo possui complexidade: <strong>O(n × m)</strong> de tempo e memória.
                                Sendo <strong>n</strong> o tamanho (número de linhas) do primeiro arquivo e
                                <strong>m</strong> o tamanho do segundo arquivo.
                            </p>
                            <p>
                                Após o surgimento e popularização do diff baseado em LCS, surgiu o comando
                                <code>patch</code> criado por Larry Wall (o mesmo criador do Perl). Esse comando
                                permitia aplicar um arquivo .diff (também chamado .patch) para reconstruir a nova versão
                                de um arquivo.
                            </p>
                            <p>Isso criou o ciclo clássico:</p>
                            <pre><code>diff old new > changes.patch 
patch old < changes.patch</code></pre>
                            <p>
                                Esse mecanismo se tornou fundamental para o desenvolvimento colaborativo de software
                                livre (BSD, GNU, etc.).
                            </p>
                            <p>
                                É importante destacar que o algoritmo de LCS utiliza
                                <strong>programação dinâmica</strong> para resolver o problema. Programação dinâmica é
                                uma técnica para resolver problemas complexos dividindo-os em subproblemas menores e
                                reaproveitando resultados já calculados. Ou seja, o problema é resolvido por etapas
                                (quase sempre utilizando matrizes, mas isso depende do problema).
                            </p>
                            <p>
                                No caso do algoritmo LCS, a solução envolve criar e percorrer uma matriz de acordo com
                                as linhas dos arquivos que estão sendo comparados. Essa é uma matriz m × n (m = tamanho
                                do arquivo 1, n = tamanho do arquivo 2), com complexidade:
                                <code>Tempo: O(m × n) | Memória: O(m × n)</code>. Isso pode ser viável para textos
                                curtos, mas torna-se completamente inviável para arquivos grandes (por exemplo, milhares
                                de linhas).
                            </p>
                            <p>
                                Em 1986, esse problema de performance foi resolvido por um cientista da computação
                                norte-americano chamado <strong>Eugene W. Myers</strong>, que se tornou muito famoso
                                pelo seu artigo:
                                <a href="http://www.xmailserver.org/diff2.pdf" class="blog-link" target="_blank">
                                    An O(ND) Difference Algorithm and Its Variations </a
                                >. Nesse artigo, Myers apresenta uma otimização da solução do problema de LCS de forma
                                extremamente eficiente.
                            </p>
                            <p>
                                Ele calcula o Shortest Edit Script (SES) diretamente, sem precisar construir toda a
                                matriz da programação dinâmica. A ideia central é representar o processo de edição em um
                                grafo de caminhos de diferença e encontrar o caminho mais curto usando uma abordagem de
                                expansão por diagonais, com complexidade: <strong>Tempo:</strong>
                                <code>O(N × D)</code> e <strong>Memória:</strong> <code>O(N + M)</code>, onde N e M são
                                os tamanhos das duas sequências e D é o número mínimo de edições (inserções + deleções).
                            </p>
                            <p>
                                De forma simplificada, imagine que, em vez de criar uma tabela inteira e percorrê-la até
                                chegar à última célula, o algoritmo de Myers realiza <strong>atalhos</strong>,
                                caminhando apenas pelas diagonais até atingir a última célula da matriz.
                            </p>
                            <p>
                                Para entender melhor, veja este exemplo visual de uma matriz sendo percorrida pelo
                                algoritmo LCS:
                            </p>

                            <pre><code>
arquiv0_A = "ABCABBA"
arquivo_B = "CBABAC"

    C     B     A    B    A     C
    +---+---+---+---+---+---+---+--+
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
C | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
B | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
A | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

Total: 7 × 6 = 42 operações
Ou seja, ele percorre toda a matriz.
</code></pre>
                            <p>Agora visualize o trajeto do algoritmo Myers resolvendo o mesmo problema:</p>
                            <pre><code>
arquiv0_A = "ABCABBA"
arquivo_B = "CBABAC"

    C     B     A    B    A     C
    +---+---+---+---+---+---+---+--+
A | ⬛ | ⬛ | ✅ | ⬛ | ⬛ | ⬛ |
B | ⬛ | ✅ | ✅ | ✅ | ⬛ | ⬛ |
C | ✅ | ✅ | ⬛ | ⬛ | ⬛ | ✅ |
A | ⬛ | ✅ | ✅ | ⬛ | ✅ | ⬛ |
B | ⬛ | ✅ | ✅ | ✅ | ⬛ | ⬛ |
B | ⬛ | ⬛ | ✅ | ✅ | ✅ | ⬛ |
A | ⬛ | ⬛ | ✅ | ✅ | ✅ | ✅ |

✅ = célula realmente explorada.
⬛ = célula ignorada/fora do caminho possível.

Total: aproximadamente 20 células visitadas (em vez de 42)
</code></pre>
                            <p>
                                O objetivo de qualquer algoritmo de diff é gerar o
                                <a href="https://en.wikipedia.org/wiki/Edit_distance" class="blog-link" target="_blank"
                                    >Shortest Edit Script (SES)</a
                                >: O menor conjunto de operações (inserções e deleções) necessárias para transformar uma
                                sequência A em B. Atualmente, o algoritmo de Myers encontra a
                                <strong>solução ótima</strong> para o problema do SES, isto é, resolve o problema de
                                forma mais eficiente possivel, e é amplamente utilizado nas ferramentas de diff modernas
                                até hoje.
                            </p>

                            <p>
                                Atualmente, o algoritmo de <strong>Myers</strong> é o padrão utilizado pelo
                                <strong>Git</strong> para a geração de diffs. Ele também está presente nas principais
                                distribuições Linux, integrado à ferramenta <code>diff</code> do pacote
                                <code>GNU diffutils</code>. Esse módulo inclui, principalmente, os seguintes
                                utilitários:
                            </p>

                            <p>
                                <code>diff:</code> compara dois arquivos ou diretórios e exibe as diferenças linha a
                                linha. (<em>Utiliza o algoritmo de Myers</em>) <br /><br />

                                <code>cmp:</code> compara dois arquivos byte a byte (ou linha a linha), indicando o
                                ponto exato em que diferem. (<em>Não utiliza o algoritmo de Myers</em>) <br /><br />

                                <code>diff3:</code> compara três arquivos — normalmente o “original”, a “versão A” e a
                                “versão B” — e pode gerar uma fusão (<em>merge</em>) com indicação de conflitos. (<em
                                    >Utiliza o algoritmo de Myers</em
                                >) <br /><br />

                                <code>sdiff:</code> compara dois arquivos lado a lado e permite, de forma interativa,
                                escolher ou mesclar alterações. (<em>Utiliza o algoritmo de Myers</em>)
                            </p>

                            <p>
                                Alternativas modernas de Diffs como <strong>Patience Diff</strong> ou
                                <strong>Histogram Diff</strong> aplicam soluções heuristicas, na prática, são pequenas
                                variações do algoritmo LCS, ambos com menos perfomance, mas com maior foco em melhorar a
                                legibilidade do diff.
                            </p>
                            <p>
                                <strong>Sobre o Patience Diff:</strong> foi criado por Bram Cohen (criador do
                                BitTorrent) em 2007. Em 2008, chegou a ser adotado pelo sistema de controle de versão
                                <strong>Bazaar</strong> e, em 2010, a equipe do Git adicionou suporte ao algoritmo por
                                meio da opção <code>--diff-algorithm=patience</code>.
                            </p>
                            <p>
                                Esse algoritmo prioriza a geração de diffs mais <strong>legíveis</strong> para humanos.
                                Ele faz isso detectando <code>anchors</code> (âncoras), que são linhas únicas presentes
                                em ambos os arquivos, e aplica o diff apenas <em>entre</em> essas âncoras. Para
                                identificar essas âncoras, o algoritmo utiliza uma ordenação seguida da resolução do
                                problema da
                                <a
                                    href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence"
                                    class="blog-link"
                                    target="_blank"
                                    ><strong>LIS</strong> (<em>Longest Increasing Subsequence</em> — subsequência
                                    crescente mais longa).</a
                                >.
                            </p>
                            <p>
                                Porém, se nenhuma âncora for encontrada — ou seja, se os arquivos A e B forem
                                extremamente diferentes —, o <em>Patience Diff</em> passa a utilizar o algoritmo de
                                <strong>Myers</strong> como estratégia de fallback. Em condições normais, o
                                <em>Patience Diff</em> possui complexidade de tempo média <code>O(n log n)</code> e
                                complexidade de memória <code>O(n)</code>, mas, ao recorrer ao algoritmo de Myers, a
                                complexidade pode chegar a <code>O(n × m)</code> tanto em tempo quanto em uso de
                                memória.
                            </p>

                            <p>
                                <strong>Sobre o Histogram Diff:</strong> esse algoritmo foi introduzido posteriormente
                                no Git como uma evolução do <em>Patience Diff</em>. Ele também busca gerar diffs mais
                                <strong>legíveis</strong>, mas utiliza um método baseado em
                                <strong>histogramas de frequência</strong> para identificar linhas únicas e
                                significativas nos arquivos. Dessa forma, ele equilibra bem a clareza do resultado com
                                uma melhor cobertura de mudanças, sendo especialmente útil em arquivos com muitas
                                repetições de linhas semelhantes. HistogramDiff foi adicionado em 2011 no Git.
                            </p>
                        </div>

                        <div id="hunks" class="about-text">
                            <h1 class="h4 portfolio-title">Deltas e Hunks</h1>
                            <p>
                                Ao executar o comando no Linux: <code>diff old.txt new.txt > changes.patch</code> o
                                sistema vai executar o diff, e criar um novo arquivo (changes.patch) onde estará
                                armazenado o <strong>delta</strong>. O nome "delta" vem da letra grega Δ (delta), usada
                                em matemática para representar mudança ou variação. Nesse caso, podemos dizer que o
                                arquivo <code>changes.patch</code> é o <strong>delta</strong> entre
                                <code>old.txt</code> e <code>new.txt</code>.
                            </p>
                            <p>Segue abaixo um exemplo de conteúdo de um delta:</p>

                            <pre><code>@@ -1,3 +1,3 @@<span style="color: red;">-Linha antiga</span><span style="color: green;">+Linha nova</span>Linha que não mudou</code></pre>

                            <p>
                                Perceba que na primeira linha do arquivo de delta, existe isso:
                                <code>@@ -1,3 +1,3 @@</code> essas informações indicam o "contenxto de mudança", isso é
                                necessário pois um arquivo delta não armazena todo o conteúdo do arquivo original, ele
                                apenas armazena hunks (nacos) de código, e a ferramenta <code>patch</code>, precisa
                                saber examente qual ele deve aplicar as mudanças.
                            </p>
                            <p><code>@@</code>: Cada hunk começa com <code>@@</code> e termina com <code>@@</code>.</p>
                            <p>
                                Você provavelmente já se deparou com algo assim ao visualizar as alterações de um commit
                                no <strong>Git</strong>. Veja o exemplo abaixo:
                            </p>

                            <div class="item item-diagrama">
                                <img
                                    src="../../assets/images/blog/diff-github-example.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                                <div class="item-description">
                                    <small><i>Visualização de um diff no GitHub.</i></small>
                                </div>
                            </div>

                            <br />

                            <p>
                                Quando uma nova linha é adicionada, ela é marcada com o símbolo
                                <small style="color: green">+</small>. Já quando uma linha é removida, ela aparece com o
                                símbolo <small style="color: red">−</small>. Esse é o formato mais comum para arquivos
                                de <em>patch</em>, conhecido como
                                <a
                                    href="https://www.gnu.org/software/diffutils/manual/html_node/Unified-Format.html"
                                    class="blog-link"
                                    target="_blank"
                                    >Unified Format</a
                                >.
                            </p>
                        </div>

                        <div id="lcs" class="about-text">
                            <h1 class="h4 portfolio-title">LCS</h1>

                            <p>
                                A melhor forma de compreender e implementar algoritmos como o <strong>Myers</strong> ou
                                o <strong>Patience</strong> é começar pela sua base: o <strong>LCS clássico</strong>.
                                Entender o problema da LCS e o funcionamento do algoritmo tradicional é essencial para,
                                posteriormente, compreender tanto a solução ótima proposta por Myers quanto a heurística
                                empregada pelo Patience.
                            </p>

                            <p>O problema de LCS pode ser resumido da seguinte forma:</p>

                            <pre><code>Dadas duas sequências, queremos encontrar a maior subsequência que aparece em ambas, 
mantendo a ordem, mas não necessariamente de forma contígua.</code></pre>

                            <p>
                                Vamos imaginar duas listas. Nosso objetivo é descobrir qual é a maior subsequência comum
                                entre <code>Lista_A</code> e <code>Lista_B</code>. Veja o exemplo:
                            </p>

                            <pre><code>Lista_A = A B C D G H
Lista_B = A E D F H R

"A": aparece nas duas → ✅
"D": aparece nas duas, depois de "A" → ✅
"H": aparece nas duas, depois de "D" → ✅

LCS = A D H
</code></pre>

                            <p>Perceba que a LCS encontrada (<code>A D H</code>) respeita as seguintes regras:</p>

                            <p>
                                1. Os elementos aparecem tanto em <code>Lista_A</code> quanto em <code>Lista_B</code> →
                                <i>comum</i> <br /><br />

                                2. Eles mantêm a mesma ordem nas duas listas → <i>subsequência</i> <br /><br />

                                3. <code>A D H</code> é a maior sequência possível que atende às condições anteriores →
                                <i>mais longa</i>
                            </p>

                            <p>
                                Em um algoritmo de <strong>diff de texto</strong>, o papel da LCS é identificar quais
                                linhas <strong>não mudaram</strong> entre o arquivo A e o arquivo B. A partir dessa
                                subsequência comum, o algoritmo consegue determinar quais linhas foram
                                <strong>adicionadas</strong> ou <strong>removidas</strong>.
                            </p>

                            <p>
                                Com base nisso, é gerado o <strong>Shortest Edit Script (SES)</strong>, que representa o
                                conjunto mínimo de operações necessárias para transformar o arquivo A no arquivo B. Cada
                                linha é associada a um tipo de <strong>operação</strong>, são elas:
                            </p>

                            <ul>
                                <li><strong>EQUAL</strong>: linha presente em ambos os arquivos (parte da LCS).</li>
                                <li>
                                    <strong>INSERT</strong> (<small style="color: green">+</small>): linha adicionada em
                                    B.
                                </li>
                                <li>
                                    <strong>DELETE</strong> (<small style="color: red">−</small>): linha removida de A.
                                </li>
                            </ul>

                            <p>Exemplo:</p>

                            <pre><code>Arquivo A:
1. nome = "Alice"
2. idade = 25
3. cidade = "São Paulo"

Arquivo B:
1. nome = "Alice"
2. idade = 26
3. país = "Brasil"
4. cidade = "São Paulo"

LCS: ["nome = 'Alice'", "cidade = 'São Paulo'"]

SES:
  nome = "Alice" → EQUAL
- idade = 25 → DELETE
+ idade = 26 → INSERT
+ país = "Brasil" → INSERT
  cidade = "São Paulo" → EQUAL
</code></pre>

                            <p>
                                Para entender com precisão como obter a operação para cada linha de cada arquivo, a
                                lógica é a seguinte:
                            </p>
                            <pre><code>
Validação para identificar a operação necessária:

Arquivo A:
1. Se essa linha existe na LCS → EQUAL
2. Se essa linha não existe na LCS → DELETE

Arquivo B:
1. Se essa linha existe na LCS → EQUAL
2. Se essa linha não existe na LCS → INSERT

SES EXPLICADO:
  nome = "Alice" → EQUAL, ESSA LINHA EXISTE NA LCS.
- idade = 25 → DELETE, ESSA LINHA NÃO EXISTE NA LCS. (LINHA DO ARQUIVO A)
+ idade = 26 → INSERT, ESSA LINHA NÃO EXISTE NA LCS. (LINHA DO ARQUIVO B)
+ país = "Brasil" → INSERT, ESSA LINHA NÃO EXISTE NA LCS. (LINHA DO ARQUIVO B)
  cidade = "São Paulo" → EQUAL, ESSA LINHA EXISTE NA LCS.
</code></pre>
                            <p>
                                É assim que um diff totalmente baseado no algoritmo de LCS clássico funciona, primeiro
                                identifica o que <strong>não mudou (LCS)</strong> e depois identifica qual é a
                                <strong>operação</strong> necessária para cada linha que <strong>mudou</strong> (SES).
                            </p>
                            <p>
                                Como mencionado anteriormente, o problema dessa abordagem, é que ela é ineficiente para
                                arquivos grandes, com muitas linhas e muitas alterações, mas para entender esse déficit,
                                temos que sair da teoria e ir para o campo prático, e verificar como funciona a
                                construção desse algoritmo.
                            </p>
                            <p>Segue abaixo o algoritmo que obtém a LCS em Rust:</p>

                            <details>
                                <summary>Código fonte do algoritmo LCS</summary>
                                <pre><code>
fn main() {
    println!("Resolvendo o problema da LCS!");
    let entries_a = vec!["A", "G", "G", "T", "A", "B"];
    let entries_b = vec!["G", "X", "T", "X", "A", "Y", "B"]; 

    let mut dp: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![0; entries_b.len() + 1]; entries_a.len() + 1];

    for i in 1..=entries_a.len() {
        for j in 1..=entries_b.len()  {
            if entries_a[i-1] == entries_b[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else {
                dp[i][j] = dp[i-1][j].max(dp[i][j-1]);
            }
        }
    }

    let lcs_len = dp[entries_a.len()][entries_b.len()];
    println!("o tamanho da LCS é: {}", lcs_len);

    let mut i = entries_a.len();
    let mut j = entries_b.len();
    let mut lcs: Vec&lt;&str&gt; = Vec::new();

    while i > 0 && j > 0 {
        if entries_a[i-1] == entries_b[j-1] {
            lcs.push(entries_a[i-1]);
            j -= 1;
            i -= 1;
        }
        else if dp[i-1][j] > dp[i][j-1] {
            i -= 1;
        }
        else {
            j -= 1;
        }
    }

    lcs.reverse();
    println!("LCS completa é: {:?}", lcs);
}
</code></pre>
                            </details>

                            <p>
                                O primeiro <strong>subproblema</strong> que precisamos resolver é: determinar o
                                <strong>tamanho</strong> da LCS. Esse resultado é fundamental, pois será utilizado
                                posteriormente para reconstruir a subsequência comum mais longa em si.
                            </p>

                            <p>
                                Para isso, inicializamos uma matriz <code>dp</code> (<em>dynamic programming</em>)
                                preenchida com zeros. Ela possui tamanho <strong>(m + 1) × (n + 1)</strong>, onde
                                <strong>m</strong> = <code>entries_a.len()</code> (comprimento de <em>A</em>) e
                                <strong>n</strong> = <code>entries_b.len()</code> (comprimento de <em>B</em>).
                            </p>

                            <p>
                                Em seguida, utilizamos dois laços <code>for</code> aninhados para percorrer cada posição
                                da matriz, conforme mostrado abaixo:
                            </p>

                            <pre><code>
for i in 1..=entries_a.len() {
    for j in 1..=entries_b.len() {
        if entries_a[i - 1] == entries_b[j - 1] {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
            dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);
        }
    }
}
</code></pre>
                            <p>
                                Essa abordagem tem uma complexidade de tempo de
                                <strong>O(m × n)</strong>, pois cada célula da matriz é visitada exatamente uma vez.
                                Embora eficiente do ponto de vista teórico-polynomial, o custo de armazenamento e
                                processamento pode se tornar elevado para arquivos muito grandes — especialmente nas
                                décadas de 1970 e 1980, quando recursos de memória e CPU eram extremamente limitados.
                            </p>
                            <p>Dentro dos for, existe isso:</p>
                            <pre><code>
if entries_a[i - 1] == entries_b[j - 1] {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);
}
</code></pre>
                            <p>
                                Você deve estar se perguntando: "que raios esta acontecendo aqui?". Essa é a parte
                                "mágica" do algoritmo, onde a matemática entra na jogada.
                            </p>
                            <p>A fórmula matemática original é essa:</p>

                            <div class="item item-diagrama">
                                <img
                                    src="../../assets/images/blog/diff-lcs.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                            </div>
                            <br />
                            <p>Fórmula adaptada para programação dinâmica com a matriz <code>dp</code>:</p>

                            <div class="item item-diagrama">
                                <img
                                    src="../../assets/images/blog/diff-lcs-dp.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                            </div>

                            <br />

                            <p>
                                Não vou entrar no detalhe matemático dessas fórmulas, apenas vou mostrar o funcionamento
                                do algoritmo a nivel de programação, caso queira entender essas fórmulas detalhadamente,
                                recomendo esse artigo:
                                <a
                                    href="https://ics.uci.edu/~dhirschb/pubs/p664-hirschberg.pdf"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                ></a>
                                <a
                                    href="https://ics.uci.edu/~dhirschb/pubs/p664-hirschberg.pdf"
                                    target="_blank"
                                    class="blog-link"
                                    >Algorithms for the Longest Common Subsequence Problem </a
                                >. Segue abaixo uma explicação da aplicação das fórmulas do algoritmo em pseudocódigo:
                            </p>

                            <code>
                                <pre>
i = Linha
j = Coluna

formula 1: dp[i][j] = dp[i - 1][j - 1] + 1;
formula 2: dp[i - 1][j].max(dp[i][j - 1]); (recebe o maior valor entre "dp[i - 1][j]" e "dp[i][j - 1]")

Quando aplicar cada fórmula:

se entries_a[i - 1] == entries_b[j - 1] → dp[i][j] = dp[i - 1][j - 1] + 1; (fórmula 1)
se não → dp[i - 1][j].max(dp[i][j - 1]); (fórmula 2)
                            </pre
                                >
                            </code>
                            <br />
                            <p>
                                Após percorrer toda a matriz e setar cada célula com o valor obtido pelas
                                <strong>fórmulas</strong>, vamos obter uma matriz <code>dp</code> nesse estilo:
                            </p>
                            <pre><code>
let entries_a = vec!["A", "G", "G", "T", "A", "B"];
let entries_b = vec!["G", "X", "T", "X", "A", "Y", "B"]; 

Matriz dp:

      |   | G | X | T | X | A | Y | B
      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
  A   | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1
  G   | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
  G   | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
  T   | 0 | 1 | 1 | 2 | 2 | 2 | 2 | 2
  A   | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 3
  B   | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 4

</code></pre>
                            <p>
                                Perceba o último valor da última célula da dp, na posição: <code>dp[6][8]</code>, o
                                valor obtido é <strong>4</strong>, esse é o <strong>tamanho da LCS!</strong>
                            </p>
                            <p>
                                Agora, temos que resolver o segundo — e último — subproblema, que é: obter a LCS. Para
                                isso será necessário utilizar a matriz <code>dp</code> que criamos para resolver o
                                problema anterior.
                            </p>
                            <p>Nesse momento, estamos estudando essa parte do algoritmo:</p>
                            <pre><code>
let mut i = entries_a.len();
let mut j = entries_b.len();
let mut lcs: Vec&lt;&str&gt; = Vec::new();

while i > 0 && j > 0 {
    if entries_a[i-1] == entries_b[j-1] {
        lcs.push(entries_a[i-1]);
        j -= 1;
        i -= 1;
    }
    else if dp[i-1][j] > dp[i][j-1] {
        i -= 1;
    }
    else {
        j -= 1;
    }
}

lcs.reverse();
println!("LCS completa é: {:?}", lcs);</code></pre>

                            <p>
                                Nessa etapa do algoritmo ocorre o processo conhecido como <strong>backtracking</strong>.
                                Ele consiste em percorrer a matriz <code>dp</code> de trás para frente — isto é,
                                partindo do último elemento até o primeiro — para reconstruir a subsequência comum mais
                                longa (LCS).
                            </p>
                            <p>
                                A cada iteração, comparamos os caracteres das duas sequências e seguimos o caminho que
                                levou ao valor atual da matriz. Se <code>entries_a[i - 1] == entries_b[j - 1]</code>,
                                significa que esse caractere faz parte da LCS. Ele é adicionado ao resultado, e movemos
                                diagonalmente (<code>i -= 1</code> e <code>j -= 1</code>).
                            </p>
                            <p>
                                Caso contrário, seguimos o maior valor entre <code>dp[i - 1][j]</code> e
                                <code>dp[i][j - 1]</code> — ou seja, avançamos na direção onde há uma subsequência comum
                                mais longa.
                            </p>
                            <p>
                                No fim do processo, obtemos a LCS na ordem inversa, por isso é necessário aplicar
                                <code>lcs.reverse()</code> para recuperar a sequência correta.
                            </p>
                            <p>Veja esse exemplo visual da matriz <code>dp</code> sendo percorrida:</p>

                            <pre><code>
Lógica explicada:
entries_a[i-1] == entries_b[j-1]: Elementos iguais, faz parte da LCS, anda na Diagonal (↖)
dp[i-1][j] > dp[i][j-1]: Elementos diferentes, não faz parte da LCS, anda para cima ↑
dp[i-1][j] > dp[i][j-1]: Elementos diferentes, não faz parte da LCS, anda para esquerda ←

Dp:
      |   | G | X | T | X | A | Y | B
      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
  A   | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1
  G   | 0 | 1↖| 1 | 1 | 1 | 1 | 1 | 1
  G   | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
  T   | 0 | 1 | 1 | 2↖| 2 | 2 | 2 | 2
  A   | 0 | 1 | 1 | 2 | 2 | 3↖| 3 | 3
  B   | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 4↖

O backtraking percorreu 4 células diagonais: (6,7) → (5,5) → (4,3) → (2,1)
Cada uma representa um elemento da LCS: G, T, A, B</code></pre>

                            <p>
                                E essa é a explicação geral do algoritmo utilizado pelos diffs baseados no LCS clássico.
                                Vale destacar que o algoritmo de LCS não é aplicado apenas em ferramentas de comparação
                                de texto, mas também é amplamente utilizado em outras áreas, como na
                                <strong>Bioinformática</strong>, especialmente em tarefas de
                                <i>alinhamento de sequências</i> de DNA, RNA e proteínas.
                            </p>

                            <p>
                                Neste tópico, o foco foi explicar o funcionamento do algoritmo de LCS e sua aplicação
                                nos algoritmos de diff. No entanto, não cheguei a implementar um diff baseado
                                diretamente em LCS — até porque esse tipo de abordagem se tornou obsoleta após o
                                surgimento do algoritmo de <strong>Myers</strong>. Assim, concentrei meus esforços no
                                desenvolvimento de uma ferramenta de diff utilizando os algoritmos de
                                <strong>Myers</strong> e <strong>Patience</strong>, que são muito mais eficientes e
                                modernos.
                            </p>
                        </div>
                    </section>

                    <p>https://bramcohen.livejournal.com/73318.html</p>
                    <p>https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html</p>

                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
        <script type="module">
            import { loadSideBarBlog } from '../../assets/js/elements/sidebar.js';

            const sections = [
                { id: 'intro', label: 'Introdução' },
                { id: 'history', label: 'Estudar o passado é conhecer o presente' },
                { id: 'hunks', label: 'Deltas e Hunks' },
                { id: 'lcs', label: 'LCS' }
            ];

            loadSideBarBlog(sections);
        </script>
    </body>
</html>
