<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Rest</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Entendendo a Arquitetura REST</h1>

                        <div>
                            <small style="color: white">10/11/2025</small> -
                            <a
                                href="https://github.com/AdrielSantoss/API-Architectures"
                                target="_blank"
                                class="blog-link"
                                >Projeto (Github)</a
                            >
                        </div>

                        <div class="tags">
                            <small class="tag">Node</small>
                            <small class="tag">Typescript</small>
                            <small class="tag">Arquitetura</small>
                            <small class="tag">Rest</small>
                            <small class="tag">Restful</small>
                            <small class="tag">Fastify</small>
                            <small class="tag">Prisma</small>
                            <small class="tag">ORM</small>
                            <small class="tag">Teste automatizado</small>
                        </div>
                    </section>

                    <br />

                    <section class="portfolio-description">
                        <div id="intro" class="blog-text">
                            <p>
                                Entre 2019 e 2020, eu desenvolvia diversas APIs REST em Node.js, utilizando o
                                <a href="https://expressjs.com" target="_blank" class="blog-link">Express</a>
                                para criar o servidor HTTP e o ORM
                                <a href="https://knexjs.org" target="_blank" class="blog-link">Knex</a>
                                para modelar as tabelas do banco de dados.
                            </p>

                            <p>
                                Desde ent√£o, acabei me afastando um pouco do ecossistema Node, e nesse meio tempo
                                surgiram (ou se popularizaram) v√°rios frameworks e bibliotecas modernas ‚Äî como o
                                <a href="https://fastify.dev" target="_blank" class="blog-link">Fastify</a>, que oferece
                                uma performance excelente na cria√ß√£o de servidores web, e o ORM
                                <a href="https://www.prisma.io/docs/getting-started" target="_blank" class="blog-link"
                                    >Prisma</a
                                >, que traz uma linguagem de modelagem intuitiva, configura√ß√£o simples e √≥timo
                                desempenho.
                            </p>

                            <p>
                                Naquela √©poca, eu ainda n√£o utilizava TypeScript e recorria ao
                                <a href="https://jestjs.io" target="_blank" class="blog-link">Jest</a>
                                para implementar testes unit√°rios e de integra√ß√£o nas APIs.
                            </p>

                            <p>
                                Hoje percebo que o Knex tem recebido poucas atualiza√ß√µes e parece ter ficado atr√°s do
                                Prisma em termos de recursos e praticidade. O Express continua sendo uma √≥tima escolha,
                                mas o Fastify vem se destacando em performance e escalabilidade. J√° o Jest, por n√£o
                                oferecer suporte nativo a TypeScript em APIs Node, tem perdido espa√ßo para ferramentas
                                mais modernas como o
                                <a href="https://vitest.dev" target="_blank" class="blog-link">Vitest</a>.
                            </p>

                            <p>
                                Na verdade isso √© um processo natural: bibliotecas surgem, se popularizam, e depois de
                                um tempo morrem, perdem espa√ßo para uma nova biblioteca que dominou a √°rea. Por isso, eu
                                n√£o gosto de escrever sobre bibliotecas e frameworks, pois esse conte√∫do costuma se
                                <strong>defazar</strong> muito r√°pido. Nesse blog, o objetivo √© falar sobre conceitos de
                                arquitetura REST, o foco n√£o √© as novas bibliotecas, elas foram apenas o gatilho que me
                                motivou a fazer esse projeto/estudo.
                            </p>

                            <p>
                                A comunidade JavaScript/Node √© extremamente ativa ‚Äî as tecnologias evoluem r√°pido e, na
                                maioria das vezes, para melhor. Por isso, recentemente decidi revisitar meus
                                conhecimentos de arquitetura REST na pr√°tica, criando um servidor HTTP com Node +
                                TypeScript + Fastify + Prisma + Vitest, entre outras ferramentas.
                            </p>

                            <p>
                                Al√©m de relembrar conceitos, quero aproveitar essa oportunidade para pesquisar e
                                aprender coisas novas.
                            </p>
                        </div>

                        <div id="api" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API</h1>

                            <p>
                                Primeiro, devemos entender o que √© uma Api: API √© a sigla para Application Programming
                                Interface (em portugu√™s, Interface de Programa√ß√£o de Aplica√ß√µes).
                            </p>

                            <p>
                                Em resumo, API √© um meio de <strong>comunica√ß√£o</strong> entre dois sistemas, entenda
                                API como um conjunto de regras, protocolos e ferramentas que permite que diferentes
                                softwares se comuniquem e troquem informa√ß√£o.
                            </p>

                            <p>
                                Quando criamos uma API, basicamente estamos criando um tipo de software que define uma
                                <strong>interface</strong> para outros sistemas se comunicarem com ele ‚Äî expondo dados e
                                funcionalidades de forma controlada e padronizada.
                            </p>
                            <p>
                                Quando falamos "interface" j√° vem logo na cabe√ßa as interfaces gr√°ficas, esses erros s√£o
                                comuns para quem est√° come√ßando a entrar no mundo da web, a √°rea da programa√ß√£o possui
                                uma sopa de letrinhas absurda, ent√£o, para n√£o ocorrer confus√µes vamos destacar o que
                                uma API n√£o √©:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Uma api n√£o √© um banco de dados:</strong> Uma API
                                    <strong>acessa</strong> um banco de dados, mas ela n√£o √© o banco de dados. Api,
                                    normalmente n√£o armazenam dados, ela age como um
                                    <strong>intermedi√°rio</strong> entre o cliente e a fonte de dados.
                                </li>
                                <br />

                                <li>
                                    <strong>2. Uma API n√£o √© uma interface gr√°fica (UI):</strong> API significa
                                    Interface de Programa√ß√£o, n√£o Interface de Usu√°rio. Ela n√£o tem bot√µes, telas nem
                                    layouts ‚Äî quem interage com ela s√£o outros programas, n√£o pessoas diretamente.
                                </li>
                                <br />

                                <li>
                                    <strong>3. Uma API n√£o √© um servidor web:</strong> Esse √© um erro
                                    <strong>muito comum</strong>, vejo muitos programadores falando "√§pi √© o servidor da
                                    aplica√ß√£o", isso est√° completamenta <strong>errado</strong>. O servidor (Express,
                                    Django, Laravel e etc) √© quem <strong>hospeda</strong> a API e processa as
                                    requisi√ß√µes. A API √© o conjunto de regras e endpoints implementados
                                    <strong>dentro</strong> desse servidor.
                                </li>
                                <br />

                                <li>
                                    <strong>4. Uma API n√£o √© automaticamente REST:</strong> Esse √© um erro
                                    <strong>cl√°ssico</strong>, REST √© um entre v√°rios estilos de arquiteturas de API,
                                    existem outros como: SOAP, GraphQL, gRPC e etc... Cada um definem suas regras para a
                                    interface de comunica√ß√£o. REST √© o estilo mais popular e mais adotado no mercado,
                                    por isso, muita gente confunde pensando que api e rest s√£o conceitos equivalentes.
                                </li>
                                <br />

                                <li>
                                    <strong>5. API n√£o √© backend:</strong> A API faz <strong>parte</strong> do teu
                                    backend, mas ela n√£o representa o teu backend. A API √© uma camada respons√°vel expor
                                    dados e funcionalidades do teu backend. A API sozinha n√£o serve pra nada, ela
                                    precisa de um backend e ou uma fonte de dados para expor.
                                </li>

                                <br />

                                <li>
                                    <strong>6. Nem toda API √© web:</strong> Nem toda api √© web, ou seja, nem toda api
                                    utiliza o HTTP para comunica√ß√£o, existem Apis de sistemas locais, APIs que permitem
                                    a comunica√ß√£o entre aplica√ß√µes e o sistema operacional, sem usar rede.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Removendo essas confus√µes de conceitos no meio do caminho, podemos visualizar o destino
                                com mais clareza, uma API n√£o √© nada mais que uma interface de comunica√ß√£o entre
                                softwares.
                            </p>

                            <p>Agora, exemplos reais do que √© uma API:</p>

                            <pre><code>
+----------------------------------------------------------------------------------------------+
| TIPO DE API                  | EXEMPLOS                               | DESCRI√á√ÉO            |
|------------------------------|----------------------------------------|----------------------|
| üåê Web (REST ou HTTP)        | GitHub, OpenWeather, Stripe, Spotify,  | APIs acessadas via   |
|                              | Google Maps                            | internet, trocam     |
|                              |                                        | dados em JSON via    |
|                              |                                        | HTTP (REST, GraphQL) |
|------------------------------|----------------------------------------|----------------------|
| üß© Sistema (locais)          | Win32 (Windows), POSIX (Linux),        | Interfaces entre     |
|                              | Android SDK, Cocoa (macOS)             | apps e o sistema     |
|                              |                                        | operacional. N√£o     |
|                              |                                        | usam HTTP.           |
|------------------------------|----------------------------------------|----------------------|
| üíª Biblioteca (linguagens)   | DOM (JavaScript), os (Python), fs      | APIs usadas dentro   |
|                              | (Node.js)                              | do c√≥digo para       |
|                              |                                        | acessar recursos ou  |
|                              |                                        | fun√ß√µes prontas.     |
|------------------------------|----------------------------------------|----------------------|
| ü§ñ Hardware                  | DirectX, OpenGL, Vulkan, Bluetooth     | APIs que permitem    |
|                              |                                        | apps se comunicarem  |
|                              |                                        | com hardware.        |
+----------------------------------------------------------------------------------------------+</code></pre>
                        </div>

                        <div id="api-rest" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API REST</h1>

                            <p>
                                Uma api rest √© um tipo especifico de api baseado no protocolo HTTP. Rest ‚Äî sigla para
                                Representational State Transfer ‚Äî √â um estilo de arquitetura criado por
                                <a href="https://github.com/royfielding" target="_blank" class="blog-link"
                                    >Roy Fielding</a
                                >
                                em 2000, na sua
                                <a
                                    href="https://ics.uci.edu/~fielding/pubs/dissertation/top.htm"
                                    target="_blank"
                                    class="blog-link"
                                    >tese de doutorado.</a
                                >
                            </p>

                            <p>
                                No final da d√©cada de 1990, <strong>Roy Fielding</strong> fazia parte do grupo
                                respons√°vel por padronizar o protocolo <strong>HTTP</strong> e projetar a arquitetura da
                                Web. Ele foi um dos principais autores da vers√£o 1.1 do HTTP. Essa √©poca representava o
                                in√≠cio da Web moderna, e a comunica√ß√£o entre sistemas na internet ainda era
                                inconsistente ‚Äî cada aplica√ß√£o tinha seu pr√≥prio estilo de API. Fielding percebeu que,
                                para a Web continuar evoluindo, seria necess√°rio definir princ√≠pios arquiteturais claros
                                e universais.
                            </p>

                            <p>
                                Em seus estudos, Roy Fielding analisou por que a Web (baseada em <strong>HTTP</strong>,
                                <strong>URLs</strong> e <strong>HTML</strong>) conseguia escalar para milh√µes de
                                usu√°rios, enquanto outras arquiteturas falhavam. A partir dessas observa√ß√µes, ele
                                definiu um conjunto de princ√≠pios arquiteturais que explicavam o sucesso da Web ‚Äî e
                                chamou esse estilo de <strong>REST</strong>.
                            </p>

                            <p>
                                Uma <strong>API REST</strong> utiliza os recursos da Web para representar entidades do
                                sistema, como usu√°rios, produtos, pedidos, entre outros. Cada recurso √© acessado por
                                meio de uma <strong>URL</strong> (Uniform Resource Locator), e as opera√ß√µes sobre esses
                                recursos s√£o realizadas atrav√©s dos <strong>m√©todos HTTP</strong>.
                            </p>

                            <p>
                                Resumidamente, uma API REST funciona por meio de
                                <strong>requisi√ß√µes</strong> (<em>requests</em>) e
                                <strong>respostas</strong> (<em>responses</em>). A <em>request</em> √© uma chamada HTTP
                                feita pelo cliente, e a <em>response</em> √© a resposta do servidor. O formato de dados
                                mais comum nessa comunica√ß√£o √© o <strong>JSON</strong> (<em
                                    >JavaScript Object Notation</em
                                >).
                            </p>

                            <p>
                                O <strong>REST</strong> foi um dos principais motivos da populariza√ß√£o do
                                <strong>JSON</strong>. Antes dele, o padr√£o dominante era o <strong>SOAP</strong>, que
                                utilizava <strong>XML</strong> para troca de dados. Comparado ao JSON, o XML √© mais
                                <strong>pesado</strong> ‚Äî tanto em tamanho quanto em processamento ‚Äî, pois exige um
                                <em>parsing</em> mais complexo, al√©m de aumentar o tamanho do texto com suas m√∫ltiplas
                                tags, tornando o conte√∫do mais verboso e de leitura dif√≠cil para humanos.
                            </p>

                            <p>
                                O JSON resolveu todos esses problemas e, desde ent√£o, tornou-se o
                                <code>content-type</code> padr√£o nas APIs REST. No entanto, √© importante destacar que o
                                JSON n√£o surgiu junto com o REST. Ele foi criado por
                                <strong>Douglas Crockford</strong> e surgiu integrado ao <strong>JavaScript</strong>,
                                como uma alternativa mais simples e eficiente ao XML. Com o tempo, acabou sendo adotado
                                naturalmente pelas APIs REST devido √† sua leveza e praticidade.
                            </p>

                            <p>
                                A arquitetura <strong>SOAP</strong> (<em>Simple Object Access Protocol</em>) surgiu
                                inicialmente como uma boa ideia em 1998, mas com o tempo acabou se tornando uma
                                <strong>gambiarra completamente invi√°vel</strong>. O SOAP foi uma evolu√ß√£o do protocolo
                                <strong>XML-RPC</strong> (<em>Remote Procedure Call</em> usando XML), criado por
                                <strong>Dave Winer</strong> no mesmo ano. O objetivo do XML-RPC era permitir que um
                                servidor executasse fun√ß√µes em outro servidor, enviando par√¢metros em XML e recebendo
                                respostas tamb√©m em XML ‚Äî tudo isso utilizando o HTTP como transporte.
                            </p>

                            <p>
                                Ainda em 1998, a <strong>Microsoft</strong> e a <strong>IBM</strong> come√ßaram a
                                colaborar na evolu√ß√£o do XML-RPC, dando origem ao SOAP. O objetivo era criar um padr√£o
                                mais formal, extens√≠vel e corporativo para a comunica√ß√£o entre sistemas. Assim, o SOAP
                                incorporou recursos como <strong>tipagem forte</strong> (baseada em XSD),
                                <strong>suporte a headers</strong> (para autentica√ß√£o, transa√ß√µes, etc.),
                                <strong>extensibilidade</strong> (permitindo adicionar metadados sem quebrar o formato)
                                e <strong>ades√£o aos padr√µes do W3C</strong>.
                            </p>

                            <p>
                                Tudo isso parecia uma boa ideia no in√≠cio, mas desmoronou r√°pido. O SOAP acabou se
                                tornando muito mais complicado do que precisava ser. Para fazer uma requisi√ß√£o simples
                                era necess√°rio lidar com estruturas XML enormes, envelopes, cabe√ßalhos e esquemas (XSD).
                                Al√©m disso, o SOAP exigia o uso de ferramentas espec√≠ficas para gerar c√≥digo,
                                interpretar WSDLs (descri√ß√µes de servi√ßo) e lidar com as regras do protocolo ‚Äî o que
                                tornava tudo lento, burocr√°tico e dif√≠cil de manter.
                            </p>

                            <p>
                                Por exemplo, veja como seria uma requisi√ß√£o simples apenas para buscar as informa√ß√µes de
                                um usu√°rio usando o SOAP:
                            </p>

                            <pre><code class="language-xml">
POST /UserService HTTP/1.1
Host: example.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "getUser"

&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Header/&gt;
  &lt;soap:Body&gt;
    &lt;getUserRequest xmlns="http://example.com/user"&gt;
      &lt;userId&gt;123&lt;/userId&gt;
    &lt;/getUserRequest&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre>

                            <p>Agora compare com uma requisi√ß√£o REST que faz exatamente a mesma coisa:</p>

                            <pre><code class="language-http">
GET /users/123 HTTP/1.1
Host: example.com
Accept: application/json
</code></pre>

                            <p>E a resposta do servidor REST seria bem mais simples e leg√≠vel:</p>

                            <pre><code class="language-json">
{
  "id": 123,
  "nome": "Adriel",
  "email": "adriel@example.com"
}
</code></pre>

                            <p>
                                Essa diferen√ßa de simplicidade √© o principal motivo da queda do SOAP e da populariza√ß√£o
                                do REST. Enquanto o SOAP exigia XML pesado, contratos WSDL e m√∫ltiplas camadas de
                                abstra√ß√£o, o REST usa os recursos nativos da Web (HTTP, URLs e JSON), tornando o
                                desenvolvimento muito mais leve, r√°pido e acess√≠vel.
                            </p>

                            <p>
                                O SOUP n√£o foi feito para a web moderna, essa arquitetura n√£o respeita os m√©todos HTTP
                                (GET, POST, PUT, DELETE), utiliza sempre POST nas requisi√ß√µes ‚Äî tratando o http apenas
                                como um t√∫nel de transporte, √© totalmente incompativel com caches HTTP e navegadores. J√°
                                a arquitetura REST, n√£o tenta reinventar a roda, ela engloba todos esses recursos do
                                protocolo HTTP ‚Äî Talvez isso se deve ao fato do criador do Rest ser um dos principais
                                fundadores da vers√£o 1.1 do protoclo http.
                            </p>
                        </div>
                        <div id="stateless-vs-stateful" class="blog-text">
                            <h1 class="h4 portfolio-title">Stateless vS Stateful</h1>
                            <p>
                                Uma das principais caracter√≠sticas da arquitetura REST √© o conceito de
                                <strong>stateless</strong>. Isso significa que o servidor n√£o armazena nenhuma
                                informa√ß√£o sobre o estado da sess√£o do cliente entre as requisi√ß√µes.
                            </p>

                            <p>
                                Em uma arquitetura <strong>stateful</strong>, o servidor precisa manter informa√ß√µes de
                                sess√£o do usu√°rio ‚Äî como dados de autentica√ß√£o ou contexto da intera√ß√£o. Geralmente
                                essas sess√µes s√£o armazenadas em mem√≥ria ou em bancos de dados r√°pidos, como o Redis.
                                Assim, a cada requisi√ß√£o, o servidor consulta o estado previamente salvo para
                                identificar o usu√°rio e continuar o fluxo.
                            </p>

                            <p>
                                J√° em uma API <strong>stateless</strong>, cada requisi√ß√£o deve conter todas as
                                informa√ß√µes necess√°rias para ser processada: autentica√ß√£o, par√¢metros, contexto, entre
                                outros. Um exemplo comum √© o uso de <strong>tokens JWT</strong>, onde o cliente envia o
                                token a cada chamada, permitindo que o servidor valide a requisi√ß√£o sem precisar manter
                                qualquer estado entre uma intera√ß√£o e outra.
                            </p>

                            <p>
                                Atualmente, √© muito mais recomend√°vel implementar uma aplica√ß√£o
                                <strong>stateless</strong> do que <strong>stateful</strong>. Essa prefer√™ncia se deve a
                                v√°rios fatores, tais como:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Escalabilidade muito mais f√°cil:</strong> Como o servidor n√£o mant√©m
                                    informa√ß√µes de sess√£o, qualquer requisi√ß√£o pode ser atendida por qualquer inst√¢ncia
                                    do backend. Isso facilita o balanceamento de carga, auto-escalonamento e a
                                    distribui√ß√£o da aplica√ß√£o em m√∫ltiplos servidores (microservi√ßos).
                                </li>
                                <br />
                                <li>
                                    <strong>2. Redu√ß√£o de complexidade:</strong> Em sistemas stateless n√£o √© necess√°rio
                                    sincronizar sess√µes, manter caches de estado ou usar bancos como Redis apenas para
                                    armazenar informa√ß√µes tempor√°rias dos usu√°rios. O servidor apenas processa
                                    requisi√ß√µes, tornando o sistema mais simples e robusto.
                                </li>
                                <br />
                                <li>
                                    <strong>3. Maior toler√¢ncia a falhas:</strong> Se uma inst√¢ncia cair, nenhuma sess√£o
                                    √© perdida e outra inst√¢ncia pode assumir imediatamente as requisi√ß√µes. Isso aumenta
                                    a disponibilidade e a resili√™ncia do sistema.
                                </li>
                                <br />
                                <li>
                                    <strong>4. Melhor desempenho em alto tr√°fego:</strong> Cada requisi√ß√£o √© processada
                                    de forma independente, sem necessidade de consultar bancos de sess√£o ou mem√≥ria
                                    compartilhada. Isso reduz a lat√™ncia e melhora a performance.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Existem v√°rios motivos pelos quais uma API <strong>stateless</strong> √© muito mais
                                vantajosa do que uma API <strong>stateful</strong>. No entanto, ainda h√° muitos backends
                                web legados, especialmente aqueles baseados em <strong>MVC</strong>, que funcionam de
                                forma totalmente <strong>stateful</strong>. Nesse tipo de aplica√ß√£o, o servidor costuma
                                controlar praticamente tudo: renderiza√ß√£o de HTML, gerenciamento do fluxo da aplica√ß√£o,
                                autentica√ß√£o baseada em sess√£o e outras responsabilidades centrais.
                            </p>

                            <p>
                                Uma observa√ß√£o importante sobre os termos: quando dizemos que um
                                <strong>servidor</strong> √© stateful, isso automaticamente significa que a
                                <strong>API</strong> tamb√©m √© stateful. Embora servidor e API sejam conceitos
                                diferentes, eles est√£o diretamente conectados ‚Äî se o servidor mant√©m estado entre
                                requisi√ß√µes, a API inevitavelmente deixar√° de ser stateless.
                            </p>

                            <p>
                                O pr√≥prio protocolo <strong>HTTP</strong> √© stateless por natureza. Mas √≥bvio, nem tudo
                                √© t√£o simples... Existem algunas cen√°rios especificos onde implementar uma aplica√ß√£o web
                                <strong>stateless</strong> n√£o √© o ideal.
                            </p>
                            <p>
                                Aplica√ß√µes que necessitam de atualiza√ß√£o em tempo real normalmente s√£o
                                <strong>stateful</strong> com o uso de <strong>WebSockets</strong>.
                            </p>

                            <p>
                                Outros exemplos cl√°ssicos de cen√°rios stateful na Web incluem logins baseados em sess√£o,
                                fluxos de m√∫ltiplas etapas (wizards) e sistemas legados que dependem de sess√µes no
                                servidor.
                            </p>

                            <p>
                                Resumidamente, em grande parte das situa√ß√µes ‚Äî provavelmente mais de 90% ‚Äî um
                                desenvolvedor web lidar√° com aplica√ß√µes <strong>stateless</strong> em vez de
                                <strong>stateful</strong>. Ainda assim, tudo depende do contexto. Compreender a
                                diferen√ßa entre esses dois modelos √© essencial para entender o funcionamento da Web
                                moderna e a arquitetura REST.
                            </p>
                        </div>
                    </section>

                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
        <script type="module">
            import { loadSideBarBlog } from '../../assets/js/elements/sidebar.js';

            const sections = [
                { id: 'intro', label: 'Introdu√ß√£o' },
                { id: 'api', label: 'O que √© uma API' },
                { id: 'api-rest', label: 'O que √© uma API REST' },
                { id: 'stateless-vs-stateful', label: 'Stateless vs Stateful' }
            ];

            loadSideBarBlog(sections);
        </script>
    </body>
</html>
