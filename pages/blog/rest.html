<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Rest</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">
                            HTTP e REST na Pr√°tica: Conceitos, Boas Pr√°ticas e Casos Reais
                        </h1>

                        <div>
                            <small style="color: white">10/11/2025</small> -
                            <a
                                href="https://github.com/AdrielSantoss/API-Architectures"
                                target="_blank"
                                class="blog-link"
                                >Projeto (Github)</a
                            >
                        </div>

                        <div class="tags">
                            <small class="tag">Node</small>
                            <small class="tag">Typescript</small>
                            <small class="tag">Arquitetura</small>
                            <small class="tag">Rest</small>
                            <small class="tag">Restful</small>
                            <small class="tag">Fastify</small>
                            <small class="tag">Prisma</small>
                            <small class="tag">ORM</small>
                        </div>
                    </section>

                    <br />

                    <section class="portfolio-description">
                        <div id="intro" class="blog-text">
                            <p>
                                Entre 2019 e 2020, eu desenvolvia diversas APIs REST em Node.js, utilizando o
                                <a href="https://expressjs.com" target="_blank" class="blog-link">Express</a>
                                para criar o servidor HTTP e o ORM
                                <a href="https://knexjs.org" target="_blank" class="blog-link">Knex</a>
                                para modelar as tabelas do banco de dados.
                            </p>

                            <p>
                                Desde ent√£o, acabei me afastando um pouco do ecossistema Node, e nesse meio tempo
                                surgiram (ou se popularizaram) v√°rios frameworks e bibliotecas modernas ‚Äî como o
                                <a href="https://fastify.dev" target="_blank" class="blog-link">Fastify</a>, que oferece
                                uma performance excelente na cria√ß√£o de servidores web, e o ORM
                                <a href="https://www.prisma.io/docs/getting-started" target="_blank" class="blog-link"
                                    >Prisma</a
                                >, que traz uma linguagem de modelagem intuitiva, configura√ß√£o simples e √≥timo
                                desempenho.
                            </p>

                            <p>
                                Naquela √©poca, eu ainda n√£o utilizava TypeScript e recorria ao
                                <a href="https://jestjs.io" target="_blank" class="blog-link">Jest</a>
                                para implementar testes unit√°rios e de integra√ß√£o nas APIs.
                            </p>

                            <p>
                                Hoje percebo que o Knex tem recebido poucas atualiza√ß√µes e parece ter ficado atr√°s do
                                Prisma em termos de recursos e praticidade. O Express continua sendo uma √≥tima escolha,
                                mas o Fastify vem se destacando em performance e escalabilidade. J√° o Jest, por n√£o
                                oferecer suporte nativo a TypeScript em APIs Node, tem perdido espa√ßo para ferramentas
                                mais modernas como o
                                <a href="https://vitest.dev" target="_blank" class="blog-link">Vitest</a>.
                            </p>

                            <p>
                                Na verdade isso √© um processo natural: bibliotecas surgem, se popularizam, e depois de
                                um tempo morrem, perdem espa√ßo para uma nova biblioteca que dominou a √°rea. Por isso, eu
                                n√£o gosto de escrever sobre bibliotecas e frameworks, pois esse conte√∫do costuma se
                                <strong>defazar</strong> muito r√°pido. Nesse blog, o objetivo √© falar sobre conceitos do
                                estilo arquitetural REST, o foco n√£o √© as novas bibliotecas, elas foram apenas o gatilho
                                que me motivou a fazer esse projeto/estudo.
                            </p>

                            <p>
                                A comunidade JavaScript/Node √© extremamente ativa ‚Äî as tecnologias evoluem r√°pido e, na
                                maioria das vezes, para melhor. Por isso, recentemente decidi revisitar meus
                                conhecimentos de REST na pr√°tica, criando um servidor HTTP com Node + TypeScript +
                                Fastify + Prisma + Vitest, entre outras ferramentas.
                            </p>

                            <p>
                                Al√©m de relembrar conceitos, quero aproveitar essa oportunidade para pesquisar e
                                aprender coisas novas sobre desenvolvimento de APIs REST.
                            </p>

                            <p>
                                √â importante destacar que muitos dos conceitos que vou apresentar aqui n√£o pertencem
                                diretamente ao estilo arquitetural REST, mas fazem parte do pr√≥prio protocolo HTTP. Como
                                REST se apoia totalmente no HTTP (e falarei disso mais adiante), torna-se imposs√≠vel
                                explicar REST sem revisitar alguns fundamentos essenciais do protocolo. Por isso,
                                recomendo fortemente que <strong>qualquer pessoa</strong> que pretenda estudar APIs
                                comece entendendo primeiro o funcionamento do protocolo HTTP. (Em um futuro pr√≥ximo,
                                provavelmente farei um estudo detalhado sobre o protocolo HTTP).
                            </p>

                            <p>
                                Nesse artigo vou adentrar em muitos temas densos, como: caching, autentica√ß√£o,
                                permiss√µes e etc. Mas a id√©ia √© fazer um geralz√£o do b√°sico que todo desenvolvedor web
                                deve saber sobre esses temas. Cada tema complexo desses merece um artigo separado, se eu
                                concentrar tudo aqui, viraria um livro e o artigo fugiria do prop√≥sito de REST.
                            </p>
                        </div>

                        <div id="api" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API</h1>

                            <p>
                                Primeiro, devemos entender o que √© uma Api: API √© a sigla para Application Programming
                                Interface (em portugu√™s, Interface de Programa√ß√£o de Aplica√ß√µes).
                            </p>

                            <p>
                                Em resumo, API √© um meio de <strong>comunica√ß√£o</strong> entre dois sistemas, entenda
                                API como um conjunto de regras, protocolos e ferramentas que permite que diferentes
                                softwares se comuniquem e troquem informa√ß√£o.
                            </p>

                            <p>
                                Quando criamos uma API, basicamente estamos criando um tipo de software que define uma
                                <strong>interface</strong> para outros sistemas se comunicarem com ele ‚Äî expondo dados e
                                funcionalidades de forma controlada e padronizada.
                            </p>
                            <p>
                                Quando falamos "interface" j√° vem logo na cabe√ßa as interfaces gr√°ficas, esses erros s√£o
                                comuns para quem est√° come√ßando a entrar no mundo da web, a √°rea da programa√ß√£o possui
                                uma sopa de letrinhas absurda, ent√£o, para n√£o ocorrer confus√µes vamos destacar o que
                                uma API n√£o √©:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Uma api n√£o √© um banco de dados:</strong> Uma API
                                    <strong>acessa</strong> um banco de dados, mas ela n√£o √© o banco de dados. Api,
                                    normalmente n√£o armazenam dados, ela age como um
                                    <strong>intermedi√°rio</strong> entre o cliente e a fonte de dados.
                                </li>
                                <br />

                                <li>
                                    <strong>2. Uma API n√£o √© uma interface gr√°fica (UI):</strong> API significa
                                    Interface de Programa√ß√£o, n√£o Interface de Usu√°rio. Ela n√£o tem bot√µes, telas nem
                                    layouts ‚Äî quem interage com ela s√£o outros programas, n√£o pessoas diretamente.
                                </li>
                                <br />

                                <li>
                                    <strong>3. Uma API n√£o √© um servidor web:</strong> Esse √© um erro
                                    <strong>muito comum</strong>, vejo muitos programadores falando "√§pi √© o servidor da
                                    aplica√ß√£o", isso est√° completamenta <strong>errado</strong>. O servidor (Express,
                                    Django, Laravel e etc) √© quem <strong>hospeda</strong> a API e processa as
                                    requisi√ß√µes. A API √© o conjunto de regras e endpoints implementados
                                    <strong>dentro</strong> desse servidor.
                                </li>
                                <br />

                                <li>
                                    <strong>4. Uma API n√£o √© automaticamente REST:</strong> Esse √© um erro
                                    <strong>cl√°ssico</strong>, REST √© um entre v√°rios estilos de arquiteturas de API,
                                    existem outros como: SOAP, GraphQL, gRPC e etc... Cada um definem suas regras para a
                                    interface de comunica√ß√£o. REST √© o estilo mais popular e mais adotado no mercado,
                                    por isso, muita gente confunde pensando que api e rest s√£o conceitos equivalentes.
                                </li>
                                <br />

                                <li>
                                    <strong>5. API n√£o √© backend:</strong> A API faz <strong>parte</strong> do teu
                                    backend, mas ela n√£o representa o teu backend. A API √© uma camada respons√°vel expor
                                    dados e funcionalidades do teu backend. A API sozinha n√£o serve pra nada, ela
                                    precisa de um backend e ou uma fonte de dados para expor.
                                </li>

                                <br />

                                <li>
                                    <strong>6. Nem toda API √© web:</strong> Nem toda api √© web, ou seja, nem toda api
                                    utiliza o HTTP para comunica√ß√£o, existem Apis de sistemas locais, APIs que permitem
                                    a comunica√ß√£o entre aplica√ß√µes e o sistema operacional, sem usar rede.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Removendo essas confus√µes de conceitos no meio do caminho, podemos visualizar o destino
                                com mais clareza, uma API n√£o √© nada mais que uma interface de comunica√ß√£o entre
                                softwares.
                            </p>

                            <p>Agora, exemplos reais do que √© uma API:</p>

                            <pre><code>
+----------------------------------------------------------------------------------------------+
| TIPO DE API                  | EXEMPLOS                               | DESCRI√á√ÉO            |
|------------------------------|----------------------------------------|----------------------|
| üåê Web (REST ou HTTP)        | GitHub, OpenWeather, Stripe, Spotify,  | APIs acessadas via   |
|                              | Google Maps                            | internet, trocam     |
|                              |                                        | dados em JSON via    |
|                              |                                        | HTTP (REST, GraphQL) |
|------------------------------|----------------------------------------|----------------------|
| üß© Sistema (locais)          | Win32 (Windows), POSIX (Linux),        | Interfaces entre     |
|                              | Android SDK, Cocoa (macOS)             | apps e o sistema     |
|                              |                                        | operacional. N√£o     |
|                              |                                        | usam HTTP.           |
|------------------------------|----------------------------------------|----------------------|
| üíª Biblioteca (linguagens)   | DOM (JavaScript), os (Python), fs      | APIs usadas dentro   |
|                              | (Node.js)                              | do c√≥digo para       |
|                              |                                        | acessar recursos ou  |
|                              |                                        | fun√ß√µes prontas.     |
|------------------------------|----------------------------------------|----------------------|
| ü§ñ Hardware                  | DirectX, OpenGL, Vulkan, Bluetooth     | APIs que permitem    |
|                              |                                        | apps se comunicarem  |
|                              |                                        | com hardware.        |
+----------------------------------------------------------------------------------------------+</code></pre>
                        </div>

                        <div id="api-rest" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API REST/RESTFUL</h1>

                            <p>
                                Uma API REST √© um tipo espec√≠fico de API baseada no protocolo HTTP e fundamentada na
                                arquitetura cliente-servidor. REST ‚Äî sigla para Representational State Transfer ‚Äî √© um
                                estilo de arquitetura criado por
                                <a href="https://github.com/royfielding" target="_blank" class="blog-link"
                                    >Roy Fielding</a
                                >
                                em 2000, na sua
                                <a
                                    href="https://roy.gbiv.com/pubs/dissertation/fielding_dissertation.pdf?utm_source=chatgpt.com"
                                    target="_blank"
                                    class="blog-link"
                                    >tese de doutorado.</a
                                >
                            </p>

                            <p>
                                Embora o termo ‚Äúarquitetura REST‚Äù seja comum no mercado, tecnicamente REST
                                <strong>n√£o √© uma arquitetura em si</strong> , mas sim um
                                <strong>estilo arquitetural</strong> composto por restri√ß√µes aplicadas sobre uma
                                arquitetura cliente-servidor. Ele orienta o design de sistemas distribu√≠dos, mas n√£o
                                define por completo a arquitetura de uma aplica√ß√£o. Entenda que arquitetura √© o projeto
                                e um estilo arquitetural s√£o as regras definidas para construir esse projeto ‚Äî Rest √©
                                exatamente isso, um conjunto de regras que orientam a cria√ß√£o de uma aplica√ß√£o
                                cliente-servidor.
                            </p>

                            <p>
                                No final da d√©cada de 1990, <strong>Roy Fielding</strong> fazia parte do grupo
                                respons√°vel por padronizar o protocolo <strong>HTTP</strong> e projetar a arquitetura da
                                Web. Ele foi um dos principais autores da vers√£o 1.1 do HTTP. Essa √©poca representava o
                                in√≠cio da Web moderna, e a comunica√ß√£o entre sistemas na internet ainda era
                                inconsistente ‚Äî cada aplica√ß√£o tinha seu pr√≥prio estilo de API. Fielding percebeu que,
                                para a Web continuar evoluindo, seria necess√°rio definir princ√≠pios arquiteturais claros
                                e universais.
                            </p>

                            <p>
                                Em seus estudos, Roy Fielding analisou por que a Web (baseada em <strong>HTTP</strong>,
                                <strong>URLs</strong> e <strong>HTML</strong>) conseguia escalar para milh√µes de
                                usu√°rios, enquanto outras arquiteturas falhavam. A partir dessas observa√ß√µes, ele
                                definiu um conjunto de princ√≠pios arquiteturais que explicavam o sucesso da Web ‚Äî e
                                chamou esse estilo de <strong>REST</strong>.
                            </p>

                            <p>
                                Uma <strong>API REST</strong> utiliza os recursos da Web para representar entidades do
                                sistema, como usu√°rios, produtos, pedidos, entre outros. Cada recurso √© acessado por
                                meio de uma <strong>URL</strong> (Uniform Resource Locator), e as opera√ß√µes sobre esses
                                recursos s√£o realizadas atrav√©s dos <strong>m√©todos HTTP</strong>.
                            </p>

                            <p>
                                Resumidamente, uma API REST funciona por meio de
                                <strong>requisi√ß√µes</strong> (<em>requests</em>) e
                                <strong>respostas</strong> (<em>responses</em>). A <em>request</em> √© uma chamada HTTP
                                feita pelo cliente, e a <em>response</em> √© a resposta do servidor. O formato de dados
                                mais comum nessa comunica√ß√£o √© o <strong>JSON</strong> (<em
                                    >JavaScript Object Notation</em
                                >).
                            </p>

                            <p>
                                O <strong>REST</strong> foi um dos principais motivos da populariza√ß√£o do
                                <strong>JSON</strong>. Antes dele, o padr√£o dominante era o <strong>SOAP</strong>, que
                                utilizava <strong>XML</strong> para troca de dados. Comparado ao JSON, o XML √© mais
                                <strong>pesado</strong> ‚Äî tanto em tamanho quanto em processamento ‚Äî, pois exige um
                                <em>parsing</em> mais complexo, al√©m de aumentar o tamanho do texto com suas m√∫ltiplas
                                tags, tornando o conte√∫do mais verboso e de leitura dif√≠cil para humanos.
                            </p>

                            <p>
                                O JSON resolveu todos esses problemas e, desde ent√£o, tornou-se o
                                <code>content-type</code> padr√£o nas APIs REST. No entanto, √© importante destacar que o
                                JSON n√£o surgiu junto com o REST. Ele foi criado por
                                <strong>Douglas Crockford</strong> e surgiu integrado ao <strong>JavaScript</strong>,
                                como uma alternativa mais simples e eficiente ao XML. Com o tempo, acabou sendo adotado
                                naturalmente pelas APIs REST devido √† sua leveza e praticidade.
                            </p>

                            <p>
                                O estilo arquitetural <strong>SOAP</strong> (<em>Simple Object Access Protocol</em>)
                                surgiu inicialmente como uma boa ideia em 1998, mas com o tempo acabou se tornando uma
                                <strong>gambiarra completamente invi√°vel</strong>. O SOAP foi uma evolu√ß√£o do protocolo
                                <strong>XML-RPC</strong> (<em>Remote Procedure Call</em> usando XML), criado por
                                <strong>Dave Winer</strong> no mesmo ano. O objetivo do XML-RPC era permitir que um
                                servidor executasse fun√ß√µes em outro servidor, enviando par√¢metros em XML e recebendo
                                respostas tamb√©m em XML ‚Äî tudo isso utilizando o HTTP como transporte.
                            </p>

                            <p>
                                Ainda em 1998, a <strong>Microsoft</strong> e a <strong>IBM</strong> come√ßaram a
                                colaborar na evolu√ß√£o do XML-RPC, dando origem ao SOAP. O objetivo era criar um padr√£o
                                mais formal, extens√≠vel e corporativo para a comunica√ß√£o entre sistemas. Assim, o SOAP
                                incorporou recursos como <strong>tipagem forte</strong> (baseada em XSD),
                                <strong>suporte a headers</strong> (para autentica√ß√£o, transa√ß√µes, etc.),
                                <strong>extensibilidade</strong> (permitindo adicionar metadados sem quebrar o formato)
                                e <strong>ades√£o aos padr√µes do W3C</strong>.
                            </p>

                            <p>
                                Tudo isso parecia uma boa ideia no in√≠cio, mas desmoronou r√°pido. O SOAP acabou se
                                tornando muito mais complicado do que precisava ser. Para fazer uma requisi√ß√£o simples
                                era necess√°rio lidar com estruturas XML enormes, envelopes, cabe√ßalhos e esquemas (XSD).
                                Al√©m disso, o SOAP exigia o uso de ferramentas espec√≠ficas para gerar c√≥digo,
                                interpretar WSDLs (descri√ß√µes de servi√ßo) e lidar com as regras do protocolo ‚Äî o que
                                tornava tudo lento, burocr√°tico e dif√≠cil de manter.
                            </p>

                            <p>
                                Por exemplo, veja como seria uma requisi√ß√£o simples apenas para buscar as informa√ß√µes de
                                um usu√°rio usando o SOAP:
                            </p>

                            <pre><code class="language-xml">
POST /UserService HTTP/1.1
Host: example.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "getUser"

&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Header/&gt;
  &lt;soap:Body&gt;
    &lt;getUserRequest xmlns="http://example.com/user"&gt;
      &lt;userId&gt;123&lt;/userId&gt;
    &lt;/getUserRequest&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre>

                            <p>Agora compare com uma requisi√ß√£o REST que faz exatamente a mesma coisa:</p>

                            <pre><code class="language-http">
GET /users/123 HTTP/1.1
Host: example.com
Accept: application/json
</code></pre>

                            <p>E a resposta do servidor REST seria bem mais simples e leg√≠vel:</p>

                            <pre><code class="language-json">
{
  "id": 123,
  "nome": "Adriel",
  "email": "adriel@example.com"
}
</code></pre>

                            <p>
                                Essa diferen√ßa de simplicidade √© o principal motivo da queda do SOAP e da populariza√ß√£o
                                do REST. Enquanto o SOAP exigia XML pesado, contratos WSDL e m√∫ltiplas camadas de
                                abstra√ß√£o, o REST usa os recursos nativos da Web (HTTP, URLs e JSON), tornando o
                                desenvolvimento muito mais leve, r√°pido e acess√≠vel.
                            </p>

                            <p>
                                O SOUP n√£o foi feito para a web moderna, essa arquitetura n√£o respeita os m√©todos HTTP
                                (GET, POST, PUT, DELETE), utiliza sempre POST nas requisi√ß√µes ‚Äî tratando o http apenas
                                como um t√∫nel de transporte, √© totalmente incompativel com caches HTTP e navegadores. J√°
                                REST, n√£o tenta reinventar a roda, ela engloba todos esses recursos do protocolo HTTP ‚Äî
                                Talvez isso se deve ao fato do criador do Rest ser um dos principais fundadores da
                                vers√£o 1.1 do protoclo http.
                            </p>
                        </div>
                        <div id="stateless-vs-stateful" class="blog-text">
                            <h1 class="h4 portfolio-title">Stateless vS Stateful</h1>
                            <p>
                                Uma das principais caracter√≠sticas do REST √© o conceito de
                                <strong>stateless</strong>. Isso significa que o servidor n√£o armazena nenhuma
                                informa√ß√£o sobre o estado da sess√£o do cliente entre as requisi√ß√µes.
                            </p>

                            <p>
                                Em uma arquitetura <strong>stateful</strong>, o servidor precisa manter informa√ß√µes de
                                sess√£o do usu√°rio ‚Äî como dados de autentica√ß√£o ou contexto da intera√ß√£o. Geralmente
                                essas sess√µes s√£o armazenadas em mem√≥ria ou em bancos de dados r√°pidos, como o Redis.
                                Assim, a cada requisi√ß√£o, o servidor consulta o estado previamente salvo para
                                identificar o usu√°rio e continuar o fluxo.
                            </p>

                            <p>
                                J√° em uma API <strong>stateless</strong>, cada requisi√ß√£o deve conter todas as
                                informa√ß√µes necess√°rias para ser processada: autentica√ß√£o, par√¢metros, contexto, entre
                                outros. Um exemplo comum √© o uso de <strong>tokens JWT</strong>, onde o cliente envia o
                                token a cada chamada, permitindo que o servidor valide a requisi√ß√£o sem precisar manter
                                qualquer estado entre uma intera√ß√£o e outra.
                            </p>

                            <p>
                                Atualmente, √© muito mais recomend√°vel implementar uma aplica√ß√£o
                                <strong>stateless</strong> do que <strong>stateful</strong>. Essa prefer√™ncia se deve a
                                v√°rios fatores, tais como:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Escalabilidade muito mais f√°cil:</strong> Como o servidor n√£o mant√©m
                                    informa√ß√µes de sess√£o, qualquer requisi√ß√£o pode ser atendida por qualquer inst√¢ncia
                                    do backend. Isso facilita o balanceamento de carga, auto-escalonamento e a
                                    distribui√ß√£o da aplica√ß√£o em m√∫ltiplos servidores (microservi√ßos).
                                </li>
                                <br />
                                <li>
                                    <strong>2. Redu√ß√£o de complexidade:</strong> Em sistemas stateless n√£o √© necess√°rio
                                    sincronizar sess√µes, manter caches de estado ou usar bancos como Redis apenas para
                                    armazenar informa√ß√µes tempor√°rias dos usu√°rios. O servidor apenas processa
                                    requisi√ß√µes, tornando o sistema mais simples e robusto.
                                </li>
                                <br />
                                <li>
                                    <strong>3. Maior toler√¢ncia a falhas:</strong> Se uma inst√¢ncia cair, nenhuma sess√£o
                                    √© perdida e outra inst√¢ncia pode assumir imediatamente as requisi√ß√µes. Isso aumenta
                                    a disponibilidade e a resili√™ncia do sistema.
                                </li>
                                <br />
                                <li>
                                    <strong>4. Melhor desempenho em alto tr√°fego:</strong> Cada requisi√ß√£o √© processada
                                    de forma independente, sem necessidade de consultar bancos de sess√£o ou mem√≥ria
                                    compartilhada. Isso reduz a lat√™ncia e melhora a performance.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Existem v√°rios motivos pelos quais uma API <strong>stateless</strong> √© muito mais
                                vantajosa do que uma API <strong>stateful</strong>. No entanto, ainda h√° muitos backends
                                web legados, especialmente aqueles baseados em <strong>MVC</strong>, que funcionam de
                                forma totalmente <strong>stateful</strong>. Nesse tipo de aplica√ß√£o, o servidor costuma
                                controlar praticamente tudo: renderiza√ß√£o de HTML, gerenciamento do fluxo da aplica√ß√£o,
                                autentica√ß√£o baseada em sess√£o e outras responsabilidades centrais.
                            </p>

                            <p>
                                Uma observa√ß√£o importante sobre os termos: quando dizemos que um
                                <strong>servidor</strong> √© stateful, isso automaticamente significa que a
                                <strong>API</strong> tamb√©m √© stateful. Embora servidor e API sejam conceitos
                                diferentes, eles est√£o diretamente conectados ‚Äî se o servidor mant√©m estado entre
                                requisi√ß√µes, a API inevitavelmente deixar√° de ser stateless.
                            </p>

                            <p>
                                O pr√≥prio protocolo <strong>HTTP</strong> √© stateless por natureza. Mas √≥bvio, nem tudo
                                √© t√£o simples... Existem algunas cen√°rios especificos onde implementar uma aplica√ß√£o web
                                <strong>stateless</strong> n√£o √© o ideal.
                            </p>
                            <p>
                                Aplica√ß√µes que necessitam de atualiza√ß√£o em tempo real normalmente s√£o
                                <strong>stateful</strong> com o uso de <strong>WebSockets</strong>.
                            </p>

                            <p>
                                Outros exemplos cl√°ssicos de cen√°rios stateful na Web incluem logins baseados em sess√£o,
                                fluxos de m√∫ltiplas etapas (wizards) e sistemas legados que dependem de sess√µes no
                                servidor.
                            </p>

                            <p>
                                Resumidamente, em grande parte das situa√ß√µes ‚Äî provavelmente mais de 90% ‚Äî um
                                desenvolvedor web lidar√° com aplica√ß√µes <strong>stateless</strong> em vez de
                                <strong>stateful</strong>. Ainda assim, tudo depende do contexto. Compreender a
                                diferen√ßa entre esses dois modelos √© essencial para entender o funcionamento da Web
                                moderna e REST.
                            </p>
                        </div>

                        <div id="get" class="blog-text">
                            <h1 class="h4 portfolio-title">GET</h1>

                            <p>
                                Agora vou demonstrar os recursos do REST na pr√°tica em uma api NODE com typescript,
                                utilizando o framework <strong>Fastify</strong> e as demais bibliotecas j√° mencionadas.
                            </p>
                            <p>
                                Vou me concentrar mais na parte da api, ignorando coisas como banco de dados, ORMS e
                                etc.
                            </p>

                            <p>
                                Uma API REST √© orientada a recursos. Isso significa que, para acessar um determinado
                                recurso (como registros de usu√°rios, por exemplo), √© necess√°rio fazer uma chamada HTTP
                                para uma URI espec√≠fica.
                            </p>

                            <p>
                                Com o fastify vou criar as <strong>endpoints</strong> da API. Um endpoint √© um ponto de
                                entrada da API, definido pela combina√ß√£o entre um m√©todo HTTP e uma URI espec√≠fica. A
                                URI (Uniform Resource Identifier) √© o identificador que aponta para um recurso ‚Äî como
                                <code>/users</code>, <code>/products/10</code> ou <code>/auth/login</code>. Cada
                                endpoint da API possui sua pr√≥pria URI, que indica ao cliente exatamente qual recurso
                                est√° sendo acessado ou qual a√ß√£o ser√° executada. Em conjunto, m√©todo + URI determinam o
                                comportamento do endpoint e como a aplica√ß√£o ir√° responder a cada requisi√ß√£o.
                            </p>

                            <p>Exemplo de uma API com alguns endpoints (cada linha exibe a URI da endpoint):</p>

                            <pre><code class="language-json">
https://app.io/usuarios      ‚Üí URL do recurso "usuarios"
https://app.io/usuarios/12   ‚Üí URL do recurso "usuarios" com ID 12
https://app.io/boardgames    ‚Üí URL do recurso "boardgames"
</code></pre>

                            <p>
                                Para obter esses recursos em formato JSON, basta realizar uma requisi√ß√£o HTTP com o
                                verbo <strong>GET</strong>.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Route Params</h1>

                            <p>
                                Note a diferen√ßa entre a primeira e a segunda URL: a primeira retorna
                                <strong>todos</strong> os usu√°rios do banco de dados (ou de qualquer outra fonte que a
                                API consulte), enquanto a segunda retorna apenas um usu√°rio espec√≠fico. Essa √© a forma
                                mais comum de filtrar um recurso espec√≠fico na API, utilizando um
                                <strong>Route Param</strong>.
                            </p>

                            <p>
                                Route params, como o pr√≥prio nome sugere, s√£o par√¢metros
                                <strong>obrigat√≥rios</strong> da rota e aparecem na pr√≥pria URL. Em uma URL, tudo √©
                                sempre tratado como <strong>texto</strong>; ou seja, n√£o existe tipagem na URL em si. A
                                convers√£o do valor para um tipo espec√≠fico (como n√∫mero, boolean, etc.) √©
                                responsabilidade do framework da API.
                            </p>

                            <p>Veja este exemplo:</p>

                            <details>
                                <summary>Declarando uma endpoint com Node.js e Fastify</summary>
                                <p><code>app</code> √© a inst√¢ncia da API utilizando Fastify.</p>
                                <pre><code>
app.get(
    '/usuarios/:id',
    {
        schema: {
            params: {
                type: 'object',
                properties: {
                    id: { type: 'number', minimum: 0 }
                },
                required: ['id']
            }
        }
    },
    async (request, reply) => userController.getUsuarioById(request, reply)
);
    </code></pre>
                            </details>

                            <p>
                                No c√≥digo acima, estou declarando uma rota e definindo o tipo do par√¢metro
                                <code>:id</code> para que o <strong>Fastify</strong> fa√ßa a convers√£o e valida√ß√£o.
                                Tamb√©m foi definida uma regra (<code>minimum: 0</code>), e o pr√≥prio Fastify realizar√° a
                                valida√ß√£o automaticamente, retornando uma exce√ß√£o <strong>400</strong>
                                caso a regra seja violada.
                            </p>

                            <p>
                                Em termos conceituais, em uma URL absolutamente tudo √© representado como texto. Isso
                                acontece porque a URL √© apenas uma <strong>string codificada</strong> que o navegador
                                envia ao servidor. Mesmo que voc√™ escreva valores que parecem num√©ricos, como
                                <code>/usuarios/10</code> ou <code>/produtos/29.90</code>, eles ainda chegam para a API
                                como texto puro. Por exemplo, a URL <code>/calcular/2/3</code> envia os valores
                                <code>"2"</code> e <code>"3"</code> (como strings), e somente depois o framework
                                converte esses dados para <code>number</code>, <code>float</code>,
                                <code>boolean</code> ou qualquer outro tipo que voc√™ tenha definido.
                            </p>
                            <p>
                                Outro exemplo: se voc√™ enviar um nome com espa√ßo, como
                                <code>/usuarios/joao silva</code>, o navegador transforma isso em
                                <code>/usuarios/joao%20silva</code>, que tamb√©m √© apenas texto codificado. Portanto, a
                                URL por si s√≥ n√£o entende tipos ‚Äî ela transporta apenas strings, e cabe √† API
                                interpretar, validar e converter para o tipo apropriado.
                            </p>

                            <p>
                                Sobre boas pr√°ticas, recomenda-se que rotas sejam sempre nomeadas no
                                <strong>plural</strong> quando representam cole√ß√µes (ex.: <code>/usuarios</code>,
                                <code>/produtos</code>), e que route params sejam escritos no singular, representando um
                                item espec√≠fico da cole√ß√£o (ex.: <code>/usuarios/:id</code>).
                            </p>

                            <p>
                                Um "erro" muito comum em iniciante, √© criar uma rota no singular quando a mesma possui
                                um route param. Exemplo:
                            </p>

                            <pre><code>
https://app.io/usuarios     ‚Üí URL do recurso "usuarios"
https://app.io/usuario/12   ‚Üí URL do recurso "usuarios" com ID 12 (singular, pr√°tica incomum)
    </code></pre>

                            <p>
                                Isso n√£o √© um erro critico, ou algo que vai prejudicar sua API REST. Essas regras de
                                boas pr√°ticas n√£o foram definidas por algu√©m em especifico, n√£o existe na tese de Roy
                                Fielding um capitulo sobre "regras de nomeclaturas e mapeamentos" ou algo assim, isso
                                tudo √© um conjunto de conven√ß√µes amplamente aceitas pela comunidade REST ao longo dos
                                anos. Quando falamos de REST, quanto mais seguimos dentro desses padr√µes, melhor ser√° a
                                qualidade geral do c√≥digo da API.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Query Params</h1>

                            <p>
                                Outra forma de enviar par√¢metros em uma requisi√ß√£o GET √© usando
                                <strong>query params</strong>. A principal diferen√ßa entre query params e route params
                                est√° na <strong>obrigatoriedade</strong>. Route params fazem parte da estrutura da URL,
                                portanto s√£o obrigat√≥rios. J√° os query params s√£o opcionais por natureza ‚Äî eles s√≥ se
                                tornam obrigat√≥rios se voc√™ aplicar uma valida√ß√£o manual no seu backend.
                            </p>

                            <p>
                                Query params permitem enviar m√∫ltiplos par√¢metros com diferentes finalidades, como
                                filtros, pagina√ß√£o, ordena√ß√£o, busca textual, entre outros. Por exemplo:
                            </p>

                            <pre><code>
https://app.io/usuarios?nome=adriel&orderby=idade
‚Üí URL do recurso "usuarios", filtrando pelo nome "adriel" e ordenando por "idade".
</code></pre>

                            <p>
                                Diferentemente dos route params, que identificam um recurso espec√≠fico, os query params
                                n√£o alteram a identidade do recurso, apenas modificam a forma como o recurso ser√°
                                retornado ‚Äî por exemplo, filtrando, ordenando ou paginando os resultados. Essa diferen√ßa
                                √© importante para a consist√™ncia do design de APIs REST.
                            </p>

                            <p>
                                J√° me deparei com algumas aplica√ß√µes trafegando tokens, senhas e outras informa√ß√µes
                                sensiveis por query params. Obviamente isso √© uma pr√°tica <strong>ruim</strong> ‚Äî para
                                dizer o minimo. URLs podem vazar em: hist√≥ricos, logs de servidor, analytics, cache do
                                navegador e etc. Query params serve para compartilhar informa√ß√µes opcionais cujo o
                                objetivo √© refinar, filtrar ou alterar a resposta.
                            </p>

                            <p>Em query params √© possivel compartilhar listas, os principais padr√µes s√£o:</p>

                            <pre><code>
a) Repetindo a chave:

?categoria=acao&categoria=rpg&categoria=terror


b) Listas separadas por v√≠rgula:

?categoria=acao,rpg,terror


c) Arrays com sintaxe:

?categoria[]=acao&categoria[]=rpg</code></pre>

                            <p>
                                Mas cuidado, evite transformar URLS em um payload com enorme quantidade de informa√ß√£o.
                                Browsers normalmente suportam aproximadamente <strong>2000 caracteres</strong>.
                            </p>

                            <p>
                                Outra pr√°tica comum em query params s√£o os operadores expl√≠citos como
                                <code>gte</code> (maior ou igual), <code>lte</code> (menor ou igual),
                                <code>ne</code> (diferente) ou <code>in</code>. Um formato bastante usado √© o estilo
                                inspirado em
                                <a
                                    href="https://www.mongodb.com/pt-br/docs/manual/reference/mql/query-predicates/comparison"
                                    target="_blank"
                                    class="blog-link"
                                    >MongoDB</a
                                >: <code>?preco[gte]=100&amp;preco[lte]=300</code>. APIs mais simples usam conven√ß√µes
                                como <code>?minPreco=100&amp;maxPreco=300</code>. Exemplos:
                            </p>

                            <pre><code>
/usuarios?idade=30                    ‚Üí igualdade
/usuarios?idade[gte]=18               ‚Üí maior ou igual a 18
/usuarios?idade[lte]=65               ‚Üí menor ou igual a 65
/produtos?preco[gte]=10&preco[lte]=50 ‚Üí intervalo
</code></pre>

                            <p>
                                √â importante ressaltar que <strong>query params</strong> e
                                <strong>route params</strong> n√£o s√£o funcionalidades criadas pelo estilo arquitetural
                                REST. Na verdade, eles fazem parte da pr√≥pria especifica√ß√£o de URLs definida pelas RFCs
                                que padronizam a Web. Os <em>route params</em> s√£o apenas trechos vari√°veis do caminho
                                (path) da URL, definidos pela aplica√ß√£o, enquanto os <em>query params</em> s√£o
                                par√¢metros opcionais definidos pela
                                <a
                                    href="https://datatracker.ietf.org/doc/html/rfc3986"
                                    target="_blank"
                                    class="blog-link"
                                    >RFC 3986</a
                                >
                                para transmitir dados na parte ap√≥s o caractere <code>?</code>. Portanto, REST apenas
                                utiliza esses recursos j√° existentes na arquitetura da Web, mas n√£o os define.
                            </p>

                            <details>
                                <summary>Declarando um endpoint com query params</summary>
                                <pre><code>
app.get(
    '/usuarios',
    {
        schema: {
            querystring: {
                type: 'object',
                properties: {
                    page: { type: 'integer', minimum: 1, default: 1 },
                    limit: {
                        type: 'integer',
                        minimum: 1,
                        maximum: 10,
                        default: 10,
                    },
                },
            },
        },
    },
    async (request, reply) => userController.getUsuarios(request, reply)
);</code></pre>
                            </details>

                            <h1 class="h4 portfolio-title">GET - Pagina√ß√£o</h1>

                            <p>
                                A pagina√ß√£o √© uma t√©cnica usada para <strong>controlar</strong> a quantidade de dados
                                retornados em uma requisi√ß√£o. Sem ela, uma endpoint poderia enviar milhares de registros
                                de uma s√≥ vez, o que causaria diversos problemas: lentid√£o no servidor, uso excessivo de
                                banda, respostas muito grandes e um custo de processamento do payload muito alto no
                                client.
                            </p>

                            <p>
                                Existem v√°rias estrat√©gias de pagina√ß√£o, mas as mais comuns s√£o:
                                <strong>Offset Pagination</strong> e <strong>Keyset Pagination</strong>.
                            </p>

                            <p>
                                Na <strong>offset pagination</strong>, o servidor pula um conjunto de registros (offset)
                                e retorna um n√∫mero fixo de itens (limit). offset e limit, s√£o definidos como
                                <strong>query params</strong>. O par√¢metro <strong>page</strong> determina qual
                                <strong>p√°gina</strong> de resultados ser√° retornada, enquanto
                                <strong>limit</strong> define a <strong>quantidade</strong> de itens por p√°gina.
                            </p>

                            <p><strong>Exemplo de URL com pagina√ß√£o:</strong></p>

                            <pre><code >GET https://api.exemplo.com/usuarios?page=2&limit=10
</code></pre>

                            <p>Nesse caso, a API retornaria a segunda p√°gina contendo at√© 10 usu√°rios por p√°gina.</p>

                            <p>
                                Vale ressaltar que a pagina√ß√£o n√£o √© um recurso obrigat√≥rio para a endpoint funcionar.
                                Ou seja, caso o client n√£o envie os par√¢metros de pagina√ß√£o para a API, ela deve assumir
                                valores padr√£o, como por exemplo: <code>offset: 0</code> e <code>limit: 50</code>.
                            </p>

                            <p>
                                A pagina√ß√£o n√£o entra em conflito com os demais par√¢metros da query; portanto, a mesma
                                endpoint pode conter simultaneamente pagina√ß√£o e filtros.
                            </p>

                            <p>
                                A f√≥rmula para obter exatamente a p√°gina especificada pelo usu√°rio √© a seguinte:
                                <code>(page - 1) * limit</code>. Ap√≥s calcular esse valor, basta limitar o resultado
                                pela quantidade definida em <code>limit</code>.
                            </p>

                            <p>Veja um exemplo pr√°tico dessa f√≥rmula aplicada no ORM Prisma:</p>

                            <code>
                                <pre>
async getUsuarios(page: number, limit: number) {
    return await prisma.usuario.findMany({
        skip: (page - 1) * limit, // pulando (page - 1) p√°ginas
        take: limit,              // obtendo apenas a quantidade definida em limit
    });
}
</pre
                                >
                            </code>

                            <br />

                            <p>
                                A principal desvantagem dessa estrat√©gia √© a queda de desempenho em tabelas com grande
                                volume de dados. Um valor muito alto de <code>offset</code> pode tornar o processamento
                                lento, pois o banco precisa percorrer muitos registros antes de retornar os resultados.
                                Essa abordagem √© recomendada para datasets pequenos ou m√©dios, oferecendo boa precis√£o
                                de busca para o client.
                            </p>

                            <p>Veja o fluxo completo da cria√ß√£o de uma pagina√ß√£o em uma API node com fastify:</p>

                            <details>
                                <summary>Declarando a endpoint /usuarios com os par√¢metros "page" e "limit"</summary>
                                <pre><code>
app.get(
    '/usuarios',
    {
        schema: {
            querystring: {
                type: 'object',
                properties: {
                    page: { type: 'integer', minimum: 1, default: 1 },
                    limit: {
                        type: 'integer',
                        minimum: 1,
                        maximum: 10,
                        default: 10,
                    },
                },
            },
        },
    },
    async (request, reply) => userController.getUsuarios(request, reply)
);</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioController.ts</summary>
                                <pre><code>
async getUsuarios(
    request: FastifyRequest,
    reply: FastifyReply
): Promise&lt;UsuariosDto | undefined&gt; {
    try {
        const queryParams = request.query as {
            page?: string;
            limit?: string;
        };

        return reply.send(
            await this.usuarioService.getUsuarios(
                Number(queryParams.page),
                Number(queryParams.limit)
            )
        );
    } catch (error) {
        this.throwResponseException(error, reply);
    }
}
</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioService.ts</summary>
                                <p>
                                    Al√©m da pagina√ß√£o, implementei o <code>lookahead</code> que √© uma propriedade que
                                    sinaliza para o client a exist√™ncia da pr√≥xima p√°gina (hasNextPage).
                                </p>
                                <pre><code>
async getUsuarios(
    page: number,
    limit: number
): Promise&lt;UsuariosDto | null&gt; {
    try {
        // Offset pagination with lookahead
        const usuarios = await this.usuarioRepository.getUsuarios(
            page,
            limit
        );
        const hasNextPage = usuarios.length == limit + 1;

        usuarios.pop();

        const usuariosDto = {
            data: usuarios,
            meta: {
                page,
                limit,
                hasNextPage: hasNextPage,
            },
        } as UsuariosDto;

        return usuariosDto;
    } catch (error) {
        console.error('Erro interno ao consultar os usu√°rios.', error);

        throw new InternalError();
    }
}
</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioRepository.ts</summary>
                                <p>
                                    Aqui, √© onde aplicamos a "f√≥rmula" da pagina√ß√£o, skipando os elementos e retornando
                                    apenas os especificados pelos par√¢metros da pagina√ß√£o.
                                </p>
                                <pre><code>
async getUsuarios(page: number, limit: number) {
    return await prisma.usuario.findMany({
        skip: (page - 1) * limit,
        take: limit + 1,
    });
}
</code></pre>
                            </details>

                            <p>
                                A outra estrat√©gia de pagina√ß√£o popular em API REST √© o
                                <strong>Keyset Pagination</strong> (tamb√©m chamada de <i>Cursor based pagination</i>).
                                Essa estrat√©gia consistem em navegar entre dos dados utilizando uma
                                <strong>chave de refer√™ncia</strong> ‚Äî normalmente o valor de uma coluna ordenada e
                                indexada, como id, created_at ou outra coluna monotonicamente crescente.
                            </p>

                            <p>Veja esse exemplo de keyset pagination:</p>

                            <pre><code>
Endpoint:
GET /items?limit=10

Response:
{
  "items": [...],
  "nextCursor": "2025-01-10T14:03:22Z"
}

Pr√≥ximo request:
GET /items?limit=10&cursor=2025-01-10T14:03:22Z

Query no backend:
SELECT *
FROM items
WHERE created_at > :cursor
ORDER BY created_at ASC
LIMIT 10;

Exemplo com ORM:
async getBoardgames(createdAt: Date | undefined, limit: number) {
    return await prisma.boardgame.findMany({
        where: {
            createdAt: {
                gte: createdAt,
            },
        },
        take: limit + 1,
    });
}
</code></pre>

                            <p>
                                Perceba que a consulta √© feita considerando apenas os dados criados ap√≥s a √∫ltima chave
                                recebida (<code>created_at > :cursor</code>). Com isso, evita-se o problema de
                                performance do offset pagination: nenhuma informa√ß√£o desnecess√°ria √© percorrida ou
                                ignorada manualmente (skip), tornando a pagina√ß√£o muito mais eficiente.
                            </p>

                            <p>
                                Normalmente, a estrat√©gia mais utilizada √© a keyset pagination, por ser melhor em termos
                                de perfomance.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Caching</h1>

                            <p>
                                Cache √© um recurso utilizado para melhorar o desempenho da aplica√ß√£o, reduzindo o n√∫mero
                                de acessos ao banco de dados e acelerando o tempo de resposta das requisi√ß√µes.
                            </p>

                            <p>
                                Esse tema √© extenso, para falar de maneira completa precisaria de um artigo somente
                                dedicado a este tema, mas aqui vou apenas resumir um pouco dos conceitos e pr√°ticas.
                            </p>

                            <p>
                                Essa funcionalidade consiste em armazenar os dados requisitados em um banco de dados em
                                <strong>mem√≥ria</strong>. O mais comum √© usar o
                                <a href="https://redis.io" target="_blank" class="blog-link">Redis</a>, devido √† sua
                                alta performance e popularidade. Assim, quando os mesmos dados s√£o requisitados
                                novamente, a aplica√ß√£o consulta o cache em mem√≥ria em vez do banco de dados.
                            </p>

                            <p>
                                O armazenamento em mem√≥ria √© essencial porque o acesso a dados na mem√≥ria √© muito mais
                                r√°pido do que em disco. Isso torna o uso de cache uma solu√ß√£o eficiente para acelerar
                                chamadas frequentes de dados.
                            </p>

                            <p>Veja um exemplo do fluxo <strong>normal</strong> de uma chamada GET sem cache:</p>

                            <pre><code>
Cliente envia requisi√ß√£o GET ‚Üí Servidor recebe a requisi√ß√£o ‚Üí Servidor consulta o banco de dados ‚Üí Banco retorna os dados ‚Üí Servidor envia a resposta ao cliente
</code></pre>

                            <p>Agora, veja como o fluxo muda quando o cache est√° ativo:</p>

                            <pre><code>
Cliente envia requisi√ß√£o GET ‚Üí Servidor verifica se os dados est√£o no cache (Redis) 
  ‚Üí Se os dados estiverem no cache ‚Üí Servidor retorna os dados diretamente ao cliente
  ‚Üí Se n√£o estiverem no cache ‚Üí Servidor consulta o banco de dados ‚Üí Banco retorna os dados ‚Üí Servidor armazena os dados no cache ‚Üí Servidor envia a resposta ao cliente
</code></pre>

                            <p>
                                Perceba que o servidor consulta primeiro no cache, e somente se necess√°rio consulta o
                                banco de dados, esse √© a funcionalidade <strong>base</strong> da maioria das estrat√©gias
                                de cache eficientes.
                            </p>

                            <p>
                                Existem v√°rias formas de implementar cache em uma aplica√ß√£o web, e a mais comum √© a
                                estrat√©gia de
                                <strong>cache-aside</strong>, cujo fluxo foi descrito acima.
                            </p>

                            <p>
                                No entanto, o pr√≥prio protocolo HTTP j√° fornece mecanismos de caching. Assim, al√©m de
                                gerenciar o cache nas camadas internas do servidor utilizando Redis, tamb√©m podemos
                                utilizar o
                                <a
                                    href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Reference/Headers/Cache-Control"
                                    target="_blank"
                                    class="blog-link"
                                    >Cache-Control</a
                                >
                                para controlar o cache na camada da API. As APIs REST modernas geralmente combinam essas
                                estrat√©gias:
                                <strong>Redis + Cache-Control (HTTP)</strong>.
                            </p>

                            <p>
                                √â importante entender a diferen√ßa entre essas duas abordagens, pois, apesar de
                                frequentemente usadas juntas, elas s√£o conceitos distintos. O
                                <strong>cache-aside</strong> √© uma estrat√©gia do lado do servidor, que utiliza um banco
                                de dados em mem√≥ria como Redis ou Memcached para acelerar respostas. Essa solu√ß√£o √©
                                <strong>estritamente do servidor</strong> e n√£o envolve o cliente.
                            </p>

                            <p>
                                J√° o <strong>cache HTTP</strong> envolve o cliente de forma ativa. Nesse caso, os
                                navegadores, proxies ou CDNs podem armazenar as respostas das requisi√ß√µes e
                                reutiliz√°-las em chamadas futuras. O cabe√ßalho <code>Cache-Control</code> permite
                                configurar regras como:
                            </p>

                            <ul>
                                <li>
                                    <strong>max-age</strong>: tempo em segundos que a resposta pode ser considerada
                                    v√°lida.
                                </li>
                                <br />
                                <li>
                                    <strong>public/private</strong>: define se a resposta pode ser armazenada por caches
                                    compartilhados (CDNs) ou apenas pelo navegador do cliente.
                                </li>
                                <br />
                                <li>
                                    <strong>no-cache/no-store</strong>: instru√ß√µes para que a resposta n√£o seja
                                    reutilizada ou armazenada.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Combinando essas duas estrat√©gias ‚Äî cache-aside para o servidor e cache HTTP para o
                                cliente ‚Äî √© poss√≠vel construir APIs REST modernas que respondem rapidamente e reduzem
                                significativamente a carga no banco de dados.
                            </p>

                            <p>
                                Mas, na pr√°tica, cerca de 90% das vezes os desenvolvedores web lidam apenas com o
                                <strong>cache-aside</strong>, no lado do servidor. J√° os mecanismos de
                                <strong>cache HTTP</strong> s√£o mais indicados para serem gerenciados pelo cliente ou
                                por camadas intermedi√°rias, como CDNs e proxies, atrav√©s de cabe√ßalhos como
                                <code>Cache-Control</code> e <code>ETag</code>. Tentar implementar a leitura de cache
                                HTTP manualmente na sua API n√£o √© recomendado, pois esses mecanismos j√° s√£o
                                interpretados automaticamente por navegadores e CDNs, tornando desnecess√°ria a l√≥gica
                                adicional no servidor.
                            </p>

                            <p>
                                Outro conceito importante de gerenciamento de cache √© a
                                <strong>invalida√ß√£o de cache</strong>, isto √©, dados que outrora eram √∫teis j√° est√£o
                                defazados e precisam ser removidos/invalidados para que novos entrem no lugar.
                            </p>

                            <p>Para entender isso visualize o seguinte cen√°rio:</p>

                            <pre><code>
1. O cliente faz um GET /produtos/42
   - A requisi√ß√£o passa pelo cache.
   - Como existe um registro armazenado, o cache retorna a vers√£o atual (mas antiga) do produto.
   - O cliente recebe os dados em milissegundos.

2. Um administrador atualiza o produto 42 no painel interno (ex.: altera pre√ßo de R$ 99 ‚Üí R$ 89).
   - A API grava o novo valor no banco de dados.
   - Por√©m, o mecanismo de cache ainda possui a vers√£o antiga.
   - Nenhuma invalida√ß√£o foi disparada automaticamente.

3. O mesmo cliente faz outro GET /produtos/42 alguns segundos depois.
   - O cache continua retornando a vers√£o antiga (pre√ßo R$ 99).
   - Do ponto de vista do cliente, o produto ‚Äúparece‚Äù n√£o ter sido atualizado.

4. Minutos depois, o TTL (Time To Live) do cache expira.
   - O cache marca o item como *stale* (obsoleto).
   - Na pr√≥xima requisi√ß√£o, o cache verifica que est√° expirado.
   - Ele encaminha a solicita√ß√£o ao servidor para obter a vers√£o mais recente.

5. O cliente faz um novo GET /produtos/42.
   - O cache detecta os dados como expirados.
   - A API retorna o pre√ßo correto (R$ 89).
   - O cache finalmente atualiza seu valor com a vers√£o mais recente.

Esse fluxo mostra claramente:
- como dados √∫teis podem se tornar rapidamente obsoletos;
- como o cliente continua recebendo informa√ß√µes antigas at√© que ocorra invalida√ß√£o ou expira√ß√£o;
- a import√¢ncia de mecanismos ativos de *cache invalidation* (ETags, versionamento, mensagens de evento etc.).</code></pre>
                            <br />

                            <p>
                                Em solu√ß√µes modernas, ferramentas como Redis e Memcached j√° oferecem mecanismos nativos
                                de <strong>TTL (Time to Live)</strong>, permitindo que itens armazenados expirem
                                automaticamente ap√≥s um per√≠odo definido.
                            </p>
                            <p>
                                Al√©m do TTL, existem outras estrat√©gias para lidar com dados inv√°lidos. Algumas
                                abordagens optam por <strong>atualizar o cache</strong> em vez de remov√™-lo
                                completamente, enquanto outras combinam atualiza√ß√£o e remo√ß√£o conforme o cen√°rio. Ainda
                                assim, o uso de TTL continua sendo a t√©cnica mais simples e amplamente adotada para
                                garantir a expira√ß√£o autom√°tica de informa√ß√µes.
                            </p>
                            <p>
                                Esses s√£o apenas os fundamentos do tema. O universo de caching √© bastante amplo, repleto
                                de conceitos, padr√µes e estrat√©gias diferentes. Explorar tudo em profundidade deixaria
                                este artigo excessivamente longo e desviaria do foco principal, por isso abordei apenas
                                o <strong>b√°sico</strong> que todo programador backend deve saber sobre caching.
                            </p>

                            <h1 class="h4 portfolio-title">GET - HATEOAS / Hypermedia</h1>

                            <p>
                                Uma das ideias mais interessantes do REST original √© que um cliente nunca deveria
                                ‚Äúadivinhar‚Äù quais a√ß√µes s√£o poss√≠veis sobre um recurso; em vez disso, a pr√≥pria resposta
                                do servidor deveria incluir links naveg√°veis que descrevem o que pode ser feito a
                                seguir. Esse conceito √© chamado de
                                <strong>HATEOAS (Hypermedia As The Engine Of Application State).</strong>
                            </p>

                            <p>
                                Na pr√°tica, isso significa que a resposta de um GET pode funcionar como uma pequena
                                interface naveg√°vel, muito parecida com um documento HTML, mas usando JSON. Cada recurso
                                retorna n√£o s√≥ os dados, mas tamb√©m metadados sobre como continuar a intera√ß√£o.
                            </p>

                            <p>Exemplo simples:</p>

                            <pre><code>
{
  "id": 42,
  "title": "Pedido n¬∫ 42",
  "status": "Awaiting Payment",
  "links": [
    { "rel": "self", "href": "/orders/42" },
    { "rel": "customer", "href": "/orders/42/customer" },
    { "rel": "pay", "href": "/orders/42/pay" }
  ]
}</code></pre>

                            <p>
                                O cliente n√£o precisa conhecer previamente a rota de pagamento ‚Äï a pr√≥pria API entrega
                                esse caminho de forma expl√≠cita e padronizada. Na teoria, isso permitiria que um cliente
                                gen√©rico navegasse por qualquer API REST, assim como um navegador faz com p√°ginas web.
                            </p>

                            <p>
                                Embora esse conceito possa ser aplicado a qualquer m√©todo HTTP, ele costuma aparecer com
                                mais frequ√™ncia em <strong>GET</strong>. Na pr√°tica, por√©m, muitos desenvolvedores
                                acabam n√£o implementando esse recurso ‚Äî e, em diversos casos, nem chegam a conhecer sua
                                exist√™ncia. Um HATEOAS bem estruturado reduz a necessidade de documenta√ß√£o extensa e
                                cria uma comunica√ß√£o mais direta entre cliente e servidor. Isso elimina comunica√ß√µes
                                humanas do tipo: ‚ÄúEi, qual era mesmo o endpoint que retorna os dados do cliente
                                relacionado ao pagamento?‚Äù, pois a pr√≥pria resposta da API j√° aponta os pr√≥ximos
                                caminhos poss√≠veis.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Streams / Downloads</h1>

                            <p>
                                Outro ponto interessante ‚Äî e pouco explorado ‚Äî √© que o GET n√£o serve apenas para
                                retornar JSON ‚Äúfechado‚Äù. Ele tamb√©m √© o m√©todo mais adequado para conte√∫dos grandes,
                                fluxos cont√≠nuos e transfer√™ncias parciais, porque √© seguro, idempotente e facilmente
                                otimizado por navegadores, proxies e CDNs.
                            </p>

                            <p>
                                Trafegar arquivos √© uma pr√°tica comum em aplica√ß√µes web modernas: PDFs, imagens, v√≠deos,
                                backups, relat√≥rios e bin√°rios em geral. Em todos esses casos, o protocolo HTTP √©
                                utilizado para enviar os dados como um stream, ou seja, a conex√£o HTTP √© estabelecida e
                                os dados do arquivo s√£o transmitidos de forma progressiva, em partes, enquanto o cliente
                                os consome. Muitos programadores web se enganam ao pensar que ao declarar um GET com:
                                <em>content-type: application/pdf</em>, o PDF ser√° enviado de uma √∫nica vez, isso n√£o
                                existe.
                            </p>

                            <p>
                                Todo download de arquivo utilizando o protocolo HTTP se baseia na ideia de
                                <strong>transfer√™ncia progressiva de dados</strong>, onde o conte√∫do √© entregue como um
                                fluxo cont√≠nuo de bytes ao cliente. Em muitos cen√°rios ‚Äî especialmente para arquivos
                                grandes ‚Äî essa transfer√™ncia pode ser otimizada por meio da estrat√©gia
                                <strong>Range-based transfer</strong>, que permite solicitar apenas partes espec√≠ficas
                                de um recurso.
                            </p>

                            <p>
                                Um exemplo muito conhecido ‚Äî e f√°cil de observar na pr√°tica ‚Äî s√£o os v√≠deos do YouTube.
                                Embora um v√≠deo seja, conceitualmente, um arquivo, seus dados n√£o s√£o transferidos de
                                uma √∫nica vez. Em vez disso, o conte√∫do √© trafegado como um
                                <strong>stream de dados</strong>, sendo consumido progressivamente pelo cliente. Esse
                                comportamento pode ser observado diretamente na ferramenta de desenvolvedor do
                                navegador, na aba <em>Network</em>.
                            </p>

                            <p>
                                Durante a reprodu√ß√£o, √© poss√≠vel perceber sucessivas requisi√ß√µes ao endpoint
                                <code>/videoplayback</code>. Essas requisi√ß√µes ocorrem ao longo do tempo e carregam os
                                dados de v√≠deo e √°udio necess√°rios para manter o buffer do player preenchido:
                            </p>

                            <div class="item item-diagrama">
                                <div class="item-description">
                                    <small><i>Clique para expandir</i></small>
                                </div>
                                <img
                                    src="../../assets/images/blog/rest/videoplaybacks.png"
                                    class="img-expanded"
                                    style="width: 100%"
                                />
                            </div>
                            <br />
                            <p>
                                Existem uma pr√°tica horr√≠vel, muito adotada ‚Äî Principalmente com arquivos de imagens ‚Äî
                                que consiste em converter arquivos bin√°rios para Base64 e inclu√≠-los dentro de um JSON.
                                Al√©m de poluir o payload e dificultar o cache, essa convers√£o aumenta o tamanho real do
                                conte√∫do em aproximadamente
                                <strong>33%</strong>. Sempre <strong>prefira HTTP streaming</strong> para a
                                transfer√™ncia de arquivos bin√°rios.
                            </p>

                            <p>
                                Quando o servidor conhece previamente o tamanho total do conte√∫do a ser enviado, ele
                                pode informar esse valor por meio do header <code>Content-Length</code>. Nesse cen√°rio,
                                o cliente sabe exatamente quantos bytes esperar e pode gerenciar melhor o progresso do
                                download, exibir barras de progresso e otimizar o uso de mem√≥ria. Por outro lado, quando
                                o tamanho do conte√∫do n√£o √© conhecido no momento em que a resposta √© iniciada ‚Äî como em
                                streams, gera√ß√£o din√¢mica de arquivos ou leitura progressiva de dados ‚Äî o HTTP utiliza a
                                transfer√™ncia em partes (<em>Transfer-Encoding: chunked</em>, no header), na qual os
                                dados s√£o enviados em blocos sucessivos enquanto a conex√£o permanece aberta, sem a
                                necessidade de informar o tamanho total antecipadamente.
                            </p>

                            <p>
                                Mas, no dia a dia, voc√™ n√£o precisa se preocupar com essas propriedades no header ao
                                transferir um arquivo, os pr√≥prios frameworks web j√° fazem isso por voc√™, ou seja, ao
                                retornar algo como:
                            </p>

                            <pre><code>
async getBoardgameRulebook(): Promise&lt;ReadStream | undefined&gt; {
    return fs.createReadStream(
        path.join(__dirname, '..', 'assets', 'rulebook-example.pdf')
    );
}</code></pre>

                            <p>
                                O pr√≥pio FASTIFY vai se encarregar de incluir: <em>Transfer-Encoding: chunked</em> e
                                <em>Content-Length</em> no headers da requisi√ß√£o.
                            </p>

                            <p>
                                E claro‚Ä¶ sempre informe o <em>Content-Type</em> corretamente. Esse header indica ao
                                cliente como os bytes recebidos devem ser interpretados. Por exemplo,
                                <code>application/json</code>, <code>text/html</code> para p√°ginas web,
                                <code>image/png</code> ou <code>image/jpeg</code> para imagens,
                                <code>application/pdf</code> para documentos PDF e <code>video/mp4</code> para conte√∫dos
                                de v√≠deo. Quando o tipo exato do arquivo n√£o √© conhecido ou n√£o deve ser interpretado
                                automaticamente pelo cliente, utilize o tipo gen√©rico
                                <code>application/octet-stream</code>, que representa um fluxo arbitr√°rio de bytes.
                            </p>
                        </div>
                        <div id="post" class="blog-text">
                            <h1 class="h4 portfolio-title">POST</h1>

                            <p>
                                O objetivo do m√©todo <strong>POST</strong> √© <strong>enviar dados</strong> ao servidor.
                                Diferentemente do <strong>GET</strong>, em que o cliente solicita uma representa√ß√£o de
                                um recurso, no POST o cliente j√° possui a informa√ß√£o e a transmite ao servidor para que
                                ela seja processada.
                            </p>

                            <p>
                                Aqui, iniciantes se confundam com o fato de o POST tamb√©m retornar uma resposta. Assim
                                como o GET ‚Äî e qualquer outro m√©todo HTTP ‚Äî o POST sempre possui uma
                                <strong>response</strong>, normalmente em formato JSON. Essa caracter√≠stica, por√©m, leva
                                a um erro conceitual frequente: utilizar POST para <em>obter</em> dados do servidor.
                                Embora isso funcione tecnicamente, est√° longe de ser a abordagem correta. O POST n√£o
                                deve ser usado como mecanismo de consulta; seu papel principal √© a cria√ß√£o ou submiss√£o
                                de dados no servidor, sendo normalmente associado a opera√ß√µes de <em>INSERT</em>.
                            </p>

                            <p>
                                Tamb√©m vale ressaltar que <strong>muitos</strong> dos conceitos apresentados no t√≥pico
                                anterior sobre o <strong>GET</strong> ‚Äî como <em>query params</em>,
                                <em>route params</em>, pagina√ß√£o e hypermedia ‚Äî podem ser utilizados normalmente em
                                requisi√ß√µes <strong>POST</strong>, ainda que alguns desses recursos sejam mais comuns no
                                contexto de GET. A principal diferen√ßa sem√¢ntica entre POST e GET no HTTP √© que, no
                                primeiro, √© permitido o envio de um payload no <strong>body</strong> da requisi√ß√£o,
                                enquanto no segundo o corpo da requisi√ß√£o n√£o √© utilizado para esse fim.
                            </p>

                            <p>
                                Assim como fiz no t√≥pico sobre pr√°ticas comuns do GET, vou descrever as situa√ß√µes e
                                pr√°ticas comuns de POST que um programador web backend lida diariamente.
                            </p>

                            <h1 class="h4 portfolio-title">POST - Mapeamento e valida√ß√£o de dados</h1>

                            <p>
                                Quando o cliente envia dados no corpo da requisi√ß√£o, esses dados devem ser
                                <strong>mapeados</strong> e <strong>validados</strong>. O protocolo HTTP n√£o realiza
                                nenhum tipo de valida√ß√£o e mapeamento, ele apenas transporta os dados. A
                                responsabilidade de converter o corpo em objetos ou classes no servidor fica a cargo do
                                framework web (no meu caso, o Fastify).
                            </p>

                            <p>
                                Sobre mapeamento, existem diversas bibliotecas que fazem o
                                <strong>parsing do corpo da requisi√ß√£o</strong> em um <strong>DTO</strong> (Data
                                Transfer Object). No caso do Fastify, a biblioteca padr√£o para isso √© o
                                <a href="https://ajv.js.org" target="_blank" class="blog-link">AJV</a>.
                            </p>

                            <p>
                                Uma boa biblioteca de parsing de API web n√£o fornece apenas o
                                <strong>mapeamento</strong> (transformar JSON em uma classe), mas tamb√©m recursos de
                                <strong>valida√ß√£o</strong> de dados. Esses recursos permitem validar regras como tipo de
                                dados, valores m√≠nimos e m√°ximos para dados num√©ricos, campos obrigat√≥rios, entre
                                outros. Quando a biblioteca de parsing √© totalmente integrada ao framework da API, essas
                                valida√ß√µes j√° retornam erros HTTP da fam√≠lia 400 sempre que algum dado enviado pelo
                                cliente n√£o corresponde √†s regras estipuladas no mapeamento.
                            </p>

                            <p>
                                Para entender melhor veja, esse mapeamento de dados da enpoint
                                <code>/usuario</code> para cria√ß√£o de um novo usu√°rio no fastify:
                            </p>

                            <pre>
                                <code>
app.post(
    '/usuarios',
    {
        schema: {
            body: {
                type: 'object',
                required: ['email'],
                properties: {
                    nome: { type: 'string' },
                    email: { type: 'string' },
                },
            },
        },
    },
    async (request, reply) => userController.createUsuario(request, reply)
);</code></pre>

                            <br />
                            <p>
                                Perceba, que eu consigo definir o <strong>tipo</strong> das propriedades, e definir a
                                obrigat√≥riedade, atr√°ves da propriedade <code>required</code>. Se o cliente, enviar um
                                valor n√∫merico no <code>nome</code>, o AJV avisa o fastify que uma regra n√£o foi
                                cumprida, e o pr√≥prio fastify se encarrega de retornar um erro <code>400</code> para o
                                cliente. Tudo autom√°tico, n√£o foi necess√°rio validar manualmente dentro dos meus m√©todos
                                controller ou service.
                            </p>

                            <p>
                                Todo framework web moderno, j√° fornece esse tipo de mapeamento e valida√ß√£o com retorno
                                de exce√ß√£o autom√°tico. Definitivamente n√£o √© uma boa pr√°tica validar corpo de requisi√ß√£o
                                manualmente. Sendo assim o desenvolvedor deve apenas se preocupar com as valida√ß√µes que
                                s√£o necess√°rias, as valida√ß√µes que envolvem as regras de neg√≥cio do sistema.
                            </p>

                            <p>
                                Ap√≥s definir o <code>schema</code> do body da requisi√ß√£o na endpoinnt POST
                                <code>/usuario</code>, eu criei uma interface <strong>DTO</strong> que mapeia as
                                propriedades desse schema, veja:
                            </p>

                            <pre><code>
export interface UsuarioDto {
    nome: string | null | undefined;
    email: string;
    created?: boolean | undefined;
}</code></pre>

                            <p>
                                Utilizo essa interface na minha controller e service, veja esse exemplo em
                                <code>usuarioController</code>:
                            </p>

                            <pre><code>
async createUsuario(
    request: FastifyRequest,
    reply: FastifyReply
): Promise&lt;undefined&gt; {
    try {
        const newUsuario = request.body as UsuarioDto;

        const usuario = await this.usuarioService.createUsuario(newUsuario);

        return reply.code(usuario?.created ? 201 : 200).send(usuario);
    } catch (error) {
        this.throwResponseException(error, reply);
    }
}</code></pre>

                            <p>
                                <code>request.body</code> √© recebido como um <code>any</code>, mas eu for√ßo a tipagem
                                para <code>UsuarioDto</code>. Utilizar DTOs √© uma boa pr√°tica em m√©todos POST. Entenda
                                DTO como uma classe "burra", que n√£o possui nenhuma funcionalidade, apenas define as
                                propriedades e seus tipos. O pr√≥prio nome j√° sugere que √© uma classe apenas para
                                transferencia de dados (Data Transfer Objects).
                            </p>

                            <p>
                                √â importante comentar sobre DTOs, pois programadores iniciantes tendem a utilizar a
                                <strong>mesma</strong> classe de Model do ORM para mapear os dados na controller. Esse √©
                                um erro muito comum. Para entender melhor, veja as duas classes abaixo:
                            </p>

                            <p>
                                Interface TypeScript que define o modelo da tabela <strong>USU√ÅRIO</strong>, utilizada
                                pelo ORM:
                            </p>
                            <pre><code>
export interface UsuarioModel {
    id: number;
    nome: string;
    email: string;
    senha: string;
    criadoEm: Date;
    atualizadoEm: Date;
}
</code></pre>

                            <p>
                                Interface TypeScript que define o DTO para o POST, utilizado na cria√ß√£o de um novo
                                usu√°rio:
                            </p>
                            <pre><code>
export interface UsuarioDto {
    nome: string;
    email: string;
    senha: string;
}
</code></pre>

                            <p>
                                Perceba que as duas interfaces possuem algumas propriedades semelhantes, mas o DTO n√£o
                                inclui campos como <code>id</code>, <code>criadoEm</code> ou <code>atualizadoEm</code>.
                                √Ä primeira vista, pode parecer que n√£o faz sentido criar um
                                <strong>UsuarioDto</strong> e que seria mais simples usar diretamente o
                                <strong>UsuarioModel</strong> na controller. No entanto, isso √© um erro comum de
                                programadores iniciantes.
                            </p>

                            <p>
                                Separar Model e DTO faz sentido por v√°rios motivos: o DTO define exatamente o que a API
                                espera receber ou enviar, protegendo campos sens√≠veis como senhas ou IDs de serem
                                modificados diretamente pelo cliente. Al√©m disso, facilita a valida√ß√£o e o mapeamento de
                                dados, mant√©m a camada de persist√™ncia desacoplada da camada de apresenta√ß√£o e torna o
                                c√≥digo mais seguro, previs√≠vel e f√°cil de manter. Essa pr√°tica √© especialmente
                                importante em APIs REST ou GraphQL, onde o contrato de dados precisa ser claro e
                                consistente.
                            </p>

                            <p>
                                Para simplificar: <strong>n√£o misture camadas.</strong> Models fazem parte da camada de
                                banco de dados e do servidor, e devem ser utilizados apenas nas classes respons√°veis
                                pela persist√™ncia, como os <code>repositories</code>. Nunca devem ser usados diretamente
                                na camada de API, como nos m√©todos da <code>controller</code>. Mais adiante, abordarei
                                com mais detalhes o conceito de camadas e refor√ßarei a import√¢ncia de manter cada
                                responsabilidade separada.
                            </p>

                            <h1 class="h4 portfolio-title">POST - Processamento ass√≠ncrono</h1>

                            <p>
                                APIs modernas utilizam <strong>async/await</strong> porque a maior parte do
                                processamento envolve opera√ß√µes de <em>I/O</em>, como acesso a banco de dados, leitura
                                de arquivos e chamadas para outros servi√ßos. Essas opera√ß√µes s√£o inerentemente lentas
                                quando comparadas √† execu√ß√£o de c√≥digo em mem√≥ria, e execut√°-las de forma s√≠ncrona
                                bloquearia o servidor. O uso de processamento ass√≠ncrono permite que a aplica√ß√£o
                                continue atendendo outras requisi√ß√µes enquanto aguarda a conclus√£o dessas opera√ß√µes.
                            </p>

                            <p>
                                Pensamento cl√°ssico: "Se eu usar async/await, posso fazer qualquer coisa dentro dos
                                m√©todos da endpoint.". Esse pensamento est√° completamente errado, async/await
                                <strong>n√£o paraleliza CPU</strong> ele apenas libera a thread enquanto espera I/O, ele
                                n√£o resolve problemas causados por tarefas computacionalmente pesadas. Opera√ß√µes
                                intensivas de CPU, como c√°lculos complexos, compress√£o de dados ou loops extensos,
                                continuam sendo executadas de forma s√≠ncrona dentro da thread de execu√ß√£o.
                            </p>

                            <p>
                                Para resolver esse problema e evitar o <strong>bloqueio do event loop</strong> no
                                Node.js, √© comum adotar a estrat√©gia de <strong>filas de processamento</strong>. Nesse
                                modelo, a API limita-se a receber e validar a requisi√ß√£o, delegando a execu√ß√£o de
                                tarefas pesadas para processos em segundo plano. Dessa forma, o servidor HTTP permanece
                                responsivo, enquanto o processamento √© realizado de maneira ass√≠ncrona e desacoplada do
                                ciclo de vida da requisi√ß√£o.
                            </p>

                            <p>
                                Esse tipo de problema ocorre principalmente quando estamos lidando com sistemas de envio
                                de e-mails, mensagens e etc. Para entender, visualize esse fluxo que
                                <strong>n√£o</strong>
                                possui fila de processamento:
                            </p>

                            <pre><code>
Cliente
   |
   v
API recebe a requisi√ß√£o
   |
   v
API processa toda a l√≥gica (envio de e-mail)
   |
   v
API aguarda o servi√ßo de e-mail responder
   |
   v
Resposta enviada ao cliente (200 OK ou erro)
</code></pre>

                            <p>
                                Nesse cen√°rio, o cliente precisa aguardar todo o processamento terminar. Caso o servi√ßo
                                de e-mail esteja lento ou indispon√≠vel, a requisi√ß√£o ficar√° bloqueada, aumentando o
                                tempo de resposta e a chance de falhas.
                            </p>

                            <p>
                                Agora veja o mesmo fluxo utilizando uma
                                <strong>fila de processamento (REST + Queue)</strong>:
                            </p>

                            <pre><code>
Cliente
   |
   v
API recebe a requisi√ß√£o
   |
   v
API valida os dados
   |
   v
API adiciona a mensagem na fila
   |
   v
Resposta imediata ao cliente (202 Accepted)

-------------------------

Worker / Consumidor
   |
   v
L√™ mensagem da fila
   |
   v
Processa a l√≥gica (envio de e-mail)
   |
   v
Comunica o servi√ßo externo
   |
   v
Finaliza o processamento
</code></pre>

                            <p>
                                Com a fila, a API responde rapidamente ao cliente, delegando o trabalho pesado para um
                                <em>worker</em>. Isso torna o sistema mais resiliente, escal√°vel e desacoplado, evitando
                                que falhas ou lentid√£o em servi√ßos externos impactem diretamente o usu√°rio final.
                            </p>

                            <p>
                                Nos √∫ltimos anos, tornou-se popular o uso de aplica√ß√µes de <strong>mensageria</strong>,
                                como <strong>RabbitMQ</strong>. √â importante entender a diferen√ßa entre fila de
                                processamento e mensageria: Embora ambos os conceitos permitam processamento ass√≠ncrono,
                                filas de processamento e mensageria possuem objetivos diferentes. A fila de
                                processamento √© utilizada para delegar a execu√ß√£o de tarefas a um <em>worker</em>,
                                geralmente dentro do mesmo sistema, garantindo que opera√ß√µes custosas sejam processadas
                                em segundo plano sem bloquear a requisi√ß√£o HTTP. J√° a mensageria tem como foco a
                                comunica√ß√£o entre servi√ßos, onde eventos ou mensagens s√£o publicados para um broker e
                                consumidos por um ou mais sistemas de forma desacoplada, sendo muito comum em
                                arquiteturas de microservi√ßos.
                            </p>

                            <p>
                                Ou seja, se a sua tarefa √© implementar um processamento ass√≠ncrono, sem depender de
                                outros servi√ßos, tais como: processamento pesado no banco de dados, gera√ß√£o de
                                relat√≥rio, envio de emails, tarefas que podem falhar e precisar de retry, entre outros
                                cen√°rios, a escolha mais adequada √© utilizar uma fila de processamento.
                            </p>

                            <p>
                                J√° a mensageria √© mais indicada quando h√° a necessidade de comunica√ß√£o entre sistemas ou
                                servi√ßos distintos, onde um evento precisa ser propagado para que outros servi√ßos reajam
                                a ele. Esse modelo √© comum em arquiteturas de microservi√ßos, permitindo maior
                                desacoplamento, escalabilidade e independ√™ncia entre os consumidores da mensagem.
                            </p>

                            <p>
                                Segue abaixo o fluxo que implementei de uma cria√ß√£o de boardgames em lote utilizando
                                fila de processamento. Utilize a biblioteca
                                <a href="https://github.com/taskforcesh/bullmq" class="blog-link" target="_blank"
                                    >BullMQ</a
                                >
                                para cria√ß√£o de queues e workers no node.
                            </p>

                            <details>
                                <summary>Declarando a endpoint /boardgames/:usuarioId/batch</summary>
                                <pre><code>
 app.post(
        '/boardgames/:usuarioId/batch',
        {
            schema: {
                params: {
                    type: 'object',
                    required: ['usuarioId'],
                    properties: {
                        usuarioId: { type: 'number', minimum: 0 },
                    },
                },
                body: {
                    type: 'array',
                    minItems: 1,
                    items: {
                        type: 'object',
                        required: ['nome', 'descricao', 'complexidade'],
                        properties: {
                            nome: { type: 'string' },
                            descricao: { type: 'string' },
                            complexidade: { type: 'number' },
                            idade: { type: 'number' },
                            tempo: { type: 'number' },
                            ano: { type: 'number' },
                        },
                    },
                },
                headers: {
                    type: 'object',
                    required: ['idempotencykey'],
                    properties: {
                        idempotencykey: { type: 'string' },
                    },
                },
            },
        },
        async (request, reply) =>
            boardgameController.createBoardgamesBatch(request, reply)
    );</code></pre>
                            </details>
                            <details>
                                <summary>Controller retornando 202 e adicionando lista na fila.</summary>
                                <pre><code>
    async createBoardgamesBatch(
        request: FastifyRequest,
        reply: FastifyReply
    ): Promise&gt;undefined&lt; {
        try {
            const boardgames = request.body as BoardgameDto[];
            const { usuarioId } = request.params as { usuarioId: number };

            await boardgameQueue.add(
                'create-boardgames',
                {
                    boardgames,
                    usuarioId,
                },
                {
                    removeOnComplete: true,
                    removeOnFail: false,
                }
            );

            return reply.code(202).send({
                message: 'Boardgames enfileirado para processamento',
            });
        } catch (error) {
            this.throwResponseException(error, reply);
        }
    }</code></pre>
                            </details>
                            <details>
                                <summary>Declarando fila e worker para processar a lista de boardgames.</summary>
                                <pre><code>
import { Queue } from 'bullmq';

import { Worker, Job } from 'bullmq';
import { BoardgameDto } from '../models/boardgameDto';
import { bullRedisOptions } from '../database/redisConnections';
import { Boardgame } from '@prisma/client';
import { prisma } from '../database/prismaClient';

export const boardgameQueue = new Queue('boardgame-queue');

interface CreateBoardgamesJob {
    boardgames: BoardgameDto[];
    usuarioId: number;
}

export const boardgameWorker = new Worker(
    'boardgame-queue',
    async (job: Job&gt;CreateBoardgamesJob&lt;) => {
        if (job.name === 'create-boardgames') {
            const { boardgames, usuarioId } = job.data;

            let boardgamesModel: Boardgame[] = [];

            for (const newBoardgame of boardgames) {
                boardgamesModel.push(&gt;Boardgame&lt;{
                    nome: newBoardgame.nome,
                    descricao: newBoardgame.descricao,
                    complexidade: newBoardgame.complexidade,
                    ano: newBoardgame.ano ?? 0,
                    idade: newBoardgame.idade,
                    tempo: newBoardgame.tempo,
                    usuarioId: usuarioId,
                });
            }

            prisma.boardgame.createMany({
                data: boardgamesModel,
            });
        }
    },
    {
        connection: bullRedisOptions,
        concurrency: 5,
    }
);
</code></pre>
                            </details>

                            <h1 class="h4 portfolio-title">POST - Webhook</h1>

                            <p>
                                Outro recurso fortemente ligado ao tema de processamento ass√≠ncrono s√£o os
                                <strong>webhooks</strong> ‚Äî n√£o confundir com <strong>WebSockets</strong>, pois s√£o
                                conceitos completamente diferentes.
                            </p>

                            <p>
                                Um webhook √© um <strong>mecanismo de notifica√ß√£o baseado em eventos</strong>, no qual um
                                sistema envia automaticamente uma requisi√ß√£o HTTP para outro sistema quando algo
                                acontece. O webhook pode ser entendido como o oposto do <strong>polling HTTP</strong>.
                            </p>

                            <p>
                                Entenda <strong>webhook</strong> como: ‚Äúme avisa quando acontecer‚Äù.<br />
                                Entenda <strong>polling</strong> como: ‚Äúvou te perguntar a cada 5 segundos se algo
                                aconteceu‚Äù.
                            </p>

                            <p>
                                Faz sentido utilizar webhooks quando √© necess√°rio disparar um evento ass√≠ncrono em outra
                                aplica√ß√£o, como por exemplo: pagamento aprovado ou reprovado, confirma√ß√£o de e-mail de
                                um usu√°rio, finaliza√ß√£o de um processamento em background, entre outros.
                            </p>

                            <p>
                                Na pr√°tica, um webhook √© apenas uma chamada HTTP para <strong>outra API</strong>, sendo
                                predominantemente utilizado para comunica√ß√£o <strong>backend ‚Üí backend</strong>,
                                normalmente em cen√°rios de integra√ß√£o entre sistemas, como: Gateway de pagamento ‚Üí
                                e-commerce. Webhooks n√£o s√£o pensados para comunica√ß√£o direta com frontend.
                            </p>

                            <p>
                                Webhooks quase sempre s√£o implementados utilizando endpoints do tipo
                                <strong>POST</strong>. Embora seja tecnicamente poss√≠vel utilizar outros m√©todos HTTP,
                                na pr√°tica isso raramente faz sentido.
                            </p>

                            <p>
                                Por ser amplamente utilizado em integra√ß√µes entre APIs, muitos desenvolvedores acabam
                                atribuindo aos webhooks uma complexidade que <strong>n√£o existe</strong>. Um webhook √©
                                <strong>apenas</strong> uma chamada HTTP para outra API, sinalizando que algo aconteceu
                                ‚Äî nada al√©m disso.
                            </p>

                            <p>
                                Existem alguns artigos que defendem o uso de polling HTTP, mas particularmente, eu n√£o
                                gosto dessa pr√°tica. Al√©m de consumir muita banda desnecess√°ria, para realizar as
                                chamadas http constantes, tamb√©m consome processamento, pois cada request trafega dados
                                de autentica√ß√£o, permiss√£o e etc, que precisa ser processado. E eu considero algo muito
                                feio de implementar, todas as vezes que implementei polling http, foi por que o servi√ßo
                                que eu estava integrando me
                                <strong>obrigou</strong> a usar polling, isto √©, ele n√£o liberava um webhook para minha
                                aplica√ß√£o se comunicar.
                            </p>

                            <p>
                                A minha opini√£o √©: Para notifica√ß√£o de eventos entre API's, prefira webhook sempre que
                                poss√≠vel, evite polling http ao m√°ximo.
                            </p>

                            <h1 class="h4 portfolio-title">POST - Upload / Multipart</h1>

                            <p>
                                Para upload de arquivos, √© poss√≠vel trafegar apenas os dados do arquivo, basta declarar
                                uma endpoint com <code>application/pdf</code> (caso seja um arquivo PDF). ou ent√£o um
                                <code>octet-stream</code>, que √© um content-type "coringa", que n√£o especifica o tipo do
                                arquivo, √© utilizado apenas para trefegar bytes.
                            </p>

                            <p>
                                Mas existe um <em>Content-Type</em> interessante, pouco utilizado e muitas vezes mal
                                compreendido, que √© o <code>multipart/form-data</code>. Com esse formato √© poss√≠vel
                                enviar dados bin√°rios + metadados na mesma requisi√ß√£o, como no caso do cadastro de um
                                produto ou boardgame, onde informa√ß√µes como nome, descri√ß√£o e pre√ßo s√£o enviadas junto
                                com a <strong>imagem</strong> associada ao item.
                            </p>

                            <p>Para simplificar, eu costumo pensar assim:</p>

                            <pre><code>
Preciso enviar apenas um arquivo
‚Üí application/pdf, image/png, image/jpeg ou application/octet-stream

Preciso enviar apenas dados estruturados (texto, n√∫meros, booleanos)
‚Üí application/json

Preciso enviar arquivo + dados
‚Üí multipart/form-data
</code></pre>
                            <br />

                            <p>
                                Vamos entender um pouco sobre
                                <code>multipart/form-data</code>: √© um formato de codifica√ß√£o de requisi√ß√µes HTTP
                                definido pelo padr√£o MIME, usado quando precisamos enviar m√∫ltiplos tipos de dados no
                                corpo da mesma requisi√ß√£o.
                            </p>

                            <p>
                                Em vez de enviar tudo como um √∫nico bloco (como no application/json), o corpo da
                                requisi√ß√£o √© dividido em partes independentes (parts), cada uma contendo: seus pr√≥prios
                                headers seu pr√≥prio conte√∫do. Essas partes s√£o separadas por um boundary.
                            </p>

                            <p>
                                JSON n√£o foi feito para trafegar arquivos, solu√ß√µes toscas como converter em BASE64 (J√°
                                discutido no t√≥pico GET - STREAM) n√£o funcionam bem. JSON √© um formato textual que foi
                                criado para representar dados estruturados leg√≠veis, n√£o para transportar dados bin√°rios
                                brutos.
                            </p>

                            <p>
                                Por isso, multipart resolve o problema, pois o formato multipart suporta
                                <strong>http streaming</strong>, ou seja, o arquivo √© lido em
                                <strong>chunks de rede</strong>, e n√£o √© necess√°rio carregar todo o bin√°rio em mem√≥ria.
                                o servidor processa os dados enquanto recebe. Isso √© essencial para uploads grandes e
                                torna a API mais escal√°vel.
                            </p>

                            <p>
                                Veja esse exemplo de corpo multipart de um arquivo de imagem (apenas uma representa√ß√£o
                                visual, no body tudo isso √© enviado em bin√°rio):
                            </p>

                            <pre><code>
------WebKitFormBoundaryXyZ123
Content-Disposition: form-data; name="title"

Capa do Boardgame
------WebKitFormBoundaryXyZ123
Content-Disposition: form-data; name="image"; filename="cover.png"
Content-Type: image/png

&lt;bytes bin√°rios da imagem&gt;
------WebKitFormBoundaryXyZ123--
</code></pre>
                            <br />
                            <p>
                                No exemplo acima, o
                                <strong>boundary</strong> (<code>------WebKitFormBoundaryXyZ123</code>) √© um delimitador
                                utilizado para separar cada parte do corpo da requisi√ß√£o
                                <code>multipart/form-data</code>. Ele √© definido no header <code>Content-Type</code> da
                                requisi√ß√£o e indica onde uma parte come√ßa e termina.
                            </p>

                            <p>
                                Cada parte do corpo cont√©m seus pr√≥prios <strong>headers</strong>, como
                                <code>Content-Disposition</code> e <code>Content-Type</code>. Esses headers descrevem os
                                metadados daquela parte espec√≠fica, informando, por exemplo, o nome do campo do
                                formul√°rio, o nome do arquivo e o tipo do conte√∫do enviado.
                            </p>

                            <p>
                                J√° o <strong>conte√∫do</strong> corresponde aos dados propriamente ditos daquela parte.
                                No caso de campos de texto, trata-se do valor textual enviado; no caso de arquivos, s√£o
                                os bytes bin√°rios do arquivo. Todo esse conte√∫do √© transmitido como um fluxo de bytes,
                                sendo interpretado pelo servidor de acordo com as regras do formato multipart.
                            </p>

                            <p>
                                Em resumo, o multipart/form-data n√£o √© apenas um formato para upload de arquivos, mas um
                                mecanismo que permite transportar diferentes tipos de dados de forma eficiente, segura e
                                compat√≠vel com streaming, sendo a escolha ideal quando arquivos e metadados precisam
                                coexistir na mesma requisi√ß√£o.
                            </p>

                            <h1 class="h4 portfolio-title">POST - Idempot√™ncia</h1>

                            <p>
                                Uma opera√ß√£o √© idempotente quando execut√°-la uma ou v√°rias vezes produz o
                                <strong>mesmo efeito</strong>
                                final no servidor.
                            </p>

                            <p>
                                Em resumo: Repetir a mesma requisi√ß√£o n√£o altera o resultado ap√≥s a primeira execu√ß√£o
                                bem-sucedida. Exemplo gen√©rico:
                            </p>
                            <pre><code>
Executar 1 vez ‚Üí estado final X 
Executar 10 vezes ‚Üí continua estado final X</code></pre>
                            <br />

                            <p>
                                Por padr√£o, m√©todos do tipo POST n√£o s√£o idempotentes. O m√©todo POST normalmente √© usado
                                para cria√ß√£o de recursos, e cada chamada tende a gerar um novo efeito colateral:
                            </p>
                            <pre><code>
POST /orders

Se chamado duas vezes:
1 vez ‚Üí Pedido #101 criado

2 vex ‚Üí Pedido #102 criado

‚û°Ô∏è Dois efeitos distintos ‚Üí n√£o idempotente

</code></pre>
                            <br />

                            <p>
                                √â possivel tornar o POST idempotente, desde que a aplica√ß√£o implemente esse
                                comportamento explicitamente na api. Entenda que tornar um POST idempotente n√£o √© s√≥ uma
                                boa pr√°tica, mas sim uma <strong>solu√ß√£o de um problema </strong> de duplicidade de
                                opera√ß√£o.
                            </p>
                            <p>
                                Nem todo POST necessita de idempot√™ncia, cada caso deve ser analisado. Mas no geral a
                                idepotencia deve ser implementada quando a opera√ß√£o n√£o pode ser
                                <strong>duplicada</strong>, principalmente quando √© uma opera√ß√£o critica, como por
                                exemplo uma API de pagamentos, cria√ß√£o de pedidos e etc.
                            </p>

                            <p>
                                Idempot√™ncia resolve principalmente problemas causados por repeti√ß√µes involunt√°rias de
                                requisi√ß√µes, como o um cliente que est√° duplicando request, usu√°rio que clica diversas
                                vezes no button "submit" do formul√°rio, uma comunica√ß√£o http que se perdeu e o
                                http-client possui retry autom√°tico, e etc.
                            </p>

                            <p>
                                O padr√£o mais utilizado para implementar idempot√™ncia em API REST √© a estrat√©gia de
                                <strong>chave de idempot√™ncia</strong>.
                            </p>

                            <p>
                                Essa estrat√©gia consiste em o cliente gerar uma chave √∫nica (chamada de
                                <code>idempotency-key</code>) e envia-la como metadado da requisi√ß√£o.
                            </p>

                            <p>
                                Normalmente essa chave √© um <strong>UUID</strong>, √© obrigat√≥ria, e deve ser enviada no
                                <strong>HEADERS</strong> da requisi√ß√£o, pois √© um metadado. Quando essa informa√ß√£o n√£o √©
                                enviada, a API retorna <code>400</code> ou <code>422</code> para o client.
                            </p>

                            <p>Segue o fluxo dessa estrat√©gia √© assim:</p>

                            <pre><code>
POST /orders
Headers:
  Idempotency-Key: 8f1a2c9e-...

Funcionamento t√≠pico:

1. Cliente gera um UUID e envia no header Idempotency-Key.

2. A API verifica se essa chave j√° foi utilizada.

3. Se a chave N√ÉO existir:
   - Processa a requisi√ß√£o
   - Persiste o resultado associado √† chave
   - Retorna a resposta ao cliente

4. Se a chave J√Å existir:
   - N√£o executa a opera√ß√£o novamente
   - Retorna exatamente o mesmo resultado da primeira execu√ß√£o
</code></pre>

                            <br />

                            <p>
                                Para que o servidor retorne o resultado da primeira execu√ß√£o, √© necess√°rio armazenar
                                essa <code>Idempotency-Key</code> junto com o resultado.
                            </p>
                            <p>
                                Normalmente esse armazenamento √© feito em um banco de dados de r√°pido acesso e que
                                possua funcionalidade de TTL, pois idempotency-key √© uma informa√ß√£o que deve ser
                                descartada depois de um tempo, como um Redis ou Memcached.
                            </p>
                            <p>
                                No meu caso, optei por utilizar redis. Com redis o fluxo do exemplo, mais detalhado √©
                                assim:
                            </p>
                            <pre><code>
POST /orders
Headers:
  Idempotency-Key: 8f1a2c9e-...

Funcionamento t√≠pico:

1. A API recebe a requisi√ß√£o e extrai o header Idempotency-Key.

2. A API consulta o Redis usando a chave de idempot√™ncia:
   - GET idempotency:8f1a2c9e-...

3. Caso a chave N√ÉO exista:
   - Cria um registro no Redis com status "processing"
   - Define um TTL para essa chave
   - Executa a l√≥gica principal (ex: cria√ß√£o do pedido)
   - Ao final, atualiza o registro com:
     - status: "completed"
     - response: payload da resposta
     - http_status: 201

4. Caso a chave J√Å exista:
   - A API N√ÉO executa a l√≥gica novamente
   - Retorna exatamente a mesma resposta armazenada
     (mesmo status HTTP e mesmo payload)

5. Ap√≥s o tempo definido no TTL:
   - A chave √© automaticamente removida do Redis
   - A opera√ß√£o pode ser executada novamente com uma nova Idempotency-Key
</code></pre>

                            <p>
                                √â importante entender que idempot√™ncia n√£o √© um recurso do HTTP ou uma regra do REST.
                                idempot√™ncia, √© considerado um <strong>contrato</strong> entre a api e o cliente, ou
                                seja, uma regra definida entre ambas as partes para garantir que uma opera√ß√£o n√£o seja
                                duplicada.
                            </p>

                            <p>
                                Segue abaixo a implementa√ß√£o de um fluxo de cria√ß√£o de um boardgame, que implementa
                                chave de idempot√™ncia.
                            </p>

                            <details>
                                <summary>Declarando endpoint com obrigatoriedade da idepotencyKey.</summary>
                                <pre><code>
app.post(
        '/boardgames',
        {
            schema: {
                params: {
                    type: 'object',
                    required: ['usuarioId'],
                    properties: {
                        usuarioId: { type: 'number', minimum: 0 },
                    },
                },
                body: {
                    type: 'array',
                    minItems: 1,
                    items: {
                        type: 'object',
                        required: ['nome', 'descricao', 'complexidade'],
                        properties: {
                            nome: { type: 'string' },
                            descricao: { type: 'string' },
                            complexidade: { type: 'number' },
                            idade: { type: 'number' },
                            tempo: { type: 'number' },
                            ano: { type: 'number' },
                        },
                    },
                },
                headers: {
                    type: 'object',
                    required: ['idempotencykey'],
                    properties: {
                        idempotencykey: { type: 'string' },
                    },
                },
            },
        },
        async (request, reply) =>
            boardgameController.createBoardgame(request, reply)
    );
</code></pre>
                            </details>
                            <details>
                                <summary>Declarando createBoardgame() em boardgameController.ts.</summary>
                                <p>
                                    Perceba que eu retorno <code>201</code> caso o boardgame seja criado, e
                                    <code>200</code> caso o boardgame j√° exista e foi detectado pela chave idempotencia.
                                </p>
                                <pre><code>
    async createBoardgame(
        request: FastifyRequest,
        reply: FastifyReply
    ): Promise&gt;undefined&lt; {
        try {
            const newBoardgame = request.body as BoardgameDto;
            const idempotencykey = request.headers.idempotencykey as string;
            const { usuarioId } = request.params as { usuarioId: number };

            const Boardgame = await this.boardgameService.createBoardgame(
                newBoardgame,
                usuarioId,
                idempotencykey
            );

            return reply.code(Boardgame?.created ? 201 : 200).send(Boardgame);
        } catch (error) {
            this.throwResponseException(error, reply);
        }
    }
</code></pre>
                            </details>
                            <details>
                                <summary>Declarando createBoardgame() em boardgameService.ts.</summary>
                                <pre><code>
    async createBoardgame(
        newBoardgame: BoardgameDto,
        usuarioId: number,
        idempotencyKey: string
    ): Promise&gt;BoardgameDto&lt; {
        try {
            let id: string | null = null;

            if (idempotencyKey) {
                id = await this.BoardgameRepository.getBoardgameIdempotencyKey(
                    idempotencyKey
                );
            }

            if (id !== null) {
                const getBoardgame =
                    await this.BoardgameRepository.getBoardgameById(Number(id));

                return {
                    nome: getBoardgame!.nome,
                    descricao: getBoardgame!.descricao,
                    ano: getBoardgame!.ano,
                    complexidade: getBoardgame!.complexidade,
                    idade: getBoardgame!.idade,
                    tempo: getBoardgame!.tempo,
                } as BoardgameDto;
            }

            const boardgame = await this.BoardgameRepository.createBoardgame(
                newBoardgame,
                usuarioId
            );

            await this.BoardgameRepository.createBoardgameIdempotencyKey(
                boardgame.id,
                idempotencyKey
            );

            return {
                ...boardgame,
                created: true,
            } as BoardgameDto;
        } catch (error: unknown) {
            if (
                error instanceof PrismaClientKnownRequestError &&
                error.code === 'P2002'
            ) {
                throw new DuplicateBoardgameError();
            }

            console.error('Erro interno ao criar o boardgame:', error);
            throw new InternalError();
        }
    }
</code></pre>
                            </details>

                            <details>
                                <summary>Declarando m√©todos do Redis e Prisma no boardgameRepository.</summary>

                                <pre>
                                    <code>
// Prefixo das chaves de idempotencia                                        
const idempotencyKeyPrefix: string = 'idempotency:';
const idempotencyBoardgameIdPrefix: string = 'idempotency:boardgame:';
                                        
// Leitura de chave de idempotencia                                        
async getBoardgameIdempotencyKey(key: string): Promise&gt;string | null&lt; {
    return await redis.get(`${idempotencyKeyPrefix}${key}`);
}</code></pre>

                                <pre>
                                    <code>
// Armazenando chave de idempotencia + id do boardgame criado na opera√ß√£o                                      
    async createBoardgameIdempotencyKey(
        id: number,
        key: string
    ): Promise&gt;undefined&lt; {
        const idempotencyKey = `${idempotencyKeyPrefix}${key}`;
        const reverseIndex = `${idempotencyBoardgameIdPrefix}${id}`;

        await redis.set(idempotencyKey, id, {
            expiration: {
                type: 'EX',
                value: 3600,
            },
        });
        await redis.set(reverseIndex, idempotencyKey, {
            expiration: {
                type: 'EX',
                value: 3600,
            },
        });
    }
</code></pre>

                                <pre>
                                    <code>
// Armazenando chave de idempotencia + id do boardgame criado na opera√ß√£o                                      
    async createBoardgameIdempotencyKey(
        id: number,
        key: string
    ): Promise&gt;undefined&lt; {
        const idempotencyKey = `${idempotencyKeyPrefix}${key}`;
        const reverseIndex = `${idempotencyBoardgameIdPrefix}${id}`;

        await redis.set(idempotencyKey, id, {
            expiration: {
                type: 'EX',
                value: 3600,
            },
        });
        await redis.set(reverseIndex, idempotencyKey, {
            expiration: {
                type: 'EX',
                value: 3600,
            },
        });
    }
</code></pre>

                                <pre>
                                    <code>
// Obtendo boardgame pelo id (esse m√©todo ser√° utilizado dentro do createBoardgame caso exista a chave idempotencia)                                 
    async getBoardgameById(id: number): Promise&gt;Boardgame | null&lt; {
        return await prisma.boardgame.findUnique({
            where: {
                id: Number(id),
            },
        });
    }
</code></pre>

                                <pre>
                                    <code>
// Criando boardgame
    async createBoardgame(
        newBoardgame: BoardgameDto,
        usuarioId: number
    ): Promise&gt;Boardgame&lt; {
        return await prisma.boardgame.create({
            data: {
                nome: newBoardgame.nome,
                descricao: newBoardgame.descricao,
                complexidade: newBoardgame.complexidade,
                ano: newBoardgame.ano,
                idade: newBoardgame.idade,
                tempo: newBoardgame.tempo,
                usuarioId: usuarioId,
            },
        });
    }
</code></pre>
                            </details>
                        </div>

                        <div id="put-patch-delete" class="blog-text">
                            <h1 class="h4 portfolio-title">PUT / PATCH / DELETE</h1>

                            <p>
                                Decidi agrupar os m√©todos <strong>PUT</strong>, <strong>PATCH</strong> e
                                <strong>DELETE</strong> em um √∫nico t√≥pico, pois eles n√£o possuem mecanismos espec√≠ficos
                                t√£o complexos quanto GET ou POST. Ou seja, nesses m√©todo n√£o costuma ser comum
                                mecanismos como idempotencia, caching, content-negociation e etc. Ainda assim, s√£o
                                m√©todos fundamentais e merecem destaque, com o objetivo de esclarecer suas
                                funcionalidades, diferen√ßas e boas pr√°ticas de uso, concluindo assim os cinco m√©todos
                                HTTP mais utilizados em APIs REST.
                            </p>

                            <p>
                                Come√ßando pelo <strong>PUT</strong>, esse m√©todo HTTP tem como objetivo
                                <strong>alterar um recurso j√° existente</strong>. Seu uso ideal consiste em enviar
                                <strong>toda a representa√ß√£o do recurso</strong> no corpo da requisi√ß√£o para que a
                                atualiza√ß√£o seja realizada.
                            </p>

                            <p>
                                Para ficar mais claro, imagine um endpoint <code>PUT /usuarios/:id</code>, respons√°vel
                                por modificar os dados de um usu√°rio na base de dados. Nesse caso, todas as informa√ß√µes
                                do usu√°rio devem ser enviadas no payload, como <code>email</code>,
                                <code>username</code>, <code>foto</code>, entre outras. Ou seja, o PUT representa uma
                                <strong>atualiza√ß√£o completa</strong> do recurso.
                            </p>

                            <p>
                                J√° o <strong>PATCH</strong> possui um prop√≥sito diferente. Um endpoint do tipo PATCH
                                indica que apenas algumas <strong>propriedades espec√≠ficas</strong> do recurso ser√£o
                                atualizadas. Enquanto o PUT realiza uma atualiza√ß√£o <strong>completa</strong>, o PATCH
                                representa uma atualiza√ß√£o <strong>parcial</strong>. Por exemplo, se existir um endpoint
                                destinado exclusivamente √† atualiza√ß√£o da <code>foto</code> do usu√°rio, o m√©todo PATCH √©
                                o mais indicado, pois n√£o h√° necessidade de enviar todas as demais informa√ß√µes, como
                                email ou username.
                            </p>

                            <p>
                                Na pr√°tica, √© comum ver o PUT sendo utilizado de forma imprecisa sempre que o objetivo √©
                                alterar um recurso. Para evitar esse tipo de ambiguidade, costumo utilizar a seguinte
                                pergunta como regra pr√°tica:
                                <strong
                                    >√© necess√°rio enviar toda a representa√ß√£o do recurso para realizar essa
                                    atualiza√ß√£o?</strong
                                >
                                Se a resposta for sim, o PUT √© a melhor escolha; caso contr√°rio, o PATCH tende a ser
                                mais adequado.
                            </p>

                            <p>
                                Vale ressaltar que √© uma boa pr√°tica retornar o dado atualizado depois que a altera√ß√£o
                                foi concluida com sucesso em um PUT ou PATCH. Assim o frontend (ou quem estiver
                                consumindo), j√° receber√° no response a informa√ß√£o em seu estado final.
                            </p>

                            <p>
                                Por fim, temos o m√©todo <strong>DELETE</strong>, cujo objetivo √© remover um recurso do
                                servidor. Assim como o PUT, o DELETE atua sobre um recurso espec√≠fico, geralmente
                                identificado por um <code>id</code> na URL, como em <code>DELETE /usuarios/:id</code>.
                            </p>

                            <p>
                                Quando um DELETE √© executado com sucesso, espera-se que o recurso n√£o esteja mais
                                dispon√≠vel para futuras consultas. Em APIs REST, √© comum que esse m√©todo retorne um
                                <code>204 No Content</code>, indicando que a opera√ß√£o foi realizada corretamente, mas
                                sem a necessidade de retornar um corpo na resposta.
                            </p>

                            <p>
                                Conceitualmente, o DELETE √© considerado um m√©todo <strong>idempotente</strong> (assim
                                como o PUT, PATCH e GET). Isso significa que m√∫ltiplas requisi√ß√µes DELETE para o mesmo
                                recurso produzem o mesmo efeito final: o recurso deixa de existir. Caso o recurso j√°
                                tenha sido removido, a API pode retornar um <code>404 Not Found</code> ou simplesmente
                                manter o <code>204</code>, dependendo da estrat√©gia adotada.
                            </p>

                            <p>
                                √â importante destacar que, na pr√°tica, o DELETE nem sempre representa uma remo√ß√£o f√≠sica
                                do dado. Em muitos cen√°rios, especialmente quando h√° requisitos de auditoria ou
                                hist√≥rico, utiliza-se o conceito de
                                <strong>soft delete</strong>, onde o recurso √© apenas marcado como inativo, permanecendo
                                armazenado na base de dados, mas indispon√≠vel para uso normal da API.
                            </p>
                        </div>
                        <div id="cors" class="blog-text">
                            <h1 class="h4 portfolio-title">OPTIONS e CORS</h1>

                            <p>
                                Existe um m√©todo HTTP que √© amplamente utilizado pelos navegadores para a valida√ß√£o
                                autom√°tica de <strong>CORS</strong>: o <code>OPTIONS</code>.
                            </p>

                            <p>
                                Vamos por partes. O m√©todo <code>OPTIONS</code> tem como objetivo informar quais
                                opera√ß√µes s√£o permitidas para um determinado recurso. Em outras palavras, ele permite
                                que o cliente verifique se uma determinada requisi√ß√£o HTTP pode ou n√£o ser realizada.
                            </p>

                            <p>
                                Por exemplo, antes de executar uma requisi√ß√£o
                                <code>GET /users</code>, o navegador pode realizar previamente uma chamada
                                <code>OPTIONS /users</code>. Se essa chamada retornar um status <strong>2xx</strong> e
                                os cabe√ßalhos esperados, significa que a requisi√ß√£o real est√° autorizada a ser enviada.
                            </p>

                            <p>
                                Na pr√°tica, o m√©todo <code>OPTIONS</code> raramente √© implementado de forma expl√≠cita em
                                APIs REST. Na maioria dos casos, ele √© tratado automaticamente pelo servidor ou pelo
                                framework web, existindo principalmente para dar suporte aos mecanismos de seguran√ßa do
                                navegador.
                            </p>

                            <p>
                                J√° o <strong>CORS</strong> (Cross-Origin Resource Sharing) √© uma pol√≠tica de seguran√ßa
                                imposta pelos navegadores. Se voc√™ desenvolve aplica√ß√µes web, √© muito prov√°vel que j√°
                                tenha se deparado com erros relacionados a CORS.
                            </p>

                            <p>
                                Essa pol√≠tica √© nativa dos navegadores e tamb√©m est√° presente nos clientes HTTP
                                utilizados por frameworks SPA, como Angular, React e Vue. √â importante destacar que
                                <strong>CORS n√£o existe em comunica√ß√µes backend-to-backend</strong>. Ou seja, uma API
                                consumindo outra API n√£o sofre qualquer restri√ß√£o de CORS.
                            </p>

                            <p>
                                O CORS existe para impedir que o JavaScript processe respostas de APIs que n√£o foram
                                explicitamente autorizadas pelo servidor, protegendo o usu√°rio contra acessos indevidos
                                a recursos de outras origens.
                            </p>
                        </div>

                        <div id="errors-responses" class="blog-text">
                            <h1 class="h4 portfolio-title">Responses e erros</h1>

                            <p>
                                Neste t√≥pico vou abordar uma coisa que iniciantes costumam negligenciar: o
                                <strong>response</strong>
                                da API. A ideia aqui √© discutir tanto os cen√°rios de sucesso quanto os de erro, e como
                                essas respostas devem ser estruturadas.
                            </p>

                            <p>
                                Se eu tivesse que resumir este t√≥pico em duas palavras, seriam:
                                <strong>previsibilidade</strong> e <strong>seguran√ßa</strong>. √â muito comum ver APIs
                                ignorando completamente os c√≥digos de status HTTP ou, pior ainda, implementando tabelas
                                pr√≥prias de c√≥digos de erro. Particularmente, n√£o entendo quem faz isso, j√° que o
                                protocolo HTTP j√° define de forma clara e padronizada os
                                <a
                                    href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Reference/Status"
                                    target="_blank"
                                    class="blog-link"
                                >
                                    c√≥digos de status de resposta HTTP </a
                                >, amplamente conhecidos e suportados por qualquer cliente.
                            </p>

                            <p>
                                Independentemente do endpoint, o formato do response deve ser
                                <strong>previs√≠vel</strong>. Um padr√£o precisa ser definido e aplicado de forma
                                consistente em toda a API, por exemplo:
                            </p>

                            <pre><code>
{
  "data": {...},
  "meta": {...},
  "errors": []
}
</code></pre>

                            <p>
                                Al√©m disso, o c√≥digo de status HTTP deve ser coerente com o payload retornado. Em
                                cen√°rios de sucesso, utilize a fam√≠lia <strong>2xx</strong> e n√£o retorne erros. Para
                                falhas causadas pelo cliente, utilize c√≥digos <strong>4xx</strong> acompanhados de
                                mensagens claras e objetivas, indicando exatamente o que est√° errado. J√° em erros
                                internos ou inesperados, utilize a fam√≠lia <strong>5xx</strong>, retornando uma mensagem
                                gen√©rica o suficiente para n√£o comprometer a seguran√ßa da aplica√ß√£o.
                            </p>

                            <p>De forma geral, os c√≥digos de status mais comuns e utilizados s√£o:</p>

                            <pre><code>
2xx ‚Äì Sucesso

    200 OK ‚Üí resposta padr√£o

    201 Created ‚Üí recurso criado (normalmente com header Location)

    204 No Content ‚Üí sucesso sem body

4xx ‚Äì Erro do cliente

    400 Bad Request ‚Üí payload inv√°lido

    401 Unauthorized ‚Üí n√£o autenticado

    403 Forbidden ‚Üí autenticado, mas sem permiss√£o

    404 Not Found ‚Üí recurso n√£o encontrado

    409 Conflict ‚Üí conflito de estado (ex: duplicidade)

    422 Unprocessable Entity ‚Üí erro de valida√ß√£o sem√¢ntica

5xx ‚Äì Erro do servidor

    500 Internal Server Error

    503 Service Unavailable 
</code></pre>

                            <p>
                                Ao longo da minha trajet√≥ria no desenvolvimento web, percebi que muitas APIs em
                                produ√ß√£o, em situa√ß√µes de erro <strong>500</strong>, acabam retornando para o cliente a
                                <strong>stacktrace</strong> completa da exce√ß√£o. Isso √© considerado uma falha de
                                seguran√ßa <strong>grave</strong>.
                            </p>

                            <p>
                                A stacktrace exp√µe detalhes internos da aplica√ß√£o, como nomes de classes, m√©todos,
                                pacotes e, em alguns casos, at√© erros de SQL contendo nomes de tabelas e colunas. Esse
                                tipo de informa√ß√£o √© um verdadeiro prato cheio para um atacante, pois a API acaba
                                entregando um ‚Äúmapa‚Äù da sua estrutura interna. Stacktraces devem ser registradas apenas
                                em <strong>logs internos</strong>, com acesso restrito √† equipe respons√°vel.
                            </p>

                            <p>
                                Al√©m disso, ao revelar nomes de arquivos e estruturas internas, muitas vezes √© poss√≠vel
                                identificar o framework web utilizado e at√© mesmo sua vers√£o. Com essa informa√ß√£o em
                                m√£os, um atacante pode pesquisar e explorar vulnerabilidades conhecidas associadas
                                √†quela vers√£o espec√≠fica do framework ou de bibliotecas utilizadas. Por isso,
                                <strong>nunca</strong> retorne mensagens de erro internas para o cliente.
                            </p>

                            <p>
                                Felizmente, muitos frameworks web j√° oferecem mecanismos padr√£o para evitar o retorno de
                                stacktraces em ambientes de produ√ß√£o ‚Äî o Fastify √© um bom exemplo. No entanto, at√© onde
                                sei, o Express n√£o oferece essa prote√ß√£o de forma nativa. Em caso de d√∫vida, implemente
                                um <strong>error handler</strong> global e fa√ßa o mapeamento adequado dos erros da sua
                                API, garantindo respostas seguras e padronizadas.
                            </p>
                            <p>
                                Grande parte dos erros da fam√≠lia <strong>4xx</strong> ocorre durante a valida√ß√£o das
                                <strong>DTOs</strong> enviadas pelo cliente. Em muitos casos, esses erros s√£o tratados e
                                retornados automaticamente pelo pr√≥prio framework, o que costuma ser uma excelente
                                pr√°tica. Frameworks web maduros prezam por respostas de erro claras e padronizadas,
                                informando exatamente <em>qual campo est√° inv√°lido</em> e
                                <em>qual regra de valida√ß√£o foi violada</em>, facilitando o tratamento do erro por quem
                                consome a API. A seguir, veja um exemplo de resposta de erro gerada automaticamente pelo
                                <strong>Fastify</strong> durante a valida√ß√£o de um payload:
                            </p>

                            <pre><code>
{
  "statusCode": 400,
  "code": "FST_ERR_VALIDATION",
  "error": "Bad Request",
  "message": "body/email must match format \"email\""
}    
</code></pre>

                            <p>
                                Esse tipo de resposta torna o consumo da API mais previs√≠vel e reduz a necessidade de
                                l√≥gica adicional no backend para tratamento de valida√ß√µes simples, al√©m de oferecer
                                feedback imediato e preciso para o cliente.
                            </p>

                            <p>
                                Em resumo, para tornar os responses da sua API REST previsivel, defina e utilize um
                                padr√£o de response, utilize os c√≥digos de status http para respostas de forma coerente.
                                E para tornar sua API segura, crie hanglers para mapear os errps da api, evitando
                                retorno de informa√ß√£o sensivel quando erros internos ocorrerem.
                            </p>
                        </div>
                    </section>

                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
        <script type="module">
            import { loadSideBarBlog } from '../../assets/js/elements/sidebar.js';

            const sections = [
                { id: 'intro', label: 'Introdu√ß√£o' },
                { id: 'api', label: 'O que √© uma API' },
                { id: 'api-rest', label: 'O que √© uma API REST/RESTFUL' },
                { id: 'stateless-vs-stateful', label: 'Stateless vs Stateful' },
                { id: 'get', label: 'GET' },
                { id: 'post', label: 'POST' },
                { id: 'put-patch-delete', label: 'PUT/PATCH/DELETE' },
                { id: 'cors', label: 'OPTIONS e CORS' },
                { id: 'errors-responses', label: 'Response e erros' },
                { id: 'auth', label: 'Autentica√ß√£o vs Autoriza√ß√£o' }, //rate limiting
                { id: 'version-log', label: 'Versionamento e Monitoramento' },
                { id: 'conclusion', label: 'Conclus√£o' },
                { id: 'refs', label: 'Refer√™ncias' }
            ];

            loadSideBarBlog(sections);
        </script>
    </body>
</html>
