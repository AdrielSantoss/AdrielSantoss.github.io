<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Rest</title>
        <link rel="stylesheet" href="../../../assets/css/style.css" />
        <link rel="stylesheet" href="../../../assets/css/changes.css" />
    </head>
    <body>
        <main class="main-body">
            <div class="main-content">
                <article>
                    <section>
                        <h1 class="h4 portfolio-title">Entendendo Apis, Rest e Restful</h1>

                        <div>
                            <small style="color: white">10/11/2025</small> -
                            <a
                                href="https://github.com/AdrielSantoss/API-Architectures"
                                target="_blank"
                                class="blog-link"
                                >Projeto (Github)</a
                            >
                        </div>

                        <div class="tags">
                            <small class="tag">Node</small>
                            <small class="tag">Typescript</small>
                            <small class="tag">Arquitetura</small>
                            <small class="tag">Rest</small>
                            <small class="tag">Restful</small>
                            <small class="tag">Fastify</small>
                            <small class="tag">Prisma</small>
                            <small class="tag">ORM</small>
                            <small class="tag">Teste automatizado</small>
                        </div>
                    </section>

                    <br />

                    <section class="portfolio-description">
                        <div id="intro" class="blog-text">
                            <p>
                                Entre 2019 e 2020, eu desenvolvia diversas APIs REST em Node.js, utilizando o
                                <a href="https://expressjs.com" target="_blank" class="blog-link">Express</a>
                                para criar o servidor HTTP e o ORM
                                <a href="https://knexjs.org" target="_blank" class="blog-link">Knex</a>
                                para modelar as tabelas do banco de dados.
                            </p>

                            <p>
                                Desde ent√£o, acabei me afastando um pouco do ecossistema Node, e nesse meio tempo
                                surgiram (ou se popularizaram) v√°rios frameworks e bibliotecas modernas ‚Äî como o
                                <a href="https://fastify.dev" target="_blank" class="blog-link">Fastify</a>, que oferece
                                uma performance excelente na cria√ß√£o de servidores web, e o ORM
                                <a href="https://www.prisma.io/docs/getting-started" target="_blank" class="blog-link"
                                    >Prisma</a
                                >, que traz uma linguagem de modelagem intuitiva, configura√ß√£o simples e √≥timo
                                desempenho.
                            </p>

                            <p>
                                Naquela √©poca, eu ainda n√£o utilizava TypeScript e recorria ao
                                <a href="https://jestjs.io" target="_blank" class="blog-link">Jest</a>
                                para implementar testes unit√°rios e de integra√ß√£o nas APIs.
                            </p>

                            <p>
                                Hoje percebo que o Knex tem recebido poucas atualiza√ß√µes e parece ter ficado atr√°s do
                                Prisma em termos de recursos e praticidade. O Express continua sendo uma √≥tima escolha,
                                mas o Fastify vem se destacando em performance e escalabilidade. J√° o Jest, por n√£o
                                oferecer suporte nativo a TypeScript em APIs Node, tem perdido espa√ßo para ferramentas
                                mais modernas como o
                                <a href="https://vitest.dev" target="_blank" class="blog-link">Vitest</a>.
                            </p>

                            <p>
                                Na verdade isso √© um processo natural: bibliotecas surgem, se popularizam, e depois de
                                um tempo morrem, perdem espa√ßo para uma nova biblioteca que dominou a √°rea. Por isso, eu
                                n√£o gosto de escrever sobre bibliotecas e frameworks, pois esse conte√∫do costuma se
                                <strong>defazar</strong> muito r√°pido. Nesse blog, o objetivo √© falar sobre conceitos do
                                estilo arquitetural REST, o foco n√£o √© as novas bibliotecas, elas foram apenas o gatilho
                                que me motivou a fazer esse projeto/estudo.
                            </p>

                            <p>
                                A comunidade JavaScript/Node √© extremamente ativa ‚Äî as tecnologias evoluem r√°pido e, na
                                maioria das vezes, para melhor. Por isso, recentemente decidi revisitar meus
                                conhecimentos de REST na pr√°tica, criando um servidor HTTP com Node + TypeScript +
                                Fastify + Prisma + Vitest, entre outras ferramentas.
                            </p>

                            <p>
                                Al√©m de relembrar conceitos, quero aproveitar essa oportunidade para pesquisar e
                                aprender coisas novas.
                            </p>
                        </div>

                        <div id="api" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API</h1>

                            <p>
                                Primeiro, devemos entender o que √© uma Api: API √© a sigla para Application Programming
                                Interface (em portugu√™s, Interface de Programa√ß√£o de Aplica√ß√µes).
                            </p>

                            <p>
                                Em resumo, API √© um meio de <strong>comunica√ß√£o</strong> entre dois sistemas, entenda
                                API como um conjunto de regras, protocolos e ferramentas que permite que diferentes
                                softwares se comuniquem e troquem informa√ß√£o.
                            </p>

                            <p>
                                Quando criamos uma API, basicamente estamos criando um tipo de software que define uma
                                <strong>interface</strong> para outros sistemas se comunicarem com ele ‚Äî expondo dados e
                                funcionalidades de forma controlada e padronizada.
                            </p>
                            <p>
                                Quando falamos "interface" j√° vem logo na cabe√ßa as interfaces gr√°ficas, esses erros s√£o
                                comuns para quem est√° come√ßando a entrar no mundo da web, a √°rea da programa√ß√£o possui
                                uma sopa de letrinhas absurda, ent√£o, para n√£o ocorrer confus√µes vamos destacar o que
                                uma API n√£o √©:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Uma api n√£o √© um banco de dados:</strong> Uma API
                                    <strong>acessa</strong> um banco de dados, mas ela n√£o √© o banco de dados. Api,
                                    normalmente n√£o armazenam dados, ela age como um
                                    <strong>intermedi√°rio</strong> entre o cliente e a fonte de dados.
                                </li>
                                <br />

                                <li>
                                    <strong>2. Uma API n√£o √© uma interface gr√°fica (UI):</strong> API significa
                                    Interface de Programa√ß√£o, n√£o Interface de Usu√°rio. Ela n√£o tem bot√µes, telas nem
                                    layouts ‚Äî quem interage com ela s√£o outros programas, n√£o pessoas diretamente.
                                </li>
                                <br />

                                <li>
                                    <strong>3. Uma API n√£o √© um servidor web:</strong> Esse √© um erro
                                    <strong>muito comum</strong>, vejo muitos programadores falando "√§pi √© o servidor da
                                    aplica√ß√£o", isso est√° completamenta <strong>errado</strong>. O servidor (Express,
                                    Django, Laravel e etc) √© quem <strong>hospeda</strong> a API e processa as
                                    requisi√ß√µes. A API √© o conjunto de regras e endpoints implementados
                                    <strong>dentro</strong> desse servidor.
                                </li>
                                <br />

                                <li>
                                    <strong>4. Uma API n√£o √© automaticamente REST:</strong> Esse √© um erro
                                    <strong>cl√°ssico</strong>, REST √© um entre v√°rios estilos de arquiteturas de API,
                                    existem outros como: SOAP, GraphQL, gRPC e etc... Cada um definem suas regras para a
                                    interface de comunica√ß√£o. REST √© o estilo mais popular e mais adotado no mercado,
                                    por isso, muita gente confunde pensando que api e rest s√£o conceitos equivalentes.
                                </li>
                                <br />

                                <li>
                                    <strong>5. API n√£o √© backend:</strong> A API faz <strong>parte</strong> do teu
                                    backend, mas ela n√£o representa o teu backend. A API √© uma camada respons√°vel expor
                                    dados e funcionalidades do teu backend. A API sozinha n√£o serve pra nada, ela
                                    precisa de um backend e ou uma fonte de dados para expor.
                                </li>

                                <br />

                                <li>
                                    <strong>6. Nem toda API √© web:</strong> Nem toda api √© web, ou seja, nem toda api
                                    utiliza o HTTP para comunica√ß√£o, existem Apis de sistemas locais, APIs que permitem
                                    a comunica√ß√£o entre aplica√ß√µes e o sistema operacional, sem usar rede.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Removendo essas confus√µes de conceitos no meio do caminho, podemos visualizar o destino
                                com mais clareza, uma API n√£o √© nada mais que uma interface de comunica√ß√£o entre
                                softwares.
                            </p>

                            <p>Agora, exemplos reais do que √© uma API:</p>

                            <pre><code>
+----------------------------------------------------------------------------------------------+
| TIPO DE API                  | EXEMPLOS                               | DESCRI√á√ÉO            |
|------------------------------|----------------------------------------|----------------------|
| üåê Web (REST ou HTTP)        | GitHub, OpenWeather, Stripe, Spotify,  | APIs acessadas via   |
|                              | Google Maps                            | internet, trocam     |
|                              |                                        | dados em JSON via    |
|                              |                                        | HTTP (REST, GraphQL) |
|------------------------------|----------------------------------------|----------------------|
| üß© Sistema (locais)          | Win32 (Windows), POSIX (Linux),        | Interfaces entre     |
|                              | Android SDK, Cocoa (macOS)             | apps e o sistema     |
|                              |                                        | operacional. N√£o     |
|                              |                                        | usam HTTP.           |
|------------------------------|----------------------------------------|----------------------|
| üíª Biblioteca (linguagens)   | DOM (JavaScript), os (Python), fs      | APIs usadas dentro   |
|                              | (Node.js)                              | do c√≥digo para       |
|                              |                                        | acessar recursos ou  |
|                              |                                        | fun√ß√µes prontas.     |
|------------------------------|----------------------------------------|----------------------|
| ü§ñ Hardware                  | DirectX, OpenGL, Vulkan, Bluetooth     | APIs que permitem    |
|                              |                                        | apps se comunicarem  |
|                              |                                        | com hardware.        |
+----------------------------------------------------------------------------------------------+</code></pre>
                        </div>

                        <div id="api-rest" class="blog-text">
                            <h1 class="h4 portfolio-title">O que √© uma API REST</h1>

                            <p>
                                Uma API REST √© um tipo espec√≠fico de API baseada no protocolo HTTP e fundamentada na
                                arquitetura cliente-servidor. REST ‚Äî sigla para Representational State Transfer ‚Äî √© um
                                estilo de arquitetura criado por
                                <a href="https://github.com/royfielding" target="_blank" class="blog-link"
                                    >Roy Fielding</a
                                >
                                em 2000, na sua
                                <a
                                    href="https://ics.uci.edu/~fielding/pubs/dissertation/top.htm"
                                    target="_blank"
                                    class="blog-link"
                                    >tese de doutorado.</a
                                >
                            </p>

                            <p>
                                Embora o termo ‚Äúarquitetura REST‚Äù seja comum no mercado, tecnicamente REST
                                <strong>n√£o √© uma arquitetura em si</strong> , mas sim um
                                <strong>estilo arquitetural</strong> composto por restri√ß√µes aplicadas sobre uma
                                arquitetura cliente-servidor. Ele orienta o design de sistemas distribu√≠dos, mas n√£o
                                define por completo a arquitetura de uma aplica√ß√£o. Entenda que arquitetura √© o projeto
                                e um estilo arquitetural s√£o as regras definidas para construir esse projeto ‚Äî Rest √©
                                exatamente isso, um conjunto de regras que orientam a cria√ß√£o de uma aplica√ß√£o
                                cliente-servidor.
                            </p>

                            <p>
                                No final da d√©cada de 1990, <strong>Roy Fielding</strong> fazia parte do grupo
                                respons√°vel por padronizar o protocolo <strong>HTTP</strong> e projetar a arquitetura da
                                Web. Ele foi um dos principais autores da vers√£o 1.1 do HTTP. Essa √©poca representava o
                                in√≠cio da Web moderna, e a comunica√ß√£o entre sistemas na internet ainda era
                                inconsistente ‚Äî cada aplica√ß√£o tinha seu pr√≥prio estilo de API. Fielding percebeu que,
                                para a Web continuar evoluindo, seria necess√°rio definir princ√≠pios arquiteturais claros
                                e universais.
                            </p>

                            <p>
                                Em seus estudos, Roy Fielding analisou por que a Web (baseada em <strong>HTTP</strong>,
                                <strong>URLs</strong> e <strong>HTML</strong>) conseguia escalar para milh√µes de
                                usu√°rios, enquanto outras arquiteturas falhavam. A partir dessas observa√ß√µes, ele
                                definiu um conjunto de princ√≠pios arquiteturais que explicavam o sucesso da Web ‚Äî e
                                chamou esse estilo de <strong>REST</strong>.
                            </p>

                            <p>
                                Uma <strong>API REST</strong> utiliza os recursos da Web para representar entidades do
                                sistema, como usu√°rios, produtos, pedidos, entre outros. Cada recurso √© acessado por
                                meio de uma <strong>URL</strong> (Uniform Resource Locator), e as opera√ß√µes sobre esses
                                recursos s√£o realizadas atrav√©s dos <strong>m√©todos HTTP</strong>.
                            </p>

                            <p>
                                Resumidamente, uma API REST funciona por meio de
                                <strong>requisi√ß√µes</strong> (<em>requests</em>) e
                                <strong>respostas</strong> (<em>responses</em>). A <em>request</em> √© uma chamada HTTP
                                feita pelo cliente, e a <em>response</em> √© a resposta do servidor. O formato de dados
                                mais comum nessa comunica√ß√£o √© o <strong>JSON</strong> (<em
                                    >JavaScript Object Notation</em
                                >).
                            </p>

                            <p>
                                O <strong>REST</strong> foi um dos principais motivos da populariza√ß√£o do
                                <strong>JSON</strong>. Antes dele, o padr√£o dominante era o <strong>SOAP</strong>, que
                                utilizava <strong>XML</strong> para troca de dados. Comparado ao JSON, o XML √© mais
                                <strong>pesado</strong> ‚Äî tanto em tamanho quanto em processamento ‚Äî, pois exige um
                                <em>parsing</em> mais complexo, al√©m de aumentar o tamanho do texto com suas m√∫ltiplas
                                tags, tornando o conte√∫do mais verboso e de leitura dif√≠cil para humanos.
                            </p>

                            <p>
                                O JSON resolveu todos esses problemas e, desde ent√£o, tornou-se o
                                <code>content-type</code> padr√£o nas APIs REST. No entanto, √© importante destacar que o
                                JSON n√£o surgiu junto com o REST. Ele foi criado por
                                <strong>Douglas Crockford</strong> e surgiu integrado ao <strong>JavaScript</strong>,
                                como uma alternativa mais simples e eficiente ao XML. Com o tempo, acabou sendo adotado
                                naturalmente pelas APIs REST devido √† sua leveza e praticidade.
                            </p>

                            <p>
                                O estilo arquitetural <strong>SOAP</strong> (<em>Simple Object Access Protocol</em>)
                                surgiu inicialmente como uma boa ideia em 1998, mas com o tempo acabou se tornando uma
                                <strong>gambiarra completamente invi√°vel</strong>. O SOAP foi uma evolu√ß√£o do protocolo
                                <strong>XML-RPC</strong> (<em>Remote Procedure Call</em> usando XML), criado por
                                <strong>Dave Winer</strong> no mesmo ano. O objetivo do XML-RPC era permitir que um
                                servidor executasse fun√ß√µes em outro servidor, enviando par√¢metros em XML e recebendo
                                respostas tamb√©m em XML ‚Äî tudo isso utilizando o HTTP como transporte.
                            </p>

                            <p>
                                Ainda em 1998, a <strong>Microsoft</strong> e a <strong>IBM</strong> come√ßaram a
                                colaborar na evolu√ß√£o do XML-RPC, dando origem ao SOAP. O objetivo era criar um padr√£o
                                mais formal, extens√≠vel e corporativo para a comunica√ß√£o entre sistemas. Assim, o SOAP
                                incorporou recursos como <strong>tipagem forte</strong> (baseada em XSD),
                                <strong>suporte a headers</strong> (para autentica√ß√£o, transa√ß√µes, etc.),
                                <strong>extensibilidade</strong> (permitindo adicionar metadados sem quebrar o formato)
                                e <strong>ades√£o aos padr√µes do W3C</strong>.
                            </p>

                            <p>
                                Tudo isso parecia uma boa ideia no in√≠cio, mas desmoronou r√°pido. O SOAP acabou se
                                tornando muito mais complicado do que precisava ser. Para fazer uma requisi√ß√£o simples
                                era necess√°rio lidar com estruturas XML enormes, envelopes, cabe√ßalhos e esquemas (XSD).
                                Al√©m disso, o SOAP exigia o uso de ferramentas espec√≠ficas para gerar c√≥digo,
                                interpretar WSDLs (descri√ß√µes de servi√ßo) e lidar com as regras do protocolo ‚Äî o que
                                tornava tudo lento, burocr√°tico e dif√≠cil de manter.
                            </p>

                            <p>
                                Por exemplo, veja como seria uma requisi√ß√£o simples apenas para buscar as informa√ß√µes de
                                um usu√°rio usando o SOAP:
                            </p>

                            <pre><code class="language-xml">
POST /UserService HTTP/1.1
Host: example.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "getUser"

&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Header/&gt;
  &lt;soap:Body&gt;
    &lt;getUserRequest xmlns="http://example.com/user"&gt;
      &lt;userId&gt;123&lt;/userId&gt;
    &lt;/getUserRequest&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre>

                            <p>Agora compare com uma requisi√ß√£o REST que faz exatamente a mesma coisa:</p>

                            <pre><code class="language-http">
GET /users/123 HTTP/1.1
Host: example.com
Accept: application/json
</code></pre>

                            <p>E a resposta do servidor REST seria bem mais simples e leg√≠vel:</p>

                            <pre><code class="language-json">
{
  "id": 123,
  "nome": "Adriel",
  "email": "adriel@example.com"
}
</code></pre>

                            <p>
                                Essa diferen√ßa de simplicidade √© o principal motivo da queda do SOAP e da populariza√ß√£o
                                do REST. Enquanto o SOAP exigia XML pesado, contratos WSDL e m√∫ltiplas camadas de
                                abstra√ß√£o, o REST usa os recursos nativos da Web (HTTP, URLs e JSON), tornando o
                                desenvolvimento muito mais leve, r√°pido e acess√≠vel.
                            </p>

                            <p>
                                O SOUP n√£o foi feito para a web moderna, essa arquitetura n√£o respeita os m√©todos HTTP
                                (GET, POST, PUT, DELETE), utiliza sempre POST nas requisi√ß√µes ‚Äî tratando o http apenas
                                como um t√∫nel de transporte, √© totalmente incompativel com caches HTTP e navegadores. J√°
                                REST, n√£o tenta reinventar a roda, ela engloba todos esses recursos do protocolo HTTP ‚Äî
                                Talvez isso se deve ao fato do criador do Rest ser um dos principais fundadores da
                                vers√£o 1.1 do protoclo http.
                            </p>
                        </div>
                        <div id="stateless-vs-stateful" class="blog-text">
                            <h1 class="h4 portfolio-title">Stateless vS Stateful</h1>
                            <p>
                                Uma das principais caracter√≠sticas do REST √© o conceito de
                                <strong>stateless</strong>. Isso significa que o servidor n√£o armazena nenhuma
                                informa√ß√£o sobre o estado da sess√£o do cliente entre as requisi√ß√µes.
                            </p>

                            <p>
                                Em uma arquitetura <strong>stateful</strong>, o servidor precisa manter informa√ß√µes de
                                sess√£o do usu√°rio ‚Äî como dados de autentica√ß√£o ou contexto da intera√ß√£o. Geralmente
                                essas sess√µes s√£o armazenadas em mem√≥ria ou em bancos de dados r√°pidos, como o Redis.
                                Assim, a cada requisi√ß√£o, o servidor consulta o estado previamente salvo para
                                identificar o usu√°rio e continuar o fluxo.
                            </p>

                            <p>
                                J√° em uma API <strong>stateless</strong>, cada requisi√ß√£o deve conter todas as
                                informa√ß√µes necess√°rias para ser processada: autentica√ß√£o, par√¢metros, contexto, entre
                                outros. Um exemplo comum √© o uso de <strong>tokens JWT</strong>, onde o cliente envia o
                                token a cada chamada, permitindo que o servidor valide a requisi√ß√£o sem precisar manter
                                qualquer estado entre uma intera√ß√£o e outra.
                            </p>

                            <p>
                                Atualmente, √© muito mais recomend√°vel implementar uma aplica√ß√£o
                                <strong>stateless</strong> do que <strong>stateful</strong>. Essa prefer√™ncia se deve a
                                v√°rios fatores, tais como:
                            </p>

                            <ul>
                                <li>
                                    <strong>1. Escalabilidade muito mais f√°cil:</strong> Como o servidor n√£o mant√©m
                                    informa√ß√µes de sess√£o, qualquer requisi√ß√£o pode ser atendida por qualquer inst√¢ncia
                                    do backend. Isso facilita o balanceamento de carga, auto-escalonamento e a
                                    distribui√ß√£o da aplica√ß√£o em m√∫ltiplos servidores (microservi√ßos).
                                </li>
                                <br />
                                <li>
                                    <strong>2. Redu√ß√£o de complexidade:</strong> Em sistemas stateless n√£o √© necess√°rio
                                    sincronizar sess√µes, manter caches de estado ou usar bancos como Redis apenas para
                                    armazenar informa√ß√µes tempor√°rias dos usu√°rios. O servidor apenas processa
                                    requisi√ß√µes, tornando o sistema mais simples e robusto.
                                </li>
                                <br />
                                <li>
                                    <strong>3. Maior toler√¢ncia a falhas:</strong> Se uma inst√¢ncia cair, nenhuma sess√£o
                                    √© perdida e outra inst√¢ncia pode assumir imediatamente as requisi√ß√µes. Isso aumenta
                                    a disponibilidade e a resili√™ncia do sistema.
                                </li>
                                <br />
                                <li>
                                    <strong>4. Melhor desempenho em alto tr√°fego:</strong> Cada requisi√ß√£o √© processada
                                    de forma independente, sem necessidade de consultar bancos de sess√£o ou mem√≥ria
                                    compartilhada. Isso reduz a lat√™ncia e melhora a performance.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Existem v√°rios motivos pelos quais uma API <strong>stateless</strong> √© muito mais
                                vantajosa do que uma API <strong>stateful</strong>. No entanto, ainda h√° muitos backends
                                web legados, especialmente aqueles baseados em <strong>MVC</strong>, que funcionam de
                                forma totalmente <strong>stateful</strong>. Nesse tipo de aplica√ß√£o, o servidor costuma
                                controlar praticamente tudo: renderiza√ß√£o de HTML, gerenciamento do fluxo da aplica√ß√£o,
                                autentica√ß√£o baseada em sess√£o e outras responsabilidades centrais.
                            </p>

                            <p>
                                Uma observa√ß√£o importante sobre os termos: quando dizemos que um
                                <strong>servidor</strong> √© stateful, isso automaticamente significa que a
                                <strong>API</strong> tamb√©m √© stateful. Embora servidor e API sejam conceitos
                                diferentes, eles est√£o diretamente conectados ‚Äî se o servidor mant√©m estado entre
                                requisi√ß√µes, a API inevitavelmente deixar√° de ser stateless.
                            </p>

                            <p>
                                O pr√≥prio protocolo <strong>HTTP</strong> √© stateless por natureza. Mas √≥bvio, nem tudo
                                √© t√£o simples... Existem algunas cen√°rios especificos onde implementar uma aplica√ß√£o web
                                <strong>stateless</strong> n√£o √© o ideal.
                            </p>
                            <p>
                                Aplica√ß√µes que necessitam de atualiza√ß√£o em tempo real normalmente s√£o
                                <strong>stateful</strong> com o uso de <strong>WebSockets</strong>.
                            </p>

                            <p>
                                Outros exemplos cl√°ssicos de cen√°rios stateful na Web incluem logins baseados em sess√£o,
                                fluxos de m√∫ltiplas etapas (wizards) e sistemas legados que dependem de sess√µes no
                                servidor.
                            </p>

                            <p>
                                Resumidamente, em grande parte das situa√ß√µes ‚Äî provavelmente mais de 90% ‚Äî um
                                desenvolvedor web lidar√° com aplica√ß√µes <strong>stateless</strong> em vez de
                                <strong>stateful</strong>. Ainda assim, tudo depende do contexto. Compreender a
                                diferen√ßa entre esses dois modelos √© essencial para entender o funcionamento da Web
                                moderna e REST.
                            </p>
                        </div>

                        <div id="get" class="blog-text">
                            <h1 class="h4 portfolio-title">GET</h1>

                            <!-- Adicionar aqui explica√ß√£o sobre endpoints, URLS, URIS e etc -->
                            <!-- Explicar sobre controllers e etc -->

                            <p>
                                Agora vou demonstrar os recursos do REST na pr√°tica em uma api NODE com typescript,
                                utilizando o framework <strong>Fastify</strong> e as demais bibliotecas j√° mencionadas.
                            </p>
                            <p>
                                Vou me concentrar mais na parte da api, ignorando coisas como banco de dados, ORMS e
                                etc.
                            </p>

                            <p>
                                Uma API REST √© orientada a recursos. Isso significa que, para acessar um determinado
                                recurso (como registros de usu√°rios, por exemplo), √© necess√°rio fazer uma chamada HTTP
                                para uma URI espec√≠fica.
                            </p>

                            <p>
                                Com o fastify vou criar as <strong>endpoints</strong> da API. Um endpoint √© um ponto de
                                entrada da API, definido pela combina√ß√£o entre um m√©todo HTTP e uma URI espec√≠fica. A
                                URI (Uniform Resource Identifier) √© o identificador que aponta para um recurso ‚Äî como
                                <code>/users</code>, <code>/products/10</code> ou <code>/auth/login</code>. Cada
                                endpoint da API possui sua pr√≥pria URI, que indica ao cliente exatamente qual recurso
                                est√° sendo acessado ou qual a√ß√£o ser√° executada. Em conjunto, m√©todo + URI determinam o
                                comportamento do endpoint e como a aplica√ß√£o ir√° responder a cada requisi√ß√£o.
                            </p>

                            <p>Exemplo de uma API com alguns endpoints (cada linha exibe a URI da endpoint):</p>

                            <pre><code class="language-json">
https://app.io/usuarios      ‚Üí URL do recurso "usuarios"
https://app.io/usuarios/12   ‚Üí URL do recurso "usuarios" com ID 12
https://app.io/boardgames    ‚Üí URL do recurso "boardgames"
</code></pre>

                            <p>
                                Para obter esses recursos em formato JSON, basta realizar uma requisi√ß√£o HTTP com o
                                verbo <strong>GET</strong>.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Route Params</h1>

                            <p>
                                Note a diferen√ßa entre a primeira e a segunda URL: a primeira retorna
                                <strong>todos</strong> os usu√°rios do banco de dados (ou de qualquer outra fonte que a
                                API consulte), enquanto a segunda retorna apenas um usu√°rio espec√≠fico. Essa √© a forma
                                mais comum de filtrar um recurso espec√≠fico na API, utilizando um
                                <strong>Route Param</strong>.
                            </p>

                            <p>
                                Route params, como o pr√≥prio nome sugere, s√£o par√¢metros
                                <strong>obrigat√≥rios</strong> da rota e aparecem na pr√≥pria URL. Em uma URL, tudo √©
                                sempre tratado como <strong>texto</strong>; ou seja, n√£o existe tipagem na URL em si. A
                                convers√£o do valor para um tipo espec√≠fico (como n√∫mero, boolean, etc.) √©
                                responsabilidade do framework da API.
                            </p>

                            <p>Veja este exemplo:</p>

                            <details>
                                <summary>Declarando uma endpoint com Node.js e Fastify</summary>
                                <p><code>app</code> √© a inst√¢ncia da API utilizando Fastify.</p>
                                <pre><code>
app.get(
    '/usuarios/:id',
    {
        schema: {
            params: {
                type: 'object',
                properties: {
                    id: { type: 'number', minimum: 0 }
                },
                required: ['id']
            }
        }
    },
    async (request, reply) => userController.getUsuarioById(request, reply)
);
    </code></pre>
                            </details>

                            <p>
                                No c√≥digo acima, estou declarando uma rota e definindo o tipo do par√¢metro
                                <code>:id</code> para que o <strong>Fastify</strong> fa√ßa a convers√£o e valida√ß√£o.
                                Tamb√©m foi definida uma regra (<code>minimum: 0</code>), e o pr√≥prio Fastify realizar√° a
                                valida√ß√£o automaticamente, retornando uma exce√ß√£o <strong>400</strong>
                                caso a regra seja violada.
                            </p>

                            <p>
                                Em termos conceituais, em uma URL absolutamente tudo √© representado como texto. Isso
                                acontece porque a URL √© apenas uma <strong>string codificada</strong> que o navegador
                                envia ao servidor. Mesmo que voc√™ escreva valores que parecem num√©ricos, como
                                <code>/usuarios/10</code> ou <code>/produtos/29.90</code>, eles ainda chegam para a API
                                como texto puro. Por exemplo, a URL <code>/calcular/2/3</code> envia os valores
                                <code>"2"</code> e <code>"3"</code> (como strings), e somente depois o framework
                                converte esses dados para <code>number</code>, <code>float</code>,
                                <code>boolean</code> ou qualquer outro tipo que voc√™ tenha definido.
                            </p>
                            <p>
                                Outro exemplo: se voc√™ enviar um nome com espa√ßo, como
                                <code>/usuarios/joao silva</code>, o navegador transforma isso em
                                <code>/usuarios/joao%20silva</code>, que tamb√©m √© apenas texto codificado. Portanto, a
                                URL por si s√≥ n√£o entende tipos ‚Äî ela transporta apenas strings, e cabe √† API
                                interpretar, validar e converter para o tipo apropriado.
                            </p>

                            <p>
                                Sobre boas pr√°ticas, recomenda-se que rotas sejam sempre nomeadas no
                                <strong>plural</strong> quando representam cole√ß√µes (ex.: <code>/usuarios</code>,
                                <code>/produtos</code>), e que route params sejam escritos no singular, representando um
                                item espec√≠fico da cole√ß√£o (ex.: <code>/usuarios/:id</code>).
                            </p>

                            <p>
                                Um "erro" muito comum em iniciante, √© criar uma rota no singular quando a mesma possui
                                um route param. Exemplo:
                            </p>

                            <pre><code>
https://app.io/usuarios     ‚Üí URL do recurso "usuarios"
https://app.io/usuario/12   ‚Üí URL do recurso "usuarios" com ID 12 (singular, pr√°tica incomum)
    </code></pre>

                            <p>
                                Isso n√£o √© um erro critico, ou algo que vai prejudicar sua API REST. Essas regras de
                                boas pr√°ticas n√£o foram definidas por algu√©m em especifico, n√£o existe na tese de Roy
                                Fielding um capitulo sobre "regras de nomeclaturas e mapeamentos" ou algo assim, isso
                                tudo √© um conjunto de conven√ß√µes amplamente aceitas pela comunidade REST ao longo dos
                                anos. Quando falamos de REST, quanto mais seguimos dentro desses padr√µes, melhor ser√° a
                                qualidade geral do c√≥digo da API.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Query Params</h1>

                            <p>
                                Outra forma de enviar par√¢metros em uma requisi√ß√£o GET √© usando
                                <strong>query params</strong>. A principal diferen√ßa entre query params e route params
                                est√° na <strong>obrigatoriedade</strong>. Route params fazem parte da estrutura da URL,
                                portanto s√£o obrigat√≥rios. J√° os query params s√£o opcionais por natureza ‚Äî eles s√≥ se
                                tornam obrigat√≥rios se voc√™ aplicar uma valida√ß√£o manual no seu backend.
                            </p>

                            <p>
                                Query params permitem enviar m√∫ltiplos par√¢metros com diferentes finalidades, como
                                filtros, pagina√ß√£o, ordena√ß√£o, busca textual, entre outros. Por exemplo:
                            </p>

                            <pre><code>
https://app.io/usuarios?nome=adriel&orderby=idade
‚Üí URL do recurso "usuarios", filtrando pelo nome "adriel" e ordenando por "idade".
</code></pre>

                            <p>
                                Diferentemente dos route params, que identificam um recurso espec√≠fico, os query params
                                n√£o alteram a identidade do recurso, apenas modificam a forma como o recurso ser√°
                                retornado ‚Äî por exemplo, filtrando, ordenando ou paginando os resultados. Essa diferen√ßa
                                √© importante para a consist√™ncia do design de APIs REST.
                            </p>

                            <p>
                                J√° me deparei com algumas aplica√ß√µes trafegando tokens, senhas e outras informa√ß√µes
                                sensiveis por query params. Obviamente isso √© uma pr√°tica <strong>ruim</strong> ‚Äî para
                                dizer o minimo. URLs podem vazar em: hist√≥ricos, logs de servidor, analytics, cache do
                                navegador e etc. Query params serve para compartilhar informa√ß√µes opcionais cujo o
                                objetivo √© refinar, filtrar ou alterar a resposta.
                            </p>

                            <p>Em query params √© possivel compartilhar listas, os principais padr√µes s√£o:</p>

                            <pre><code>
a) Repetindo a chave:

?categoria=acao&categoria=rpg&categoria=terror


b) Listas separadas por v√≠rgula:

?categoria=acao,rpg,terror


c) Arrays com sintaxe:

?categoria[]=acao&categoria[]=rpg</code></pre>

                            <p>
                                Mas cuidado, evite transformar URLS em um payload com enorme quantidade de informa√ß√£o.
                                Browsers normalmente suportam aproximadamente <strong>2000 caracteres</strong>.
                            </p>

                            <p>
                                Outra pr√°tica comum em query params s√£o os operadores expl√≠citos como
                                <code>gte</code> (maior ou igual), <code>lte</code> (menor ou igual),
                                <code>ne</code> (diferente) ou <code>in</code>. Um formato bastante usado √© o estilo
                                inspirado em
                                <a
                                    href="https://www.mongodb.com/pt-br/docs/manual/reference/mql/query-predicates/comparison"
                                    target="_blank"
                                    class="blog-link"
                                    >MongoDB</a
                                >: <code>?preco[gte]=100&amp;preco[lte]=300</code>. APIs mais simples usam conven√ß√µes
                                como <code>?minPreco=100&amp;maxPreco=300</code>. Exemplos:
                            </p>

                            <pre><code>
/usuarios?idade=30                    ‚Üí igualdade
/usuarios?idade[gte]=18               ‚Üí maior ou igual a 18
/usuarios?idade[lte]=65               ‚Üí menor ou igual a 65
/produtos?preco[gte]=10&preco[lte]=50 ‚Üí intervalo
</code></pre>

                            <p>
                                √â importante ressaltar que <strong>query params</strong> e
                                <strong>route params</strong> n√£o s√£o funcionalidades criadas pelo estilo arquitetural
                                REST. Na verdade, eles fazem parte da pr√≥pria especifica√ß√£o de URLs definida pelas RFCs
                                que padronizam a Web. Os <em>route params</em> s√£o apenas trechos vari√°veis do caminho
                                (path) da URL, definidos pela aplica√ß√£o, enquanto os <em>query params</em> s√£o
                                par√¢metros opcionais definidos pela
                                <a
                                    href="https://datatracker.ietf.org/doc/html/rfc3986"
                                    target="_blank"
                                    class="blog-link"
                                    >RFC 3986</a
                                >
                                para transmitir dados na parte ap√≥s o caractere <code>?</code>. Portanto, REST apenas
                                utiliza esses recursos j√° existentes na arquitetura da Web, mas n√£o os define.
                            </p>

                            <details>
                                <summary>Declarando um endpoint com query params</summary>
                                <pre><code>
app.get(
    '/usuarios',
    {
        schema: {
            querystring: {
                type: 'object',
                properties: {
                    page: { type: 'integer', minimum: 1, default: 1 },
                    limit: {
                        type: 'integer',
                        minimum: 1,
                        maximum: 10,
                        default: 10,
                    },
                },
            },
        },
    },
    async (request, reply) => userController.getUsuarios(request, reply)
);</code></pre>
                            </details>

                            <h1 class="h4 portfolio-title">GET - Pagina√ß√£o</h1>

                            <p>
                                A pagina√ß√£o √© uma t√©cnica usada para <strong>controlar</strong> a quantidade de dados
                                retornados em uma requisi√ß√£o. Sem ela, uma endpoint poderia enviar milhares de registros
                                de uma s√≥ vez, o que causaria diversos problemas: lentid√£o no servidor, uso excessivo de
                                banda, respostas muito grandes e um custo de processamento do payload muito alto no
                                client.
                            </p>

                            <p>
                                Existem v√°rias estrat√©gias de pagina√ß√£o, mas as mais comuns s√£o:
                                <strong>Offset Pagination</strong> e <strong>Keyset Pagination</strong>.
                            </p>

                            <p>
                                Na <strong>offset pagination</strong>, o servidor pula um conjunto de registros (offset)
                                e retorna um n√∫mero fixo de itens (limit). offset e limit, s√£o definidos como
                                <strong>query params</strong>. O par√¢metro <strong>page</strong> determina qual
                                <strong>p√°gina</strong> de resultados ser√° retornada, enquanto
                                <strong>limit</strong> define a <strong>quantidade</strong> de itens por p√°gina.
                            </p>

                            <p><strong>Exemplo de URL com pagina√ß√£o:</strong></p>

                            <pre><code >GET https://api.exemplo.com/usuarios?page=2&limit=10
</code></pre>

                            <p>Nesse caso, a API retornaria a segunda p√°gina contendo at√© 10 usu√°rios por p√°gina.</p>

                            <p>
                                Vale ressaltar que a pagina√ß√£o n√£o √© um recurso obrigat√≥rio para a endpoint funcionar.
                                Ou seja, caso o client n√£o envie os par√¢metros de pagina√ß√£o para a API, ela deve assumir
                                valores padr√£o, como por exemplo: <code>offset: 0</code> e <code>limit: 50</code>.
                            </p>

                            <p>
                                A pagina√ß√£o n√£o entra em conflito com os demais par√¢metros da query; portanto, a mesma
                                endpoint pode conter simultaneamente pagina√ß√£o e filtros.
                            </p>

                            <p>
                                A f√≥rmula para obter exatamente a p√°gina especificada pelo usu√°rio √© a seguinte:
                                <code>(page - 1) * limit</code>. Ap√≥s calcular esse valor, basta limitar o resultado
                                pela quantidade definida em <code>limit</code>.
                            </p>

                            <p>Veja um exemplo pr√°tico dessa f√≥rmula aplicada no ORM Prisma:</p>

                            <code>
                                <pre>
async getUsuarios(page: number, limit: number) {
    return await prisma.usuario.findMany({
        skip: (page - 1) * limit, // pulando (page - 1) p√°ginas
        take: limit,              // obtendo apenas a quantidade definida em limit
    });
}
</pre
                                >
                            </code>

                            <br />

                            <p>
                                A principal desvantagem dessa estrat√©gia √© a queda de desempenho em tabelas com grande
                                volume de dados. Um valor muito alto de <code>offset</code> pode tornar o processamento
                                lento, pois o banco precisa percorrer muitos registros antes de retornar os resultados.
                                Essa abordagem √© recomendada para datasets pequenos ou m√©dios, oferecendo boa precis√£o
                                de busca para o client.
                            </p>

                            <p>Veja o fluxo completo da cria√ß√£o de uma pagina√ß√£o em uma API node com fastify:</p>

                            <details>
                                <summary>Declarando a endpoint /usuarios com os par√¢metros "page" e "limit"</summary>
                                <pre><code>
app.get(
    '/usuarios',
    {
        schema: {
            querystring: {
                type: 'object',
                properties: {
                    page: { type: 'integer', minimum: 1, default: 1 },
                    limit: {
                        type: 'integer',
                        minimum: 1,
                        maximum: 10,
                        default: 10,
                    },
                },
            },
        },
    },
    async (request, reply) => userController.getUsuarios(request, reply)
);</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioController.ts</summary>
                                <pre><code>
async getUsuarios(
    request: FastifyRequest,
    reply: FastifyReply
): Promise&lt;UsuariosDto | undefined&gt; {
    try {
        const queryParams = request.query as {
            page?: string;
            limit?: string;
        };

        return reply.send(
            await this.usuarioService.getUsuarios(
                Number(queryParams.page),
                Number(queryParams.limit)
            )
        );
    } catch (error) {
        this.throwResponseException(error, reply);
    }
}
</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioService.ts</summary>
                                <p>
                                    Al√©m da pagina√ß√£o, implementei o <code>lookahead</code> que √© uma propriedade que
                                    sinaliza para o client a exist√™ncia da pr√≥xima p√°gina (hasNextPage).
                                </p>
                                <pre><code>
async getUsuarios(
    page: number,
    limit: number
): Promise&lt;UsuariosDto | null&gt; {
    try {
        // Offset pagination with lookahead
        const usuarios = await this.usuarioRepository.getUsuarios(
            page,
            limit
        );
        const hasNextPage = usuarios.length == limit + 1;

        usuarios.pop();

        const usuariosDto = {
            data: usuarios,
            meta: {
                page,
                limit,
                hasNextPage: hasNextPage,
            },
        } as UsuariosDto;

        return usuariosDto;
    } catch (error) {
        console.error('Erro interno ao consultar os usu√°rios.', error);

        throw new InternalError();
    }
}
</code></pre>
                            </details>

                            <details>
                                <summary>Declarando o m√©todo getUsuarios() em UsuarioRepository.ts</summary>
                                <p>
                                    Aqui, √© onde aplicamos a "f√≥rmula" da pagina√ß√£o, skipando os elementos e retornando
                                    apenas os especificados pelos par√¢metros da pagina√ß√£o.
                                </p>
                                <pre><code>
async getUsuarios(page: number, limit: number) {
    return await prisma.usuario.findMany({
        skip: (page - 1) * limit,
        take: limit + 1,
    });
}
</code></pre>
                            </details>

                            <p>
                                A outra estrat√©gia de pagina√ß√£o popular em API REST √© o
                                <strong>Keyset Pagination</strong> (tamb√©m chamada de <i>Cursor based pagination</i>).
                                Essa estrat√©gia consistem em navegar entre dos dados utilizando uma
                                <strong>chave de refer√™ncia</strong> ‚Äî normalmente o valor de uma coluna ordenada e
                                indexada, como id, created_at ou outra coluna monotonicamente crescente.
                            </p>

                            <p>Veja esse exemplo de keyset pagination:</p>

                            <pre><code>
Endpoint:
GET /items?limit=10

Response:
{
  "items": [...],
  "nextCursor": "2025-01-10T14:03:22Z"
}

Pr√≥ximo request:
GET /items?limit=10&cursor=2025-01-10T14:03:22Z

Query no backend:
SELECT *
FROM items
WHERE created_at > :cursor
ORDER BY created_at ASC
LIMIT 10;

Exemplo com ORM:
async getBoardgames(createdAt: Date | undefined, limit: number) {
    return await prisma.boardgame.findMany({
        where: {
            createdAt: {
                gte: createdAt,
            },
        },
        take: limit + 1,
    });
}
</code></pre>

                            <p>
                                Perceba que a consulta √© feita considerando apenas os dados criados ap√≥s a √∫ltima chave
                                recebida (<code>created_at > :cursor</code>). Com isso, evita-se o problema de
                                performance do offset pagination: nenhuma informa√ß√£o desnecess√°ria √© percorrida ou
                                ignorada manualmente (skip), tornando a pagina√ß√£o muito mais eficiente.
                            </p>

                            <p>
                                Normalmente, a estrat√©gia mais utilizada √© a keyset pagination, por ser melhor em termos
                                de perfomance.
                            </p>

                            <h1 class="h4 portfolio-title">GET - Caching</h1>

                            <p>
                                Cache √© um recurso utilizado para melhorar o desempenho da aplica√ß√£o, reduzindo o n√∫mero
                                de acessos ao banco de dados e acelerando o tempo de resposta das requisi√ß√µes.
                            </p>

                            <p>
                                Esse tema √© extenso, para falar de maneira completa precisaria de um artigo somente
                                dedicado a este tema, mas aqui vou apenas resumir um pouco dos conceitos e pr√°ticas.
                            </p>

                            <p>
                                Essa funcionalidade consiste em armazenar os dados requisitados em um banco de dados em
                                <strong>mem√≥ria</strong>. O mais comum √© usar o
                                <a href="https://redis.io" target="_blank" class="blog-link">Redis</a>, devido √† sua
                                alta performance e popularidade. Assim, quando os mesmos dados s√£o requisitados
                                novamente, a aplica√ß√£o consulta o cache em mem√≥ria em vez do banco de dados.
                            </p>

                            <p>
                                O armazenamento em mem√≥ria √© essencial porque o acesso a dados na mem√≥ria √© muito mais
                                r√°pido do que em disco. Isso torna o uso de cache uma solu√ß√£o eficiente para acelerar
                                chamadas frequentes de dados.
                            </p>

                            <p>Veja um exemplo do fluxo <strong>normal</strong> de uma chamada GET sem cache:</p>

                            <pre><code>
Cliente envia requisi√ß√£o GET ‚Üí Servidor recebe a requisi√ß√£o ‚Üí Servidor consulta o banco de dados ‚Üí Banco retorna os dados ‚Üí Servidor envia a resposta ao cliente
</code></pre>

                            <p>Agora, veja como o fluxo muda quando o cache est√° ativo:</p>

                            <pre><code>
Cliente envia requisi√ß√£o GET ‚Üí Servidor verifica se os dados est√£o no cache (Redis) 
  ‚Üí Se os dados estiverem no cache ‚Üí Servidor retorna os dados diretamente ao cliente
  ‚Üí Se n√£o estiverem no cache ‚Üí Servidor consulta o banco de dados ‚Üí Banco retorna os dados ‚Üí Servidor armazena os dados no cache ‚Üí Servidor envia a resposta ao cliente
</code></pre>

                            <p>
                                Perceba que o servidor consulta primeiro no cache, e somente se necess√°rio consulta o
                                banco de dados, esse √© a funcionalidade <strong>base</strong> da maioria das estrat√©gias
                                de cache eficientes.
                            </p>

                            <p>
                                Existem v√°rias formas de implementar cache em uma aplica√ß√£o web, e a mais comum √© a
                                estrat√©gia de
                                <strong>cache-aside</strong>, cujo fluxo foi descrito acima.
                            </p>

                            <p>
                                No entanto, o pr√≥prio protocolo HTTP j√° fornece mecanismos de caching. Assim, al√©m de
                                gerenciar o cache nas camadas internas do servidor utilizando Redis, tamb√©m podemos
                                utilizar o
                                <a
                                    href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Reference/Headers/Cache-Control"
                                    target="_blank"
                                    class="blog-link"
                                    >Cache-Control</a
                                >
                                para controlar o cache na camada da API. As APIs REST modernas geralmente combinam essas
                                estrat√©gias:
                                <strong>Redis + Cache-Control (HTTP)</strong>.
                            </p>

                            <p>
                                √â importante entender a diferen√ßa entre essas duas abordagens, pois, apesar de
                                frequentemente usadas juntas, elas s√£o conceitos distintos. O
                                <strong>cache-aside</strong> √© uma estrat√©gia do lado do servidor, que utiliza um banco
                                de dados em mem√≥ria como Redis ou Memcached para acelerar respostas. Essa solu√ß√£o √©
                                <strong>estritamente do servidor</strong> e n√£o envolve o cliente.
                            </p>

                            <p>
                                J√° o <strong>cache HTTP</strong> envolve o cliente de forma ativa. Nesse caso, os
                                navegadores, proxies ou CDNs podem armazenar as respostas das requisi√ß√µes e
                                reutiliz√°-las em chamadas futuras. O cabe√ßalho <code>Cache-Control</code> permite
                                configurar regras como:
                            </p>

                            <ul>
                                <li>
                                    <strong>max-age</strong>: tempo em segundos que a resposta pode ser considerada
                                    v√°lida.
                                </li>
                                <br />
                                <li>
                                    <strong>public/private</strong>: define se a resposta pode ser armazenada por caches
                                    compartilhados (CDNs) ou apenas pelo navegador do cliente.
                                </li>
                                <br />
                                <li>
                                    <strong>no-cache/no-store</strong>: instru√ß√µes para que a resposta n√£o seja
                                    reutilizada ou armazenada.
                                </li>
                                <br />
                            </ul>

                            <p>
                                Combinando essas duas estrat√©gias ‚Äî cache-aside para o servidor e cache HTTP para o
                                cliente ‚Äî √© poss√≠vel construir APIs REST modernas que respondem rapidamente e reduzem
                                significativamente a carga no banco de dados.
                            </p>

                            <p>
                                Mas, na pr√°tica, cerca de 90% das vezes os desenvolvedores web lidam apenas com o
                                <strong>cache-aside</strong>, no lado do servidor. J√° os mecanismos de
                                <strong>cache HTTP</strong> s√£o mais indicados para serem gerenciados pelo cliente ou
                                por camadas intermedi√°rias, como CDNs e proxies, atrav√©s de cabe√ßalhos como
                                <code>Cache-Control</code> e <code>ETag</code>. Tentar implementar a leitura de cache
                                HTTP manualmente na sua API n√£o √© recomendado, pois esses mecanismos j√° s√£o
                                interpretados automaticamente por navegadores e CDNs, tornando desnecess√°ria a l√≥gica
                                adicional no servidor.
                            </p>

                            <p>
                                Outro conceito importante de gerenciamento de cache √© a
                                <strong>invalida√ß√£o de cache</strong>, isto √©, dados que outrora eram √∫teis j√° est√£o
                                defazados e precisam ser removidos/invalidados para que novos entrem no lugar.
                            </p>

                            <p>Para entender isso visualize o seguinte cen√°rio:</p>

                            <pre><code>
1. O cliente faz um GET /produtos/42
   - A requisi√ß√£o passa pelo cache.
   - Como existe um registro armazenado, o cache retorna a vers√£o atual (mas antiga) do produto.
   - O cliente recebe os dados em milissegundos.

2. Um administrador atualiza o produto 42 no painel interno (ex.: altera pre√ßo de R$ 99 ‚Üí R$ 89).
   - A API grava o novo valor no banco de dados.
   - Por√©m, o mecanismo de cache ainda possui a vers√£o antiga.
   - Nenhuma invalida√ß√£o foi disparada automaticamente.

3. O mesmo cliente faz outro GET /produtos/42 alguns segundos depois.
   - O cache continua retornando a vers√£o antiga (pre√ßo R$ 99).
   - Do ponto de vista do cliente, o produto ‚Äúparece‚Äù n√£o ter sido atualizado.

4. Minutos depois, o TTL (Time To Live) do cache expira.
   - O cache marca o item como *stale* (obsoleto).
   - Na pr√≥xima requisi√ß√£o, o cache verifica que est√° expirado.
   - Ele encaminha a solicita√ß√£o ao servidor para obter a vers√£o mais recente.

5. O cliente faz um novo GET /produtos/42.
   - O cache detecta os dados como expirados.
   - A API retorna o pre√ßo correto (R$ 89).
   - O cache finalmente atualiza seu valor com a vers√£o mais recente.

Esse fluxo mostra claramente:
- como dados √∫teis podem se tornar rapidamente obsoletos;
- como o cliente continua recebendo informa√ß√µes antigas at√© que ocorra invalida√ß√£o ou expira√ß√£o;
- a import√¢ncia de mecanismos ativos de *cache invalidation* (ETags, versionamento, mensagens de evento etc.).</code></pre>
                            <br />

                            <p>
                                Em solu√ß√µes modernas, ferramentas como Redis e Memcached j√° oferecem mecanismos nativos
                                de <strong>TTL (Time to Live)</strong>, permitindo que itens armazenados expirem
                                automaticamente ap√≥s um per√≠odo definido.
                            </p>
                            <p>
                                Al√©m do TTL, existem outras estrat√©gias para lidar com dados inv√°lidos. Algumas
                                abordagens optam por <strong>atualizar o cache</strong> em vez de remov√™-lo
                                completamente, enquanto outras combinam atualiza√ß√£o e remo√ß√£o conforme o cen√°rio. Ainda
                                assim, o uso de TTL continua sendo a t√©cnica mais simples e amplamente adotada para
                                garantir a expira√ß√£o autom√°tica de informa√ß√µes.
                            </p>
                            <p>
                                Esses s√£o apenas os fundamentos do tema. O universo de caching √© bastante amplo, repleto
                                de conceitos, padr√µes e estrat√©gias diferentes. Explorar tudo em profundidade deixaria
                                este artigo excessivamente longo e desviaria do foco principal, por isso abordei apenas
                                o <strong>b√°sico</strong> que todo programador backend deve saber sobre caching.
                            </p>
                        </div>
                    </section>

                    <section class="working-in-progress"></section>
                </article>
            </div>
        </main>

        <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
        <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
        <script type="module" src="../../../assets/js/index.js"></script>
        <script type="module">
            import { loadSideBarBlog } from '../../assets/js/elements/sidebar.js';

            const sections = [
                { id: 'intro', label: 'Introdu√ß√£o' },
                { id: 'api', label: 'O que √© uma API' },
                { id: 'api-rest', label: 'O que √© uma API REST' },
                { id: 'stateless-vs-stateful', label: 'Stateless vs Stateful' },
                { id: 'get', label: 'GET' },
                { id: 'post', label: 'POST' },
                { id: 'put', label: 'PUT/PATCH' },
                { id: 'delete', label: 'DELETE' },
                { id: 'errors', label: 'Tratamento de exce√ß√µes' },
                { id: 'auth', label: 'Autentica√ß√£o' },
                { id: 'tests', label: 'Testes automatizados' },
                { id: 'conclusion', label: 'Conclus√£o' },
                { id: 'refs', label: 'Refer√™ncias' }
            ];

            loadSideBarBlog(sections);
        </script>
    </body>
</html>
